
kernel.bin:     file format elf32-i386


Disassembly of section .text:

00100000 <outb>:
//extern void outb(unsigned short port, unsigned char value);

void outb(unsigned short _port, unsigned char _data)
{
  100000:	55                   	push   %ebp
  100001:	89 e5                	mov    %esp,%ebp
  100003:	83 ec 08             	sub    $0x8,%esp
  100006:	8b 55 08             	mov    0x8(%ebp),%edx
  100009:	8b 45 0c             	mov    0xc(%ebp),%eax
  10000c:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
  100010:	88 45 f8             	mov    %al,-0x8(%ebp)
   __asm__ ("out %%al, %%dx" : : "a" (_data), "d" (_port));
  100013:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
  100017:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
  10001b:	ee                   	out    %al,(%dx)
}
  10001c:	c9                   	leave  
  10001d:	c3                   	ret    

0010001e <outportw>:

void outportw(unsigned _port, unsigned _data)
{
  10001e:	55                   	push   %ebp
  10001f:	89 e5                	mov    %esp,%ebp
	__asm__ ("out %%ax, %%dx" : : "a" (_data), "d" (_port));
  100021:	8b 45 0c             	mov    0xc(%ebp),%eax
  100024:	8b 55 08             	mov    0x8(%ebp),%edx
  100027:	66 ef                	out    %ax,(%dx)
}
  100029:	5d                   	pop    %ebp
  10002a:	c3                   	ret    

0010002b <inb>:


unsigned char inb(unsigned short _port)
{
  10002b:	55                   	push   %ebp
  10002c:	89 e5                	mov    %esp,%ebp
  10002e:	83 ec 14             	sub    $0x14,%esp
  100031:	8b 45 08             	mov    0x8(%ebp),%eax
  100034:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	unsigned char result;
	__asm__ ("in %%dx, %%al" : "=a" (result) : "d" (_port));
  100038:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
  10003c:	89 c2                	mov    %eax,%edx
  10003e:	ec                   	in     (%dx),%al
  10003f:	88 45 ff             	mov    %al,-0x1(%ebp)
	return result;
  100042:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
  100046:	c9                   	leave  
  100047:	c3                   	ret    

00100048 <clrscr>:
static unsigned long pos = 0;
static unsigned long row, col;
unsigned short attr = 0x07;


void clrscr(void) {
  100048:	55                   	push   %ebp
  100049:	89 e5                	mov    %esp,%ebp
  10004b:	83 ec 10             	sub    $0x10,%esp
	unsigned int i;
	for (i = 0; i < SCR_COLS * SCR_ROWS * 2; i += 2) {
  10004e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  100055:	eb 28                	jmp    10007f <clrscr+0x37>
		vid_mem[i] = ' ';
  100057:	8b 15 80 61 10 00    	mov    0x106180,%edx
  10005d:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100060:	01 d0                	add    %edx,%eax
  100062:	c6 00 20             	movb   $0x20,(%eax)
		vid_mem[i + 1] = attr;
  100065:	a1 80 61 10 00       	mov    0x106180,%eax
  10006a:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10006d:	83 c2 01             	add    $0x1,%edx
  100070:	01 d0                	add    %edx,%eax
  100072:	0f b7 15 84 61 10 00 	movzwl 0x106184,%edx
  100079:	88 10                	mov    %dl,(%eax)
unsigned short attr = 0x07;


void clrscr(void) {
	unsigned int i;
	for (i = 0; i < SCR_COLS * SCR_ROWS * 2; i += 2) {
  10007b:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
  10007f:	81 7d fc ff 0e 00 00 	cmpl   $0xeff,-0x4(%ebp)
  100086:	76 cf                	jbe    100057 <clrscr+0xf>
		vid_mem[i] = ' ';
		vid_mem[i + 1] = attr;
	}
}
  100088:	c9                   	leave  
  100089:	c3                   	ret    

0010008a <update_cursor>:

// update cursor position on screen //
void update_cursor(void) {
  10008a:	55                   	push   %ebp
  10008b:	89 e5                	mov    %esp,%ebp
  10008d:	83 ec 18             	sub    $0x18,%esp
	unsigned short offset;
	offset = (row * SCR_COLS + col);
  100090:	a1 04 80 10 00       	mov    0x108004,%eax
  100095:	89 c2                	mov    %eax,%edx
  100097:	89 d0                	mov    %edx,%eax
  100099:	c1 e0 02             	shl    $0x2,%eax
  10009c:	01 d0                	add    %edx,%eax
  10009e:	c1 e0 04             	shl    $0x4,%eax
  1000a1:	89 c2                	mov    %eax,%edx
  1000a3:	a1 08 80 10 00       	mov    0x108008,%eax
  1000a8:	01 d0                	add    %edx,%eax
  1000aa:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	outb(CRTC_IO_ADDR + 0, 0x0E);
  1000ae:	83 ec 08             	sub    $0x8,%esp
  1000b1:	6a 0e                	push   $0xe
  1000b3:	68 d4 03 00 00       	push   $0x3d4
  1000b8:	e8 43 ff ff ff       	call   100000 <outb>
  1000bd:	83 c4 10             	add    $0x10,%esp
	outb(CRTC_IO_ADDR + 1, offset >> 8);
  1000c0:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
  1000c4:	66 c1 e8 08          	shr    $0x8,%ax
  1000c8:	0f b6 c0             	movzbl %al,%eax
  1000cb:	83 ec 08             	sub    $0x8,%esp
  1000ce:	50                   	push   %eax
  1000cf:	68 d5 03 00 00       	push   $0x3d5
  1000d4:	e8 27 ff ff ff       	call   100000 <outb>
  1000d9:	83 c4 10             	add    $0x10,%esp
	outb(CRTC_IO_ADDR + 0, 0x0F);
  1000dc:	83 ec 08             	sub    $0x8,%esp
  1000df:	6a 0f                	push   $0xf
  1000e1:	68 d4 03 00 00       	push   $0x3d4
  1000e6:	e8 15 ff ff ff       	call   100000 <outb>
  1000eb:	83 c4 10             	add    $0x10,%esp
	outb(CRTC_IO_ADDR + 1, offset);
  1000ee:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
  1000f2:	0f b6 c0             	movzbl %al,%eax
  1000f5:	83 ec 08             	sub    $0x8,%esp
  1000f8:	50                   	push   %eax
  1000f9:	68 d5 03 00 00       	push   $0x3d5
  1000fe:	e8 fd fe ff ff       	call   100000 <outb>
  100103:	83 c4 10             	add    $0x10,%esp
}
  100106:	c9                   	leave  
  100107:	c3                   	ret    

00100108 <scroll2row>:

// hardware scrolling by changing framebuffer base addr //
void scroll2row() {
  100108:	55                   	push   %ebp
  100109:	89 e5                	mov    %esp,%ebp
  10010b:	83 ec 18             	sub    $0x18,%esp
	unsigned short lines;
	unsigned long offset;
	if (row > SCR_ROWS) {
  10010e:	a1 04 80 10 00       	mov    0x108004,%eax
  100113:	83 f8 18             	cmp    $0x18,%eax
  100116:	76 0e                	jbe    100126 <scroll2row+0x1e>
		lines = row - SCR_ROWS + 1;
  100118:	a1 04 80 10 00       	mov    0x108004,%eax
  10011d:	83 e8 17             	sub    $0x17,%eax
  100120:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
  100124:	eb 06                	jmp    10012c <scroll2row+0x24>
	} else {
		lines = 0;
  100126:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%ebp)
	}

	offset = lines * SCR_COLS;
  10012c:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
  100130:	89 d0                	mov    %edx,%eax
  100132:	c1 e0 02             	shl    $0x2,%eax
  100135:	01 d0                	add    %edx,%eax
  100137:	c1 e0 04             	shl    $0x4,%eax
  10013a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	outb(CRTC_IO_ADDR + 0, 0x0C);
  10013d:	83 ec 08             	sub    $0x8,%esp
  100140:	6a 0c                	push   $0xc
  100142:	68 d4 03 00 00       	push   $0x3d4
  100147:	e8 b4 fe ff ff       	call   100000 <outb>
  10014c:	83 c4 10             	add    $0x10,%esp
	outb(CRTC_IO_ADDR + 1, offset >> 8);
  10014f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  100152:	c1 e8 08             	shr    $0x8,%eax
  100155:	0f b6 c0             	movzbl %al,%eax
  100158:	83 ec 08             	sub    $0x8,%esp
  10015b:	50                   	push   %eax
  10015c:	68 d5 03 00 00       	push   $0x3d5
  100161:	e8 9a fe ff ff       	call   100000 <outb>
  100166:	83 c4 10             	add    $0x10,%esp
	outb(CRTC_IO_ADDR + 0, 0x0D);
  100169:	83 ec 08             	sub    $0x8,%esp
  10016c:	6a 0d                	push   $0xd
  10016e:	68 d4 03 00 00       	push   $0x3d4
  100173:	e8 88 fe ff ff       	call   100000 <outb>
  100178:	83 c4 10             	add    $0x10,%esp
	outb(CRTC_IO_ADDR + 1, offset & 0xFF);
  10017b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10017e:	0f b6 c0             	movzbl %al,%eax
  100181:	83 ec 08             	sub    $0x8,%esp
  100184:	50                   	push   %eax
  100185:	68 d5 03 00 00       	push   $0x3d5
  10018a:	e8 71 fe ff ff       	call   100000 <outb>
  10018f:	83 c4 10             	add    $0x10,%esp
}
  100192:	c9                   	leave  
  100193:	c3                   	ret    

00100194 <scroll_up>:

void scroll_up() {
  100194:	55                   	push   %ebp
  100195:	89 e5                	mov    %esp,%ebp
  100197:	83 ec 08             	sub    $0x8,%esp
	row = 0;
  10019a:	c7 05 04 80 10 00 00 	movl   $0x0,0x108004
  1001a1:	00 00 00 
	scroll2row();
  1001a4:	e8 5f ff ff ff       	call   100108 <scroll2row>
}
  1001a9:	c9                   	leave  
  1001aa:	c3                   	ret    

001001ab <scroll_down>:

void scroll_down() {
  1001ab:	55                   	push   %ebp
  1001ac:	89 e5                	mov    %esp,%ebp
  1001ae:	83 ec 08             	sub    $0x8,%esp
	row = SCR_ROWS;
  1001b1:	c7 05 04 80 10 00 18 	movl   $0x18,0x108004
  1001b8:	00 00 00 
	scroll2row();
  1001bb:	e8 48 ff ff ff       	call   100108 <scroll2row>
}
  1001c0:	c9                   	leave  
  1001c1:	c3                   	ret    

001001c2 <gotoxy>:

void gotoxy(void) {
  1001c2:	55                   	push   %ebp
  1001c3:	89 e5                	mov    %esp,%ebp
  1001c5:	83 ec 08             	sub    $0x8,%esp
	if (col >= SCR_COLS) {
  1001c8:	a1 08 80 10 00       	mov    0x108008,%eax
  1001cd:	83 f8 4f             	cmp    $0x4f,%eax
  1001d0:	76 17                	jbe    1001e9 <gotoxy+0x27>
		row++;
  1001d2:	a1 04 80 10 00       	mov    0x108004,%eax
  1001d7:	83 c0 01             	add    $0x1,%eax
  1001da:	a3 04 80 10 00       	mov    %eax,0x108004
		col = 0;
  1001df:	c7 05 08 80 10 00 00 	movl   $0x0,0x108008
  1001e6:	00 00 00 
	}
	if (row >= SCR_ROWS) {
//		console_up();
	}
	pos = (row * SCR_COLS + col) * 2;
  1001e9:	8b 15 04 80 10 00    	mov    0x108004,%edx
  1001ef:	89 d0                	mov    %edx,%eax
  1001f1:	c1 e0 02             	shl    $0x2,%eax
  1001f4:	01 d0                	add    %edx,%eax
  1001f6:	c1 e0 04             	shl    $0x4,%eax
  1001f9:	89 c2                	mov    %eax,%edx
  1001fb:	a1 08 80 10 00       	mov    0x108008,%eax
  100200:	01 d0                	add    %edx,%eax
  100202:	01 c0                	add    %eax,%eax
  100204:	a3 00 80 10 00       	mov    %eax,0x108000
	scroll2row();
  100209:	e8 fa fe ff ff       	call   100108 <scroll2row>
	update_cursor();
  10020e:	e8 77 fe ff ff       	call   10008a <update_cursor>
}
  100213:	c9                   	leave  
  100214:	c3                   	ret    

00100215 <clr2eol>:

void clr2eol(void) {
  100215:	55                   	push   %ebp
  100216:	89 e5                	mov    %esp,%ebp
  100218:	83 ec 08             	sub    $0x8,%esp
	for (; col < SCR_COLS; col++) {
  10021b:	eb 3b                	jmp    100258 <clr2eol+0x43>
		gotoxy();
  10021d:	e8 a0 ff ff ff       	call   1001c2 <gotoxy>
		vid_mem[pos] = ' ';
  100222:	8b 15 80 61 10 00    	mov    0x106180,%edx
  100228:	a1 00 80 10 00       	mov    0x108000,%eax
  10022d:	01 d0                	add    %edx,%eax
  10022f:	c6 00 20             	movb   $0x20,(%eax)
		vid_mem[pos + 1] = attr;
  100232:	a1 80 61 10 00       	mov    0x106180,%eax
  100237:	8b 15 00 80 10 00    	mov    0x108000,%edx
  10023d:	83 c2 01             	add    $0x1,%edx
  100240:	01 d0                	add    %edx,%eax
  100242:	0f b7 15 84 61 10 00 	movzwl 0x106184,%edx
  100249:	88 10                	mov    %dl,(%eax)
	scroll2row();
	update_cursor();
}

void clr2eol(void) {
	for (; col < SCR_COLS; col++) {
  10024b:	a1 08 80 10 00       	mov    0x108008,%eax
  100250:	83 c0 01             	add    $0x1,%eax
  100253:	a3 08 80 10 00       	mov    %eax,0x108008
  100258:	a1 08 80 10 00       	mov    0x108008,%eax
  10025d:	83 f8 4f             	cmp    $0x4f,%eax
  100260:	76 bb                	jbe    10021d <clr2eol+0x8>
		gotoxy();
		vid_mem[pos] = ' ';
		vid_mem[pos + 1] = attr;
	}
}
  100262:	c9                   	leave  
  100263:	c3                   	ret    

00100264 <clr2sol>:

void clr2sol(void) {
  100264:	55                   	push   %ebp
  100265:	89 e5                	mov    %esp,%ebp
  100267:	83 ec 08             	sub    $0x8,%esp
	for (; col > 0; col--) {
  10026a:	eb 3b                	jmp    1002a7 <clr2sol+0x43>
		gotoxy();
  10026c:	e8 51 ff ff ff       	call   1001c2 <gotoxy>
		vid_mem[pos] = ' ';
  100271:	8b 15 80 61 10 00    	mov    0x106180,%edx
  100277:	a1 00 80 10 00       	mov    0x108000,%eax
  10027c:	01 d0                	add    %edx,%eax
  10027e:	c6 00 20             	movb   $0x20,(%eax)
		vid_mem[pos + 1] = attr;
  100281:	a1 80 61 10 00       	mov    0x106180,%eax
  100286:	8b 15 00 80 10 00    	mov    0x108000,%edx
  10028c:	83 c2 01             	add    $0x1,%edx
  10028f:	01 d0                	add    %edx,%eax
  100291:	0f b7 15 84 61 10 00 	movzwl 0x106184,%edx
  100298:	88 10                	mov    %dl,(%eax)
		vid_mem[pos + 1] = attr;
	}
}

void clr2sol(void) {
	for (; col > 0; col--) {
  10029a:	a1 08 80 10 00       	mov    0x108008,%eax
  10029f:	83 e8 01             	sub    $0x1,%eax
  1002a2:	a3 08 80 10 00       	mov    %eax,0x108008
  1002a7:	a1 08 80 10 00       	mov    0x108008,%eax
  1002ac:	85 c0                	test   %eax,%eax
  1002ae:	75 bc                	jne    10026c <clr2sol+0x8>
		gotoxy();
		vid_mem[pos] = ' ';
		vid_mem[pos + 1] = attr;
	}
}
  1002b0:	c9                   	leave  
  1002b1:	c3                   	ret    

001002b2 <put_tab>:

void put_tab(void) {
  1002b2:	55                   	push   %ebp
  1002b3:	89 e5                	mov    %esp,%ebp
  1002b5:	83 ec 18             	sub    $0x18,%esp
	unsigned int max;
	for (max = col + TAB_SPACES; col < max; col++) {
  1002b8:	a1 08 80 10 00       	mov    0x108008,%eax
  1002bd:	83 c0 04             	add    $0x4,%eax
  1002c0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1002c3:	eb 3b                	jmp    100300 <put_tab+0x4e>
		gotoxy();
  1002c5:	e8 f8 fe ff ff       	call   1001c2 <gotoxy>
		vid_mem[pos] = ' ';
  1002ca:	8b 15 80 61 10 00    	mov    0x106180,%edx
  1002d0:	a1 00 80 10 00       	mov    0x108000,%eax
  1002d5:	01 d0                	add    %edx,%eax
  1002d7:	c6 00 20             	movb   $0x20,(%eax)
		vid_mem[pos + 1] = attr;
  1002da:	a1 80 61 10 00       	mov    0x106180,%eax
  1002df:	8b 15 00 80 10 00    	mov    0x108000,%edx
  1002e5:	83 c2 01             	add    $0x1,%edx
  1002e8:	01 d0                	add    %edx,%eax
  1002ea:	0f b7 15 84 61 10 00 	movzwl 0x106184,%edx
  1002f1:	88 10                	mov    %dl,(%eax)
	}
}

void put_tab(void) {
	unsigned int max;
	for (max = col + TAB_SPACES; col < max; col++) {
  1002f3:	a1 08 80 10 00       	mov    0x108008,%eax
  1002f8:	83 c0 01             	add    $0x1,%eax
  1002fb:	a3 08 80 10 00       	mov    %eax,0x108008
  100300:	a1 08 80 10 00       	mov    0x108008,%eax
  100305:	3b 45 f4             	cmp    -0xc(%ebp),%eax
  100308:	72 bb                	jb     1002c5 <put_tab+0x13>
		gotoxy();
		vid_mem[pos] = ' ';
		vid_mem[pos + 1] = attr;
	}
}
  10030a:	c9                   	leave  
  10030b:	c3                   	ret    

0010030c <console_write>:

//
//	No tty like write yet
//
void console_write(char *str) {
  10030c:	55                   	push   %ebp
  10030d:	89 e5                	mov    %esp,%ebp
  10030f:	83 ec 08             	sub    $0x8,%esp
	for (; *str; str++) {
  100312:	e9 81 00 00 00       	jmp    100398 <console_write+0x8c>

		switch (*str) {
  100317:	8b 45 08             	mov    0x8(%ebp),%eax
  10031a:	0f b6 00             	movzbl (%eax),%eax
  10031d:	0f be c0             	movsbl %al,%eax
  100320:	83 f8 0a             	cmp    $0xa,%eax
  100323:	74 13                	je     100338 <console_write+0x2c>
  100325:	83 f8 0d             	cmp    $0xd,%eax
  100328:	74 07                	je     100331 <console_write+0x25>
  10032a:	83 f8 09             	cmp    $0x9,%eax
  10032d:	74 10                	je     10033f <console_write+0x33>
  10032f:	eb 15                	jmp    100346 <console_write+0x3a>
			case '\r':
				clr2sol();
  100331:	e8 2e ff ff ff       	call   100264 <clr2sol>
				break;
  100336:	eb 57                	jmp    10038f <console_write+0x83>

			case '\n':
				clr2eol();
  100338:	e8 d8 fe ff ff       	call   100215 <clr2eol>
				break;
  10033d:	eb 50                	jmp    10038f <console_write+0x83>

			case '\t':
				put_tab();
  10033f:	e8 6e ff ff ff       	call   1002b2 <put_tab>
				break;
  100344:	eb 49                	jmp    10038f <console_write+0x83>

			default:
				vid_mem[pos] = *str;
  100346:	8b 15 80 61 10 00    	mov    0x106180,%edx
  10034c:	a1 00 80 10 00       	mov    0x108000,%eax
  100351:	01 c2                	add    %eax,%edx
  100353:	8b 45 08             	mov    0x8(%ebp),%eax
  100356:	0f b6 00             	movzbl (%eax),%eax
  100359:	88 02                	mov    %al,(%edx)
				vid_mem[pos + 1] = attr;
  10035b:	a1 80 61 10 00       	mov    0x106180,%eax
  100360:	8b 15 00 80 10 00    	mov    0x108000,%edx
  100366:	83 c2 01             	add    $0x1,%edx
  100369:	01 d0                	add    %edx,%eax
  10036b:	0f b7 15 84 61 10 00 	movzwl 0x106184,%edx
  100372:	88 10                	mov    %dl,(%eax)
				pos += 1;
  100374:	a1 00 80 10 00       	mov    0x108000,%eax
  100379:	83 c0 01             	add    $0x1,%eax
  10037c:	a3 00 80 10 00       	mov    %eax,0x108000
				col++;
  100381:	a1 08 80 10 00       	mov    0x108008,%eax
  100386:	83 c0 01             	add    $0x1,%eax
  100389:	a3 08 80 10 00       	mov    %eax,0x108008
				break;
  10038e:	90                   	nop
		}
		gotoxy();
  10038f:	e8 2e fe ff ff       	call   1001c2 <gotoxy>

//
//	No tty like write yet
//
void console_write(char *str) {
	for (; *str; str++) {
  100394:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  100398:	8b 45 08             	mov    0x8(%ebp),%eax
  10039b:	0f b6 00             	movzbl (%eax),%eax
  10039e:	84 c0                	test   %al,%al
  1003a0:	0f 85 71 ff ff ff    	jne    100317 <console_write+0xb>
				col++;
				break;
		}
		gotoxy();
	}
}
  1003a6:	c9                   	leave  
  1003a7:	c3                   	ret    

001003a8 <kprintf>:


void kprintf(char *fmt, ...) {
  1003a8:	55                   	push   %ebp
  1003a9:	89 e5                	mov    %esp,%ebp
  1003ab:	81 ec 18 04 00 00    	sub    $0x418,%esp
	char buf[1024];
	va_list args;

	va_start(args, fmt);
  1003b1:	8d 45 0c             	lea    0xc(%ebp),%eax
  1003b4:	89 45 f4             	mov    %eax,-0xc(%ebp)
	vsprintf(buf, fmt, args);
  1003b7:	8b 45 08             	mov    0x8(%ebp),%eax
  1003ba:	83 ec 04             	sub    $0x4,%esp
  1003bd:	ff 75 f4             	pushl  -0xc(%ebp)
  1003c0:	50                   	push   %eax
  1003c1:	8d 85 f4 fb ff ff    	lea    -0x40c(%ebp),%eax
  1003c7:	50                   	push   %eax
  1003c8:	e8 63 41 00 00       	call   104530 <vsprintf>
  1003cd:	83 c4 10             	add    $0x10,%esp
	va_end(args);

	console_write(buf);
  1003d0:	83 ec 0c             	sub    $0xc,%esp
  1003d3:	8d 85 f4 fb ff ff    	lea    -0x40c(%ebp),%eax
  1003d9:	50                   	push   %eax
  1003da:	e8 2d ff ff ff       	call   10030c <console_write>
  1003df:	83 c4 10             	add    $0x10,%esp
	serial_write(buf);
  1003e2:	83 ec 0c             	sub    $0xc,%esp
  1003e5:	8d 85 f4 fb ff ff    	lea    -0x40c(%ebp),%eax
  1003eb:	50                   	push   %eax
  1003ec:	e8 af 13 00 00       	call   1017a0 <serial_write>
  1003f1:	83 c4 10             	add    $0x10,%esp
	return;
  1003f4:	90                   	nop
}
  1003f5:	c9                   	leave  
  1003f6:	c3                   	ret    

001003f7 <console_init>:


void console_init(void) {
  1003f7:	55                   	push   %ebp
  1003f8:	89 e5                	mov    %esp,%ebp
  1003fa:	83 ec 08             	sub    $0x8,%esp
	clrscr();
  1003fd:	e8 46 fc ff ff       	call   100048 <clrscr>
	row = 0;
  100402:	c7 05 04 80 10 00 00 	movl   $0x0,0x108004
  100409:	00 00 00 
	col = 0;
  10040c:	c7 05 08 80 10 00 00 	movl   $0x0,0x108008
  100413:	00 00 00 
	pos = 0;
  100416:	c7 05 00 80 10 00 00 	movl   $0x0,0x108000
  10041d:	00 00 00 
	gotoxy();
  100420:	e8 9d fd ff ff       	call   1001c2 <gotoxy>
}
  100425:	c9                   	leave  
  100426:	c3                   	ret    

00100427 <setxy>:


void setxy(unsigned long r, unsigned long c) {
  100427:	55                   	push   %ebp
  100428:	89 e5                	mov    %esp,%ebp
  10042a:	83 ec 08             	sub    $0x8,%esp
	row = r;
  10042d:	8b 45 08             	mov    0x8(%ebp),%eax
  100430:	a3 04 80 10 00       	mov    %eax,0x108004
	col = c;
  100435:	8b 45 0c             	mov    0xc(%ebp),%eax
  100438:	a3 08 80 10 00       	mov    %eax,0x108008
	gotoxy();
  10043d:	e8 80 fd ff ff       	call   1001c2 <gotoxy>
}
  100442:	c9                   	leave  
  100443:	c3                   	ret    

00100444 <panic>:

void panic(char *fmt, ...) {
  100444:	55                   	push   %ebp
  100445:	89 e5                	mov    %esp,%ebp
  100447:	81 ec 18 04 00 00    	sub    $0x418,%esp
	char buf[1024];
	va_list args;
	va_start(args, fmt);
  10044d:	8d 45 0c             	lea    0xc(%ebp),%eax
  100450:	89 45 f4             	mov    %eax,-0xc(%ebp)
	vsprintf(buf, fmt, args);
  100453:	8b 45 08             	mov    0x8(%ebp),%eax
  100456:	83 ec 04             	sub    $0x4,%esp
  100459:	ff 75 f4             	pushl  -0xc(%ebp)
  10045c:	50                   	push   %eax
  10045d:	8d 85 f4 fb ff ff    	lea    -0x40c(%ebp),%eax
  100463:	50                   	push   %eax
  100464:	e8 c7 40 00 00       	call   104530 <vsprintf>
  100469:	83 c4 10             	add    $0x10,%esp
	va_end(args);
	console_write(buf);
  10046c:	83 ec 0c             	sub    $0xc,%esp
  10046f:	8d 85 f4 fb ff ff    	lea    -0x40c(%ebp),%eax
  100475:	50                   	push   %eax
  100476:	e8 91 fe ff ff       	call   10030c <console_write>
  10047b:	83 c4 10             	add    $0x10,%esp
	halt();
  10047e:	e8 58 03 00 00       	call   1007db <halt>
}
  100483:	c9                   	leave  
  100484:	c3                   	ret    

00100485 <list_root>:
fs_node_t *fs_root;
unsigned int initrd_location, initrd_end;
unsigned int stack_ptr, stack_size;

void list_root(fs_node_t *fs_root)
{
  100485:	55                   	push   %ebp
  100486:	89 e5                	mov    %esp,%ebp
  100488:	83 ec 18             	sub    $0x18,%esp
	// list the contents of //
	unsigned int i = 0;
  10048b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct dirent *node = 0;
  100492:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	while((node = readdir_fs(fs_root, i))) {
  100499:	eb 78                	jmp    100513 <list_root+0x8e>
		kprintf("Found file %s\n", node->name);
  10049b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10049e:	83 ec 08             	sub    $0x8,%esp
  1004a1:	50                   	push   %eax
  1004a2:	68 80 63 10 00       	push   $0x106380
  1004a7:	e8 fc fe ff ff       	call   1003a8 <kprintf>
  1004ac:	83 c4 10             	add    $0x10,%esp
		fs_node_t *fs_node = finddir_fs(fs_root, node->name);
  1004af:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1004b2:	83 ec 08             	sub    $0x8,%esp
  1004b5:	50                   	push   %eax
  1004b6:	ff 75 08             	pushl  0x8(%ebp)
  1004b9:	e8 0a 31 00 00       	call   1035c8 <finddir_fs>
  1004be:	83 c4 10             	add    $0x10,%esp
  1004c1:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if(fs_node->flags & FS_DIRECTORY) {
  1004c4:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1004c7:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
  1004cd:	83 e0 02             	and    $0x2,%eax
  1004d0:	85 c0                	test   %eax,%eax
  1004d2:	74 16                	je     1004ea <list_root+0x65>
			kprintf("\tDir %s\t\n", fs_node->name);
  1004d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1004d7:	83 ec 08             	sub    $0x8,%esp
  1004da:	50                   	push   %eax
  1004db:	68 8f 63 10 00       	push   $0x10638f
  1004e0:	e8 c3 fe ff ff       	call   1003a8 <kprintf>
  1004e5:	83 c4 10             	add    $0x10,%esp
  1004e8:	eb 25                	jmp    10050f <list_root+0x8a>
		} else {
			// char buff[256];
			// unsigned int size, offs = 0;
			kprintf("name: %s, inode: %d, length: %d\n", fs_node->name, fs_node->inode, fs_node->length);
  1004ea:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1004ed:	8b 88 94 00 00 00    	mov    0x94(%eax),%ecx
  1004f3:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1004f6:	8b 90 90 00 00 00    	mov    0x90(%eax),%edx
  1004fc:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1004ff:	51                   	push   %ecx
  100500:	52                   	push   %edx
  100501:	50                   	push   %eax
  100502:	68 9c 63 10 00       	push   $0x10639c
  100507:	e8 9c fe ff ff       	call   1003a8 <kprintf>
  10050c:	83 c4 10             	add    $0x10,%esp
			// 	size = read_fs(fs_node, offs, 256, buff);
			// 	kprintf("%s", buff);
			// 	offs+=size;
			// } while(size > 0);
		}
		i++;
  10050f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
void list_root(fs_node_t *fs_root)
{
	// list the contents of //
	unsigned int i = 0;
	struct dirent *node = 0;
	while((node = readdir_fs(fs_root, i))) {
  100513:	83 ec 08             	sub    $0x8,%esp
  100516:	ff 75 f4             	pushl  -0xc(%ebp)
  100519:	ff 75 08             	pushl  0x8(%ebp)
  10051c:	e8 64 30 00 00       	call   103585 <readdir_fs>
  100521:	83 c4 10             	add    $0x10,%esp
  100524:	89 45 f0             	mov    %eax,-0x10(%ebp)
  100527:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  10052b:	0f 85 6a ff ff ff    	jne    10049b <list_root+0x16>
			// 	offs+=size;
			// } while(size > 0);
		}
		i++;
	}
}
  100531:	c9                   	leave  
  100532:	c3                   	ret    

00100533 <shutdown>:


void shutdown()
{
  100533:	55                   	push   %ebp
  100534:	89 e5                	mov    %esp,%ebp
  100536:	83 ec 18             	sub    $0x18,%esp
	char *c = "Shutdown";
  100539:	c7 45 f4 bd 63 10 00 	movl   $0x1063bd,-0xc(%ebp)
	while (*c) { outb(0x8900, *c++); }
  100540:	eb 20                	jmp    100562 <shutdown+0x2f>
  100542:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100545:	8d 50 01             	lea    0x1(%eax),%edx
  100548:	89 55 f4             	mov    %edx,-0xc(%ebp)
  10054b:	0f b6 00             	movzbl (%eax),%eax
  10054e:	0f b6 c0             	movzbl %al,%eax
  100551:	83 ec 08             	sub    $0x8,%esp
  100554:	50                   	push   %eax
  100555:	68 00 89 00 00       	push   $0x8900
  10055a:	e8 a1 fa ff ff       	call   100000 <outb>
  10055f:	83 c4 10             	add    $0x10,%esp
  100562:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100565:	0f b6 00             	movzbl (%eax),%eax
  100568:	84 c0                	test   %al,%al
  10056a:	75 d6                	jne    100542 <shutdown+0xf>
}
  10056c:	c9                   	leave  
  10056d:	c3                   	ret    

0010056e <main>:

extern int get_flags();
extern unsigned int get_esp();

void test_user_mode();
void main(unsigned int magic, multiboot_header *mboot, unsigned int ssize, unsigned int sptr) {
  10056e:	8d 4c 24 04          	lea    0x4(%esp),%ecx
  100572:	83 e4 f0             	and    $0xfffffff0,%esp
  100575:	ff 71 fc             	pushl  -0x4(%ecx)
  100578:	55                   	push   %ebp
  100579:	89 e5                	mov    %esp,%ebp
  10057b:	53                   	push   %ebx
  10057c:	51                   	push   %ecx
  10057d:	89 cb                	mov    %ecx,%ebx
	stack_ptr = sptr;
  10057f:	8b 43 0c             	mov    0xc(%ebx),%eax
  100582:	a3 e8 c0 10 00       	mov    %eax,0x10c0e8
	stack_size = ssize;
  100587:	8b 43 08             	mov    0x8(%ebx),%eax
  10058a:	a3 f4 c0 10 00       	mov    %eax,0x10c0f4

	console_init();
  10058f:	e8 63 fe ff ff       	call   1003f7 <console_init>
	serial_init();
  100594:	e8 75 12 00 00       	call   10180e <serial_init>

	multiboot_parse(magic, mboot);
  100599:	83 ec 08             	sub    $0x8,%esp
  10059c:	ff 73 04             	pushl  0x4(%ebx)
  10059f:	ff 33                	pushl  (%ebx)
  1005a1:	e8 47 04 00 00       	call   1009ed <multiboot_parse>
  1005a6:	83 c4 10             	add    $0x10,%esp
	kprintf("cOSiris\n");
  1005a9:	83 ec 0c             	sub    $0xc,%esp
  1005ac:	68 c6 63 10 00       	push   $0x1063c6
  1005b1:	e8 f2 fd ff ff       	call   1003a8 <kprintf>
  1005b6:	83 c4 10             	add    $0x10,%esp

	get_kernel_info(&kinfo);
  1005b9:	83 ec 0c             	sub    $0xc,%esp
  1005bc:	68 20 c0 10 00       	push   $0x10c020
  1005c1:	e8 dd 01 00 00       	call   1007a3 <get_kernel_info>
  1005c6:	83 c4 10             	add    $0x10,%esp
	kprintf("Kernel info:\n");
  1005c9:	83 ec 0c             	sub    $0xc,%esp
  1005cc:	68 cf 63 10 00       	push   $0x1063cf
  1005d1:	e8 d2 fd ff ff       	call   1003a8 <kprintf>
  1005d6:	83 c4 10             	add    $0x10,%esp
	kprintf("\tcode start: 0x%X, start entry: 0x%X, data start: 0x%X\n", kinfo.code, kinfo.start, kinfo.data);
  1005d9:	8b 0d 28 c0 10 00    	mov    0x10c028,%ecx
  1005df:	8b 15 24 c0 10 00    	mov    0x10c024,%edx
  1005e5:	a1 20 c0 10 00       	mov    0x10c020,%eax
  1005ea:	51                   	push   %ecx
  1005eb:	52                   	push   %edx
  1005ec:	50                   	push   %eax
  1005ed:	68 e0 63 10 00       	push   $0x1063e0
  1005f2:	e8 b1 fd ff ff       	call   1003a8 <kprintf>
  1005f7:	83 c4 10             	add    $0x10,%esp
	kprintf("\tbss start: 0x%X, end: 0x%X, total size: %i bytes\n", kinfo.bss, kinfo.end, kinfo.size);
  1005fa:	8b 0d 34 c0 10 00    	mov    0x10c034,%ecx
  100600:	8b 15 30 c0 10 00    	mov    0x10c030,%edx
  100606:	a1 2c c0 10 00       	mov    0x10c02c,%eax
  10060b:	51                   	push   %ecx
  10060c:	52                   	push   %edx
  10060d:	50                   	push   %eax
  10060e:	68 18 64 10 00       	push   $0x106418
  100613:	e8 90 fd ff ff       	call   1003a8 <kprintf>
  100618:	83 c4 10             	add    $0x10,%esp
	kprintf("\tstack: %p, size: %p\n", kinfo.stack, kinfo.stack_size);
  10061b:	8b 15 3c c0 10 00    	mov    0x10c03c,%edx
  100621:	a1 38 c0 10 00       	mov    0x10c038,%eax
  100626:	83 ec 04             	sub    $0x4,%esp
  100629:	52                   	push   %edx
  10062a:	50                   	push   %eax
  10062b:	68 4b 64 10 00       	push   $0x10644b
  100630:	e8 73 fd ff ff       	call   1003a8 <kprintf>
  100635:	83 c4 10             	add    $0x10,%esp
	kprintf("Setup gdt entries\n");
  100638:	83 ec 0c             	sub    $0xc,%esp
  10063b:	68 61 64 10 00       	push   $0x106461
  100640:	e8 63 fd ff ff       	call   1003a8 <kprintf>
  100645:	83 c4 10             	add    $0x10,%esp
	gdt_init();
  100648:	e8 55 05 00 00       	call   100ba2 <gdt_init>

	kprintf("Setup idt entries\n");
  10064d:	83 ec 0c             	sub    $0xc,%esp
  100650:	68 74 64 10 00       	push   $0x106474
  100655:	e8 4e fd ff ff       	call   1003a8 <kprintf>
  10065a:	83 c4 10             	add    $0x10,%esp
	idt_init();
  10065d:	e8 d7 06 00 00       	call   100d39 <idt_init>

	kprintf("Setup isr\n");
  100662:	83 ec 0c             	sub    $0xc,%esp
  100665:	68 87 64 10 00       	push   $0x106487
  10066a:	e8 39 fd ff ff       	call   1003a8 <kprintf>
  10066f:	83 c4 10             	add    $0x10,%esp
	isr_init();
  100672:	e8 f9 06 00 00       	call   100d70 <isr_init>

	kprintf("Setup irq\n");
  100677:	83 ec 0c             	sub    $0xc,%esp
  10067a:	68 92 64 10 00       	push   $0x106492
  10067f:	e8 24 fd ff ff       	call   1003a8 <kprintf>
  100684:	83 c4 10             	add    $0x10,%esp
	irq_install();
  100687:	e8 79 0c 00 00       	call   101305 <irq_install>

	sti();
  10068c:	fb                   	sti    

	kprintf("Setup timer\n");
  10068d:	83 ec 0c             	sub    $0xc,%esp
  100690:	68 9d 64 10 00       	push   $0x10649d
  100695:	e8 0e fd ff ff       	call   1003a8 <kprintf>
  10069a:	83 c4 10             	add    $0x10,%esp
	timer_install();
  10069d:	e8 ac 0e 00 00       	call   10154e <timer_install>

	kprintf("Calibrating delay loop: %d loops/ms\n", calibrate_delay_loop());
  1006a2:	e8 27 12 00 00       	call   1018ce <calibrate_delay_loop>
  1006a7:	83 ec 08             	sub    $0x8,%esp
  1006aa:	50                   	push   %eax
  1006ab:	68 ac 64 10 00       	push   $0x1064ac
  1006b0:	e8 f3 fc ff ff       	call   1003a8 <kprintf>
  1006b5:	83 c4 10             	add    $0x10,%esp

	kprintf("Setup keyboard\n");
  1006b8:	83 ec 0c             	sub    $0xc,%esp
  1006bb:	68 d1 64 10 00       	push   $0x1064d1
  1006c0:	e8 e3 fc ff ff       	call   1003a8 <kprintf>
  1006c5:	83 c4 10             	add    $0x10,%esp
	kbd_install();
  1006c8:	e8 2a 10 00 00       	call   1016f7 <kbd_install>

	// find location of initial ramdisk //
	if (mboot->mods_count > 0) {
  1006cd:	8b 43 04             	mov    0x4(%ebx),%eax
  1006d0:	8b 40 14             	mov    0x14(%eax),%eax
  1006d3:	85 c0                	test   %eax,%eax
  1006d5:	74 34                	je     10070b <main+0x19d>
		kprintf("Modules: %d\n", mboot->mods_count);
  1006d7:	8b 43 04             	mov    0x4(%ebx),%eax
  1006da:	8b 40 14             	mov    0x14(%eax),%eax
  1006dd:	83 ec 08             	sub    $0x8,%esp
  1006e0:	50                   	push   %eax
  1006e1:	68 e1 64 10 00       	push   $0x1064e1
  1006e6:	e8 bd fc ff ff       	call   1003a8 <kprintf>
  1006eb:	83 c4 10             	add    $0x10,%esp
		initrd_location = *((unsigned int *) mboot->mods_addr);
  1006ee:	8b 43 04             	mov    0x4(%ebx),%eax
  1006f1:	8b 40 18             	mov    0x18(%eax),%eax
  1006f4:	8b 00                	mov    (%eax),%eax
  1006f6:	a3 40 c0 10 00       	mov    %eax,0x10c040
		initrd_end = *(unsigned int *) (mboot->mods_addr + 4);
  1006fb:	8b 43 04             	mov    0x4(%ebx),%eax
  1006fe:	8b 40 18             	mov    0x18(%eax),%eax
  100701:	83 c0 04             	add    $0x4,%eax
  100704:	8b 00                	mov    (%eax),%eax
  100706:	a3 f0 c0 10 00       	mov    %eax,0x10c0f0
	}

	kprintf("Setup paging\n");
  10070b:	83 ec 0c             	sub    $0xc,%esp
  10070e:	68 ee 64 10 00       	push   $0x1064ee
  100713:	e8 90 fc ff ff       	call   1003a8 <kprintf>
  100718:	83 c4 10             	add    $0x10,%esp
	mem_init(mboot);
  10071b:	83 ec 0c             	sub    $0xc,%esp
  10071e:	ff 73 04             	pushl  0x4(%ebx)
  100721:	e8 4e 21 00 00       	call   102874 <mem_init>
  100726:	83 c4 10             	add    $0x10,%esp
	// map(0x10000000, (unsigned int)upage, P_PRESENT|P_READ_WRITE|P_USER);
	// unsigned int *addr = temp_map(initrd_location);
	// memcpy((void *)0x10000000, (void *)initrd_location, PAGE_SIZE);
	// temp_unmap();

	fs_root = initrd_init(initrd_location);
  100729:	a1 40 c0 10 00       	mov    0x10c040,%eax
  10072e:	83 ec 0c             	sub    $0xc,%esp
  100731:	50                   	push   %eax
  100732:	e8 a6 30 00 00       	call   1037dd <initrd_init>
  100737:	83 c4 10             	add    $0x10,%esp
  10073a:	a3 08 c1 10 00       	mov    %eax,0x10c108
	// list_root(fs_root);


	task_init();
  10073f:	e8 61 35 00 00       	call   103ca5 <task_init>

	syscall_init();
  100744:	e8 f9 39 00 00       	call   104142 <syscall_init>
	// fork();
	exec_init();
  100749:	e8 99 37 00 00       	call   103ee7 <exec_init>
	// 	//delay(20);	// short delay to let the child switch
	// 	//ps();
	// 	kprintf("Used mem: %d kB\n", (total_pages-num_pages)*PAGE_SIZE /1024);
	// 	task_idle();
	// }
	kprintf("Should not get here\n");
  10074e:	83 ec 0c             	sub    $0xc,%esp
  100751:	68 fc 64 10 00       	push   $0x1064fc
  100756:	e8 4d fc ff ff       	call   1003a8 <kprintf>
  10075b:	83 c4 10             	add    $0x10,%esp
	return;
  10075e:	90                   	nop
}
  10075f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  100762:	59                   	pop    %ecx
  100763:	5b                   	pop    %ebx
  100764:	5d                   	pop    %ebp
  100765:	8d 61 fc             	lea    -0x4(%ecx),%esp
  100768:	c3                   	ret    
  100769:	66 90                	xchg   %ax,%ax
  10076b:	66 90                	xchg   %ax,%ax
  10076d:	66 90                	xchg   %ax,%ax
  10076f:	90                   	nop

[SECTION .text]

	align 4

	dd MULTIBOOT_HEADER_MAGIC
  100770:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
	dd MULTIBOOT_HEADER_FLAGS
  100776:	00 00                	add    %al,(%eax)
	dd CHECKSUM
  100778:	fb                   	sti    
  100779:	4f                   	dec    %edi
  10077a:	52                   	push   %edx
  10077b:	e4 90                	in     $0x90,%al
	; multiboot header, pt grub, tre sa fie in primii 8k


align 8
  10077d:	90                   	nop
  10077e:	90                   	nop
  10077f:	90                   	nop

00100780 <start>:
start:
	mov esp, stack+STACKSIZE
  100780:	bc 00 b0 10 00       	mov    $0x10b000,%esp
	mov ebp, esp
  100785:	89 e5                	mov    %esp,%ebp
	push esp
  100787:	54                   	push   %esp
	push STACKSIZE
  100788:	68 00 20 00 00       	push   $0x2000
	push ebx	; ptr struct multiboot_header
  10078d:	53                   	push   %ebx
	push eax	; magic
  10078e:	50                   	push   %eax
	call main
  10078f:	e8 da fd ff ff       	call   10056e <main>

00100794 <start.h>:
.h:
	;hlt
	jmp .h
  100794:	eb fe                	jmp    100794 <start.h>

00100796 <get_esp>:


; functii apelate din C
GLOBAL get_esp
get_esp:
	mov eax, esp
  100796:	89 e0                	mov    %esp,%eax
	ret
  100798:	c3                   	ret    

00100799 <get_eip>:
GLOBAL get_eip
get_eip:
	pop eax
  100799:	58                   	pop    %eax
	jmp eax
  10079a:	ff e0                	jmp    *%eax

0010079c <get_ebp>:

GLOBAL get_ebp
get_ebp:
	mov eax, ebp
  10079c:	89 e8                	mov    %ebp,%eax
	ret
  10079e:	c3                   	ret    

0010079f <bochs_magic_break>:
;	pop ebp
;	ret

GLOBAL bochs_magic_break
bochs_magic_break:
    xchg bx, bx
  10079f:	66 87 db             	xchg   %bx,%bx
    ret
  1007a2:	c3                   	ret    

001007a3 <get_kernel_info>:

GLOBAL get_kernel_info
get_kernel_info:
	push ebp
  1007a3:	55                   	push   %ebp
	mov ebp, esp
  1007a4:	89 e5                	mov    %esp,%ebp
	mov edx, end
  1007a6:	ba 00 d0 10 00       	mov    $0x10d000,%edx
	sub edx, code
  1007ab:	81 ea 00 00 10 00    	sub    $0x100000,%edx
	mov eax, [ebp+8];
  1007b1:	8b 45 08             	mov    0x8(%ebp),%eax
	mov dword [eax], code
  1007b4:	c7 00 00 00 10 00    	movl   $0x100000,(%eax)
	mov dword [eax+4], start
  1007ba:	c7 40 04 80 07 10 00 	movl   $0x100780,0x4(%eax)
	mov dword [eax+8], data
  1007c1:	c7 40 08 80 61 10 00 	movl   $0x106180,0x8(%eax)
	mov dword [eax+12], bss
  1007c8:	c7 40 0c 00 80 10 00 	movl   $0x108000,0xc(%eax)
	mov dword [eax+16], end
  1007cf:	c7 40 10 00 d0 10 00 	movl   $0x10d000,0x10(%eax)
	mov dword [eax+20], edx
  1007d6:	89 50 14             	mov    %edx,0x14(%eax)
	pop ebp
  1007d9:	5d                   	pop    %ebp
	ret
  1007da:	c3                   	ret    

001007db <halt>:

GLOBAL halt
halt:
	cli;
  1007db:	fa                   	cli    
	hlt;
  1007dc:	f4                   	hlt    

001007dd <gdt_flush>:


GLOBAL gdt_flush
EXTERN gdt_p
gdt_flush:
	lgdt[gdt_p]		;incarca tabela globala de descriptori (GDT) cu pointerul special gdt_p, definit in gdt.h
  1007dd:	0f 01 15 50 c1 10 00 	lgdtl  0x10c150
	mov ax, 0x10		;0x10 e offsetul catre segmentul de date // la 0x00 e null descriptor, la 0x08 e code, 0x10 data
  1007e4:	66 b8 10 00          	mov    $0x10,%ax
	mov ds, ax
  1007e8:	8e d8                	mov    %eax,%ds
	mov es, ax
  1007ea:	8e c0                	mov    %eax,%es
	mov fs, ax
  1007ec:	8e e0                	mov    %eax,%fs
	mov gs, ax
  1007ee:	8e e8                	mov    %eax,%gs
	mov ss, ax
  1007f0:	8e d0                	mov    %eax,%ss
	jmp 0x08:flush_cs	;segmentul de data e mai special, nu poate fi incarcat direct, facem un far jump pentru a-l seta
  1007f2:	ea f9 07 10 00 08 00 	ljmp   $0x8,$0x1007f9

001007f9 <flush_cs>:
flush_cs:
	ret
  1007f9:	c3                   	ret    

001007fa <idt_load>:


GLOBAL idt_load
EXTERN idt_p
idt_load:
	lidt [idt_p]
  1007fa:	0f 01 1d 80 c1 10 00 	lidtl  0x10c180
	ret
  100801:	c3                   	ret    

00100802 <isr0>:
GLOBAL isr16, isr17, isr18, isr19, isr20, isr21, isr22, isr23
GLOBAL isr24, isr25, isr26, isr27, isr28, isr29, isr30, isr31, isr128


isr0:
	cli
  100802:	fa                   	cli    
	push byte 0
  100803:	6a 00                	push   $0x0
	push byte 0
  100805:	6a 00                	push   $0x0
	jmp isr_common
  100807:	e9 01 01 00 00       	jmp    10090d <isr_common>

0010080c <isr1>:

isr1:
	cli
  10080c:	fa                   	cli    
	push byte 0
  10080d:	6a 00                	push   $0x0
	push byte 1
  10080f:	6a 01                	push   $0x1
	jmp isr_common
  100811:	e9 f7 00 00 00       	jmp    10090d <isr_common>

00100816 <isr2>:

isr2:
	cli
  100816:	fa                   	cli    
	push byte 0
  100817:	6a 00                	push   $0x0
	push byte 2
  100819:	6a 02                	push   $0x2
	jmp isr_common
  10081b:	e9 ed 00 00 00       	jmp    10090d <isr_common>

00100820 <isr3>:

isr3:
	cli
  100820:	fa                   	cli    
	push byte 0
  100821:	6a 00                	push   $0x0
	push byte 3
  100823:	6a 03                	push   $0x3
	jmp isr_common
  100825:	e9 e3 00 00 00       	jmp    10090d <isr_common>

0010082a <isr4>:

isr4:
	cli
  10082a:	fa                   	cli    
	push byte 0
  10082b:	6a 00                	push   $0x0
	push byte 4
  10082d:	6a 04                	push   $0x4
	jmp isr_common
  10082f:	e9 d9 00 00 00       	jmp    10090d <isr_common>

00100834 <isr5>:

isr5:
	cli
  100834:	fa                   	cli    
	push byte 0
  100835:	6a 00                	push   $0x0
	push byte 5
  100837:	6a 05                	push   $0x5
	jmp isr_common
  100839:	e9 cf 00 00 00       	jmp    10090d <isr_common>

0010083e <isr6>:

isr6:
	cli
  10083e:	fa                   	cli    
	push byte 0
  10083f:	6a 00                	push   $0x0
	push byte 6
  100841:	6a 06                	push   $0x6
	jmp isr_common
  100843:	e9 c5 00 00 00       	jmp    10090d <isr_common>

00100848 <isr7>:

isr7:
	cli
  100848:	fa                   	cli    
	push byte 0
  100849:	6a 00                	push   $0x0
	push byte 7
  10084b:	6a 07                	push   $0x7
	jmp isr_common
  10084d:	e9 bb 00 00 00       	jmp    10090d <isr_common>

00100852 <isr8>:

isr8:
	cli
  100852:	fa                   	cli    
	push byte 8	; - already pushed
  100853:	6a 08                	push   $0x8
	jmp isr_common
  100855:	e9 b3 00 00 00       	jmp    10090d <isr_common>

0010085a <isr9>:

isr9:
	cli
  10085a:	fa                   	cli    
	push byte 0
  10085b:	6a 00                	push   $0x0
	push byte 9
  10085d:	6a 09                	push   $0x9
	jmp isr_common
  10085f:	e9 a9 00 00 00       	jmp    10090d <isr_common>

00100864 <isr10>:

isr10:
	cli
  100864:	fa                   	cli    
	push byte 10
  100865:	6a 0a                	push   $0xa
	jmp isr_common
  100867:	e9 a1 00 00 00       	jmp    10090d <isr_common>

0010086c <isr11>:

isr11:
	cli
  10086c:	fa                   	cli    
	push byte 11
  10086d:	6a 0b                	push   $0xb
	jmp isr_common
  10086f:	e9 99 00 00 00       	jmp    10090d <isr_common>

00100874 <isr12>:

isr12:
	cli
  100874:	fa                   	cli    
	push byte 12
  100875:	6a 0c                	push   $0xc
	jmp isr_common
  100877:	e9 91 00 00 00       	jmp    10090d <isr_common>

0010087c <isr13>:

isr13:
	cli
  10087c:	fa                   	cli    
	push byte 13
  10087d:	6a 0d                	push   $0xd
	jmp isr_common
  10087f:	e9 89 00 00 00       	jmp    10090d <isr_common>

00100884 <isr14>:

isr14:
	cli
  100884:	fa                   	cli    
	push byte 14
  100885:	6a 0e                	push   $0xe
	jmp isr_common
  100887:	e9 81 00 00 00       	jmp    10090d <isr_common>

0010088c <isr15>:

isr15:
	cli
  10088c:	fa                   	cli    
	push byte 0
  10088d:	6a 00                	push   $0x0
	push byte 15
  10088f:	6a 0f                	push   $0xf
	jmp isr_common
  100891:	eb 7a                	jmp    10090d <isr_common>

00100893 <isr16>:

isr16:
	cli
  100893:	fa                   	cli    
	push byte 0
  100894:	6a 00                	push   $0x0
	push byte 16
  100896:	6a 10                	push   $0x10
	jmp isr_common
  100898:	eb 73                	jmp    10090d <isr_common>

0010089a <isr17>:

isr17:
	cli
  10089a:	fa                   	cli    
	push byte 0
  10089b:	6a 00                	push   $0x0
	push byte 17
  10089d:	6a 11                	push   $0x11
	jmp isr_common
  10089f:	eb 6c                	jmp    10090d <isr_common>

001008a1 <isr18>:

isr18:
	cli
  1008a1:	fa                   	cli    
	push byte 0
  1008a2:	6a 00                	push   $0x0
	push byte 18
  1008a4:	6a 12                	push   $0x12
	jmp isr_common
  1008a6:	eb 65                	jmp    10090d <isr_common>

001008a8 <isr19>:

isr19:
	cli
  1008a8:	fa                   	cli    
	push byte 0
  1008a9:	6a 00                	push   $0x0
	push byte 19
  1008ab:	6a 13                	push   $0x13
	jmp isr_common
  1008ad:	eb 5e                	jmp    10090d <isr_common>

001008af <isr20>:

isr20:
	cli
  1008af:	fa                   	cli    
	push byte 0
  1008b0:	6a 00                	push   $0x0
	push byte 20
  1008b2:	6a 14                	push   $0x14
	jmp isr_common
  1008b4:	eb 57                	jmp    10090d <isr_common>

001008b6 <isr21>:

isr21:
	cli
  1008b6:	fa                   	cli    
	push byte 0
  1008b7:	6a 00                	push   $0x0
	push byte 21
  1008b9:	6a 15                	push   $0x15
	jmp isr_common
  1008bb:	eb 50                	jmp    10090d <isr_common>

001008bd <isr22>:

isr22:
	cli
  1008bd:	fa                   	cli    
	push byte 0
  1008be:	6a 00                	push   $0x0
	push byte 22
  1008c0:	6a 16                	push   $0x16
	jmp isr_common
  1008c2:	eb 49                	jmp    10090d <isr_common>

001008c4 <isr23>:

isr23:
	cli
  1008c4:	fa                   	cli    
	push byte 0
  1008c5:	6a 00                	push   $0x0
	push byte 23
  1008c7:	6a 17                	push   $0x17
	jmp isr_common
  1008c9:	eb 42                	jmp    10090d <isr_common>

001008cb <isr24>:

isr24:
	cli
  1008cb:	fa                   	cli    
	push byte 0
  1008cc:	6a 00                	push   $0x0
	push byte 24
  1008ce:	6a 18                	push   $0x18
	jmp isr_common
  1008d0:	eb 3b                	jmp    10090d <isr_common>

001008d2 <isr25>:

isr25:
	cli
  1008d2:	fa                   	cli    
	push byte 0
  1008d3:	6a 00                	push   $0x0
	push byte 25
  1008d5:	6a 19                	push   $0x19
	jmp isr_common
  1008d7:	eb 34                	jmp    10090d <isr_common>

001008d9 <isr26>:

isr26:
	cli
  1008d9:	fa                   	cli    
	push byte 0
  1008da:	6a 00                	push   $0x0
	push byte 26
  1008dc:	6a 1a                	push   $0x1a
	jmp isr_common
  1008de:	eb 2d                	jmp    10090d <isr_common>

001008e0 <isr27>:

isr27:
	cli
  1008e0:	fa                   	cli    
	push byte 0
  1008e1:	6a 00                	push   $0x0
	push byte 27
  1008e3:	6a 1b                	push   $0x1b
	jmp isr_common
  1008e5:	eb 26                	jmp    10090d <isr_common>

001008e7 <isr28>:

isr28:
	cli
  1008e7:	fa                   	cli    
	push byte 0
  1008e8:	6a 00                	push   $0x0
	push byte 28
  1008ea:	6a 1c                	push   $0x1c
	jmp isr_common
  1008ec:	eb 1f                	jmp    10090d <isr_common>

001008ee <isr29>:

isr29:
	cli
  1008ee:	fa                   	cli    
	push byte 0
  1008ef:	6a 00                	push   $0x0
	push byte 29
  1008f1:	6a 1d                	push   $0x1d
	jmp isr_common
  1008f3:	eb 18                	jmp    10090d <isr_common>

001008f5 <isr30>:

isr30:
	cli
  1008f5:	fa                   	cli    
	push byte 0
  1008f6:	6a 00                	push   $0x0
	push byte 30
  1008f8:	6a 1e                	push   $0x1e
	jmp isr_common
  1008fa:	eb 11                	jmp    10090d <isr_common>

001008fc <isr31>:

isr31:
	cli
  1008fc:	fa                   	cli    
	push byte 0
  1008fd:	6a 00                	push   $0x0
	push byte 31
  1008ff:	6a 1f                	push   $0x1f
	jmp isr_common
  100901:	eb 0a                	jmp    10090d <isr_common>

00100903 <isr128>:

isr128:
	cli
  100903:	fa                   	cli    
	push byte 0
  100904:	6a 00                	push   $0x0
	push 128
  100906:	68 80 00 00 00       	push   $0x80
	jmp isr_common
  10090b:	eb 00                	jmp    10090d <isr_common>

0010090d <isr_common>:

global isr_common
extern isr_handler
isr_common:
	pusha
  10090d:	60                   	pusha  
	push ds
  10090e:	1e                   	push   %ds
	push es
  10090f:	06                   	push   %es
	push fs
  100910:	0f a0                	push   %fs
	push gs
  100912:	0f a8                	push   %gs

	mov ax, 0x10 ; data segment
  100914:	66 b8 10 00          	mov    $0x10,%ax
	mov ds, ax
  100918:	8e d8                	mov    %eax,%ds
	mov es, ax
  10091a:	8e c0                	mov    %eax,%es
	mov fs, ax
  10091c:	8e e0                	mov    %eax,%fs
	mov gs, ax
  10091e:	8e e8                	mov    %eax,%gs

	mov eax, esp
  100920:	89 e0                	mov    %esp,%eax
	push eax	 ; push us to stack
  100922:	50                   	push   %eax
	call isr_handler
  100923:	e8 bf 08 00 00       	call   1011e7 <isr_handler>
;	call eax
	pop eax
  100928:	58                   	pop    %eax

	pop gs
  100929:	0f a9                	pop    %gs
	pop fs
  10092b:	0f a1                	pop    %fs
	pop es
  10092d:	07                   	pop    %es
	pop ds
  10092e:	1f                   	pop    %ds
	popa
  10092f:	61                   	popa   

	add esp, 8	; cleanup pushed error codes and pushed isr numbers
  100930:	83 c4 08             	add    $0x8,%esp
	iret
  100933:	cf                   	iret   

00100934 <irq0>:
;; irqs ;;
GLOBAL irq0, irq1, irq2, irq3, irq4, irq5, irq6, irq7
GLOBAL irq8, irq9, irq10, irq11, irq12, irq13, irq14, irq15

irq0:
	cli
  100934:	fa                   	cli    
	push byte 0
  100935:	6a 00                	push   $0x0
	push byte 32
  100937:	6a 20                	push   $0x20
	jmp irq_common
  100939:	eb 69                	jmp    1009a4 <irq_common>

0010093b <irq1>:

irq1:
	cli
  10093b:	fa                   	cli    
	push byte 0
  10093c:	6a 00                	push   $0x0
	push byte 33
  10093e:	6a 21                	push   $0x21
	jmp irq_common
  100940:	eb 62                	jmp    1009a4 <irq_common>

00100942 <irq2>:

irq2:
	cli
  100942:	fa                   	cli    
	push byte 0
  100943:	6a 00                	push   $0x0
	push byte 34
  100945:	6a 22                	push   $0x22
	jmp irq_common
  100947:	eb 5b                	jmp    1009a4 <irq_common>

00100949 <irq3>:

irq3:
	cli
  100949:	fa                   	cli    
	push byte 0
  10094a:	6a 00                	push   $0x0
	push byte 35
  10094c:	6a 23                	push   $0x23
	jmp irq_common
  10094e:	eb 54                	jmp    1009a4 <irq_common>

00100950 <irq4>:

irq4:
	cli
  100950:	fa                   	cli    
	push byte 0
  100951:	6a 00                	push   $0x0
	push byte 36
  100953:	6a 24                	push   $0x24
	jmp irq_common
  100955:	eb 4d                	jmp    1009a4 <irq_common>

00100957 <irq5>:

irq5:
	cli
  100957:	fa                   	cli    
	push byte 0
  100958:	6a 00                	push   $0x0
	push byte 37
  10095a:	6a 25                	push   $0x25
	jmp irq_common
  10095c:	eb 46                	jmp    1009a4 <irq_common>

0010095e <irq6>:

irq6:
	cli
  10095e:	fa                   	cli    
	push byte 0
  10095f:	6a 00                	push   $0x0
	push byte 38
  100961:	6a 26                	push   $0x26
	jmp irq_common
  100963:	eb 3f                	jmp    1009a4 <irq_common>

00100965 <irq7>:

irq7:
	cli
  100965:	fa                   	cli    
	push byte 0
  100966:	6a 00                	push   $0x0
	push byte 39
  100968:	6a 27                	push   $0x27
	jmp irq_common
  10096a:	eb 38                	jmp    1009a4 <irq_common>

0010096c <irq8>:

irq8:
	cli
  10096c:	fa                   	cli    
	push byte 0
  10096d:	6a 00                	push   $0x0
	push byte 40
  10096f:	6a 28                	push   $0x28
	jmp irq_common
  100971:	eb 31                	jmp    1009a4 <irq_common>

00100973 <irq9>:

irq9:
	cli
  100973:	fa                   	cli    
	push byte 0
  100974:	6a 00                	push   $0x0
	push byte 41
  100976:	6a 29                	push   $0x29
	jmp irq_common
  100978:	eb 2a                	jmp    1009a4 <irq_common>

0010097a <irq10>:

irq10:
	cli
  10097a:	fa                   	cli    
	push byte 0
  10097b:	6a 00                	push   $0x0
	push byte 42
  10097d:	6a 2a                	push   $0x2a
	jmp irq_common
  10097f:	eb 23                	jmp    1009a4 <irq_common>

00100981 <irq11>:

irq11:
	cli
  100981:	fa                   	cli    
	push byte 0
  100982:	6a 00                	push   $0x0
	push byte 43
  100984:	6a 2b                	push   $0x2b
	jmp irq_common
  100986:	eb 1c                	jmp    1009a4 <irq_common>

00100988 <irq12>:

irq12:
	cli
  100988:	fa                   	cli    
	push byte 0
  100989:	6a 00                	push   $0x0
	push byte 44
  10098b:	6a 2c                	push   $0x2c
	jmp irq_common
  10098d:	eb 15                	jmp    1009a4 <irq_common>

0010098f <irq13>:

irq13:
	cli
  10098f:	fa                   	cli    
	push byte 0
  100990:	6a 00                	push   $0x0
	push byte 45
  100992:	6a 2d                	push   $0x2d
	jmp irq_common
  100994:	eb 0e                	jmp    1009a4 <irq_common>

00100996 <irq14>:

irq14:
	cli
  100996:	fa                   	cli    
	push byte 0
  100997:	6a 00                	push   $0x0
	push byte 46
  100999:	6a 2e                	push   $0x2e
	jmp irq_common
  10099b:	eb 07                	jmp    1009a4 <irq_common>

0010099d <irq15>:

irq15:
	cli
  10099d:	fa                   	cli    
	push byte 0
  10099e:	6a 00                	push   $0x0
	push byte 47
  1009a0:	6a 2f                	push   $0x2f
	jmp irq_common
  1009a2:	eb 00                	jmp    1009a4 <irq_common>

001009a4 <irq_common>:


EXTERN irq_handler
irq_common:
	pusha
  1009a4:	60                   	pusha  
	push ds
  1009a5:	1e                   	push   %ds
	push es
  1009a6:	06                   	push   %es
	push fs
  1009a7:	0f a0                	push   %fs
	push gs
  1009a9:	0f a8                	push   %gs
	mov ax, 0x10 ; data segment
  1009ab:	66 b8 10 00          	mov    $0x10,%ax
	mov ds, ax
  1009af:	8e d8                	mov    %eax,%ds
	mov es, ax
  1009b1:	8e c0                	mov    %eax,%es
	mov fs, ax
  1009b3:	8e e0                	mov    %eax,%fs
	mov gs, ax
  1009b5:	8e e8                	mov    %eax,%gs
	mov eax, esp
  1009b7:	89 e0                	mov    %esp,%eax
	push eax
  1009b9:	50                   	push   %eax
	mov eax, irq_handler
  1009ba:	b8 82 14 10 00       	mov    $0x101482,%eax
	call eax
  1009bf:	ff d0                	call   *%eax
	pop eax
  1009c1:	58                   	pop    %eax
	pop gs
  1009c2:	0f a9                	pop    %gs
	pop fs
  1009c4:	0f a1                	pop    %fs
	pop es
  1009c6:	07                   	pop    %es
	pop ds
  1009c7:	1f                   	pop    %ds
	popa
  1009c8:	61                   	popa   
	add esp, 2 * 4
  1009c9:	83 c4 08             	add    $0x8,%esp
	iret
  1009cc:	cf                   	iret   

001009cd <bochs_break>:
;	ret


global bochs_break
bochs_break:
    xchg bx, bx
  1009cd:	66 87 db             	xchg   %bx,%bx

001009d0 <switch_pd>:

GLOBAL switch_pd
switch_pd:
	push ebp
  1009d0:	55                   	push   %ebp
	mov ebp, esp
  1009d1:	89 e5                	mov    %esp,%ebp
	mov eax, [ebp+8]
  1009d3:	8b 45 08             	mov    0x8(%ebp),%eax
	mov cr3, eax
  1009d6:	0f 22 d8             	mov    %eax,%cr3
	mov eax, cr0
  1009d9:	0f 20 c0             	mov    %cr0,%eax
	or eax, 0x80000000
  1009dc:	0d 00 00 00 80       	or     $0x80000000,%eax
	mov cr0, eax
  1009e1:	0f 22 c0             	mov    %eax,%cr0
	pop ebp
  1009e4:	5d                   	pop    %ebp
	ret
  1009e5:	c3                   	ret    

001009e6 <flush_tlb>:

GLOBAL flush_tlb
flush_tlb:
	mov eax, cr3
  1009e6:	0f 20 d8             	mov    %cr3,%eax
	mov cr3, eax
  1009e9:	0f 22 d8             	mov    %eax,%cr3
	ret
  1009ec:	c3                   	ret    

001009ed <multiboot_parse>:



static unsigned short int boot_device = 0;

void multiboot_parse(unsigned int magic, multiboot_header *mboot) {
  1009ed:	55                   	push   %ebp
  1009ee:	89 e5                	mov    %esp,%ebp
  1009f0:	56                   	push   %esi
  1009f1:	53                   	push   %ebx
  1009f2:	83 ec 10             	sub    $0x10,%esp
//	kprintf("0x%X\n", magic);
	if(magic != MBOOT_MAGIC) {
  1009f5:	81 7d 08 02 b0 ad 2b 	cmpl   $0x2badb002,0x8(%ebp)
  1009fc:	74 13                	je     100a11 <multiboot_parse+0x24>
		panic("Invalid magic flag: 0x%X\n", magic);
  1009fe:	83 ec 08             	sub    $0x8,%esp
  100a01:	ff 75 08             	pushl  0x8(%ebp)
  100a04:	68 14 65 10 00       	push   $0x106514
  100a09:	e8 36 fa ff ff       	call   100444 <panic>
  100a0e:	83 c4 10             	add    $0x10,%esp
	}
	kprintf("Multiboot flags: 0x%X\n", mboot->flags);
  100a11:	8b 45 0c             	mov    0xc(%ebp),%eax
  100a14:	8b 00                	mov    (%eax),%eax
  100a16:	83 ec 08             	sub    $0x8,%esp
  100a19:	50                   	push   %eax
  100a1a:	68 2e 65 10 00       	push   $0x10652e
  100a1f:	e8 84 f9 ff ff       	call   1003a8 <kprintf>
  100a24:	83 c4 10             	add    $0x10,%esp
	if(testb(mboot->flags, MBOOTF_MEM)) {
  100a27:	8b 45 0c             	mov    0xc(%ebp),%eax
  100a2a:	8b 00                	mov    (%eax),%eax
  100a2c:	83 e0 01             	and    $0x1,%eax
  100a2f:	85 c0                	test   %eax,%eax
  100a31:	74 1e                	je     100a51 <multiboot_parse+0x64>
		kprintf("Low memory: %iKb, upper memory:%iKb\n", mboot->mem_lower, mboot->mem_upper);
  100a33:	8b 45 0c             	mov    0xc(%ebp),%eax
  100a36:	8b 50 08             	mov    0x8(%eax),%edx
  100a39:	8b 45 0c             	mov    0xc(%ebp),%eax
  100a3c:	8b 40 04             	mov    0x4(%eax),%eax
  100a3f:	83 ec 04             	sub    $0x4,%esp
  100a42:	52                   	push   %edx
  100a43:	50                   	push   %eax
  100a44:	68 48 65 10 00       	push   $0x106548
  100a49:	e8 5a f9 ff ff       	call   1003a8 <kprintf>
  100a4e:	83 c4 10             	add    $0x10,%esp
	}
	if(testb(mboot->flags, MBOOTF_BOOTD)) {
  100a51:	8b 45 0c             	mov    0xc(%ebp),%eax
  100a54:	8b 00                	mov    (%eax),%eax
  100a56:	83 e0 02             	and    $0x2,%eax
  100a59:	85 c0                	test   %eax,%eax
  100a5b:	74 24                	je     100a81 <multiboot_parse+0x94>
		boot_device = (unsigned short int) (mboot->boot_device & 0xFF000000) >> 12;
  100a5d:	66 c7 05 00 b0 10 00 	movw   $0x0,0x10b000
  100a64:	00 00 
		kprintf("Boot device:0x%X\n", boot_device);
  100a66:	0f b7 05 00 b0 10 00 	movzwl 0x10b000,%eax
  100a6d:	0f b7 c0             	movzwl %ax,%eax
  100a70:	83 ec 08             	sub    $0x8,%esp
  100a73:	50                   	push   %eax
  100a74:	68 6d 65 10 00       	push   $0x10656d
  100a79:	e8 2a f9 ff ff       	call   1003a8 <kprintf>
  100a7e:	83 c4 10             	add    $0x10,%esp
	}
	if(testb(mboot->flags, MBOOTF_MMAP)) {
  100a81:	8b 45 0c             	mov    0xc(%ebp),%eax
  100a84:	8b 00                	mov    (%eax),%eax
  100a86:	83 e0 40             	and    $0x40,%eax
  100a89:	85 c0                	test   %eax,%eax
  100a8b:	74 71                	je     100afe <multiboot_parse+0x111>
		kprintf("Detecting memory:\n");
  100a8d:	83 ec 0c             	sub    $0xc,%esp
  100a90:	68 7f 65 10 00       	push   $0x10657f
  100a95:	e8 0e f9 ff ff       	call   1003a8 <kprintf>
  100a9a:	83 c4 10             	add    $0x10,%esp
		memory_map *mmap;
		mmap = (memory_map *) mboot->mmap_addr;
  100a9d:	8b 45 0c             	mov    0xc(%ebp),%eax
  100aa0:	8b 40 30             	mov    0x30(%eax),%eax
  100aa3:	89 45 f4             	mov    %eax,-0xc(%ebp)
		do {
			kprintf ("\tbase_addr = 0x%x%x, length = 0x%x%x, type = 0x%x\n",
				(unsigned) mmap->base_addr_high, (unsigned) mmap->base_addr_low,
				(unsigned) mmap->length_high, (unsigned) mmap->length_low,
				(unsigned) mmap->type);
  100aa6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100aa9:	8b 70 14             	mov    0x14(%eax),%esi
		memory_map *mmap;
		mmap = (memory_map *) mboot->mmap_addr;
		do {
			kprintf ("\tbase_addr = 0x%x%x, length = 0x%x%x, type = 0x%x\n",
				(unsigned) mmap->base_addr_high, (unsigned) mmap->base_addr_low,
				(unsigned) mmap->length_high, (unsigned) mmap->length_low,
  100aac:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100aaf:	8b 58 0c             	mov    0xc(%eax),%ebx
  100ab2:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100ab5:	8b 48 10             	mov    0x10(%eax),%ecx
		kprintf("Detecting memory:\n");
		memory_map *mmap;
		mmap = (memory_map *) mboot->mmap_addr;
		do {
			kprintf ("\tbase_addr = 0x%x%x, length = 0x%x%x, type = 0x%x\n",
				(unsigned) mmap->base_addr_high, (unsigned) mmap->base_addr_low,
  100ab8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100abb:	8b 50 04             	mov    0x4(%eax),%edx
  100abe:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100ac1:	8b 40 08             	mov    0x8(%eax),%eax
	if(testb(mboot->flags, MBOOTF_MMAP)) {
		kprintf("Detecting memory:\n");
		memory_map *mmap;
		mmap = (memory_map *) mboot->mmap_addr;
		do {
			kprintf ("\tbase_addr = 0x%x%x, length = 0x%x%x, type = 0x%x\n",
  100ac4:	83 ec 08             	sub    $0x8,%esp
  100ac7:	56                   	push   %esi
  100ac8:	53                   	push   %ebx
  100ac9:	51                   	push   %ecx
  100aca:	52                   	push   %edx
  100acb:	50                   	push   %eax
  100acc:	68 94 65 10 00       	push   $0x106594
  100ad1:	e8 d2 f8 ff ff       	call   1003a8 <kprintf>
  100ad6:	83 c4 20             	add    $0x20,%esp
				(unsigned) mmap->base_addr_high, (unsigned) mmap->base_addr_low,
				(unsigned) mmap->length_high, (unsigned) mmap->length_low,
				(unsigned) mmap->type);
			mmap = (memory_map *) ((unsigned long) mmap + mmap->size + sizeof(mmap->size));
  100ad9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100adc:	8b 10                	mov    (%eax),%edx
  100ade:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100ae1:	01 d0                	add    %edx,%eax
  100ae3:	83 c0 04             	add    $0x4,%eax
  100ae6:	89 45 f4             	mov    %eax,-0xc(%ebp)
		} while((unsigned long) mmap < mboot->mmap_addr + mboot->mmap_length);
  100ae9:	8b 55 f4             	mov    -0xc(%ebp),%edx
  100aec:	8b 45 0c             	mov    0xc(%ebp),%eax
  100aef:	8b 48 30             	mov    0x30(%eax),%ecx
  100af2:	8b 45 0c             	mov    0xc(%ebp),%eax
  100af5:	8b 40 2c             	mov    0x2c(%eax),%eax
  100af8:	01 c8                	add    %ecx,%eax
  100afa:	39 c2                	cmp    %eax,%edx
  100afc:	72 a8                	jb     100aa6 <multiboot_parse+0xb9>
	}
  100afe:	8d 65 f8             	lea    -0x8(%ebp),%esp
  100b01:	5b                   	pop    %ebx
  100b02:	5e                   	pop    %esi
  100b03:	5d                   	pop    %ebp
  100b04:	c3                   	ret    

00100b05 <gdt_set_gate>:
// ptr to this table //
struct gdt_ptr gdt_p;


void gdt_set_gate(int num, unsigned long base, unsigned long limit, unsigned char access, unsigned char gran)
{
  100b05:	55                   	push   %ebp
  100b06:	89 e5                	mov    %esp,%ebp
  100b08:	83 ec 08             	sub    $0x8,%esp
  100b0b:	8b 55 14             	mov    0x14(%ebp),%edx
  100b0e:	8b 45 18             	mov    0x18(%ebp),%eax
  100b11:	88 55 fc             	mov    %dl,-0x4(%ebp)
  100b14:	88 45 f8             	mov    %al,-0x8(%ebp)
	gdt[num].base_low = (base & 0xFFFF);
  100b17:	8b 45 0c             	mov    0xc(%ebp),%eax
  100b1a:	89 c2                	mov    %eax,%edx
  100b1c:	8b 45 08             	mov    0x8(%ebp),%eax
  100b1f:	66 89 14 c5 22 c1 10 	mov    %dx,0x10c122(,%eax,8)
  100b26:	00 
	gdt[num].base_middle = (base >> 16) & 0xFF;
  100b27:	8b 45 0c             	mov    0xc(%ebp),%eax
  100b2a:	c1 e8 10             	shr    $0x10,%eax
  100b2d:	89 c2                	mov    %eax,%edx
  100b2f:	8b 45 08             	mov    0x8(%ebp),%eax
  100b32:	88 14 c5 24 c1 10 00 	mov    %dl,0x10c124(,%eax,8)
	gdt[num].base_high = (base >> 24) & 0xFF;
  100b39:	8b 45 0c             	mov    0xc(%ebp),%eax
  100b3c:	c1 e8 18             	shr    $0x18,%eax
  100b3f:	89 c2                	mov    %eax,%edx
  100b41:	8b 45 08             	mov    0x8(%ebp),%eax
  100b44:	88 14 c5 27 c1 10 00 	mov    %dl,0x10c127(,%eax,8)
	gdt[num].limit_low = (limit & 0xFFFF);
  100b4b:	8b 45 10             	mov    0x10(%ebp),%eax
  100b4e:	89 c2                	mov    %eax,%edx
  100b50:	8b 45 08             	mov    0x8(%ebp),%eax
  100b53:	66 89 14 c5 20 c1 10 	mov    %dx,0x10c120(,%eax,8)
  100b5a:	00 
	gdt[num].granularity = ((limit >> 16) & 0x0F);
  100b5b:	8b 45 10             	mov    0x10(%ebp),%eax
  100b5e:	c1 e8 10             	shr    $0x10,%eax
  100b61:	83 e0 0f             	and    $0xf,%eax
  100b64:	89 c2                	mov    %eax,%edx
  100b66:	8b 45 08             	mov    0x8(%ebp),%eax
  100b69:	88 14 c5 26 c1 10 00 	mov    %dl,0x10c126(,%eax,8)
	gdt[num].granularity |= (gran & 0xF0);
  100b70:	8b 45 08             	mov    0x8(%ebp),%eax
  100b73:	0f b6 04 c5 26 c1 10 	movzbl 0x10c126(,%eax,8),%eax
  100b7a:	00 
  100b7b:	89 c2                	mov    %eax,%edx
  100b7d:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
  100b81:	83 e0 f0             	and    $0xfffffff0,%eax
  100b84:	09 d0                	or     %edx,%eax
  100b86:	89 c2                	mov    %eax,%edx
  100b88:	8b 45 08             	mov    0x8(%ebp),%eax
  100b8b:	88 14 c5 26 c1 10 00 	mov    %dl,0x10c126(,%eax,8)
	gdt[num].access = access;
  100b92:	8b 45 08             	mov    0x8(%ebp),%eax
  100b95:	0f b6 55 fc          	movzbl -0x4(%ebp),%edx
  100b99:	88 14 c5 25 c1 10 00 	mov    %dl,0x10c125(,%eax,8)
}
  100ba0:	c9                   	leave  
  100ba1:	c3                   	ret    

00100ba2 <gdt_init>:

void gdt_init(void)
{
  100ba2:	55                   	push   %ebp
  100ba3:	89 e5                	mov    %esp,%ebp
  100ba5:	83 ec 08             	sub    $0x8,%esp
	gdt_p.limit = (sizeof(struct gdt_entry) * 6) - 1;
  100ba8:	66 c7 05 50 c1 10 00 	movw   $0x2f,0x10c150
  100baf:	2f 00 
	gdt_p.base = (unsigned int) &gdt;
  100bb1:	b8 20 c1 10 00       	mov    $0x10c120,%eax
  100bb6:	a3 52 c1 10 00       	mov    %eax,0x10c152

	gdt_set_gate(0, 0, 0, 0, 0); // null descriptor
  100bbb:	6a 00                	push   $0x0
  100bbd:	6a 00                	push   $0x0
  100bbf:	6a 00                	push   $0x0
  100bc1:	6a 00                	push   $0x0
  100bc3:	6a 00                	push   $0x0
  100bc5:	e8 3b ff ff ff       	call   100b05 <gdt_set_gate>
  100bca:	83 c4 14             	add    $0x14,%esp

	// code segment base address 0x0, 4GB long, granulatie 4KB, 32 bits opcode,
	gdt_set_gate(1, 0, 0xFFFFFFFF, 0x9A, 0xCF);
  100bcd:	68 cf 00 00 00       	push   $0xcf
  100bd2:	68 9a 00 00 00       	push   $0x9a
  100bd7:	6a ff                	push   $0xffffffff
  100bd9:	6a 00                	push   $0x0
  100bdb:	6a 01                	push   $0x1
  100bdd:	e8 23 ff ff ff       	call   100b05 <gdt_set_gate>
  100be2:	83 c4 14             	add    $0x14,%esp
	// data segment base address 0x0, 4GB, granulatie 4KB,
	gdt_set_gate(2, 0, 0xFFFFFFFF, 0x92, 0xCF);
  100be5:	68 cf 00 00 00       	push   $0xcf
  100bea:	68 92 00 00 00       	push   $0x92
  100bef:	6a ff                	push   $0xffffffff
  100bf1:	6a 00                	push   $0x0
  100bf3:	6a 02                	push   $0x2
  100bf5:	e8 0b ff ff ff       	call   100b05 <gdt_set_gate>
  100bfa:	83 c4 14             	add    $0x14,%esp

	// user mode code segment
	gdt_set_gate(3, 0, 0xFFFFFFFF, 0xFA, 0xCF);
  100bfd:	68 cf 00 00 00       	push   $0xcf
  100c02:	68 fa 00 00 00       	push   $0xfa
  100c07:	6a ff                	push   $0xffffffff
  100c09:	6a 00                	push   $0x0
  100c0b:	6a 03                	push   $0x3
  100c0d:	e8 f3 fe ff ff       	call   100b05 <gdt_set_gate>
  100c12:	83 c4 14             	add    $0x14,%esp
	// // user mode data segment
	gdt_set_gate(4, 0, 0xFFFFFFFF, 0xF2, 0xCF);
  100c15:	68 cf 00 00 00       	push   $0xcf
  100c1a:	68 f2 00 00 00       	push   $0xf2
  100c1f:	6a ff                	push   $0xffffffff
  100c21:	6a 00                	push   $0x0
  100c23:	6a 04                	push   $0x4
  100c25:	e8 db fe ff ff       	call   100b05 <gdt_set_gate>
  100c2a:	83 c4 14             	add    $0x14,%esp

	gdt_flush();
  100c2d:	e8 ab fb ff ff       	call   1007dd <gdt_flush>
	//tss_flush();
}
  100c32:	c9                   	leave  
  100c33:	c3                   	ret    

00100c34 <write_tss>:

void write_tss(uint32_t num, uint32_t ss0, uint32_t esp0)
{
  100c34:	55                   	push   %ebp
  100c35:	89 e5                	mov    %esp,%ebp
  100c37:	83 ec 18             	sub    $0x18,%esp
	uint32_t base = (uint32_t)&tss;
  100c3a:	c7 45 f4 80 c0 10 00 	movl   $0x10c080,-0xc(%ebp)
	uint32_t limit = base + sizeof(tss);
  100c41:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100c44:	83 c0 68             	add    $0x68,%eax
  100c47:	89 45 f0             	mov    %eax,-0x10(%ebp)
	gdt_set_gate(num, base, limit, 0xE9, 0x0);
  100c4a:	8b 45 08             	mov    0x8(%ebp),%eax
  100c4d:	6a 00                	push   $0x0
  100c4f:	68 e9 00 00 00       	push   $0xe9
  100c54:	ff 75 f0             	pushl  -0x10(%ebp)
  100c57:	ff 75 f4             	pushl  -0xc(%ebp)
  100c5a:	50                   	push   %eax
  100c5b:	e8 a5 fe ff ff       	call   100b05 <gdt_set_gate>
  100c60:	83 c4 14             	add    $0x14,%esp
	memset(&tss, 0, sizeof(tss));
  100c63:	83 ec 04             	sub    $0x4,%esp
  100c66:	6a 68                	push   $0x68
  100c68:	6a 00                	push   $0x0
  100c6a:	68 80 c0 10 00       	push   $0x10c080
  100c6f:	e8 1c 36 00 00       	call   104290 <memset>
  100c74:	83 c4 10             	add    $0x10,%esp
	tss.ss0 = ss0;
  100c77:	8b 45 0c             	mov    0xc(%ebp),%eax
  100c7a:	a3 88 c0 10 00       	mov    %eax,0x10c088
	tss.esp0 = esp0;
  100c7f:	8b 45 10             	mov    0x10(%ebp),%eax
  100c82:	a3 84 c0 10 00       	mov    %eax,0x10c084
	tss.cs = 0x0b;
  100c87:	c7 05 cc c0 10 00 0b 	movl   $0xb,0x10c0cc
  100c8e:	00 00 00 
	tss.ss = tss.ds = tss.es = tss.fs = tss.gs = 0x13;
  100c91:	c7 05 dc c0 10 00 13 	movl   $0x13,0x10c0dc
  100c98:	00 00 00 
  100c9b:	a1 dc c0 10 00       	mov    0x10c0dc,%eax
  100ca0:	a3 d8 c0 10 00       	mov    %eax,0x10c0d8
  100ca5:	a1 d8 c0 10 00       	mov    0x10c0d8,%eax
  100caa:	a3 c8 c0 10 00       	mov    %eax,0x10c0c8
  100caf:	a1 c8 c0 10 00       	mov    0x10c0c8,%eax
  100cb4:	a3 d4 c0 10 00       	mov    %eax,0x10c0d4
  100cb9:	a1 d4 c0 10 00       	mov    0x10c0d4,%eax
  100cbe:	a3 d0 c0 10 00       	mov    %eax,0x10c0d0
}
  100cc3:	c9                   	leave  
  100cc4:	c3                   	ret    

00100cc5 <set_tss_kernel_stack>:

void set_tss_kernel_stack(uint32_t *stack)
{
  100cc5:	55                   	push   %ebp
  100cc6:	89 e5                	mov    %esp,%ebp
	tss.esp0 = (uint32_t)stack;
  100cc8:	8b 45 08             	mov    0x8(%ebp),%eax
  100ccb:	a3 84 c0 10 00       	mov    %eax,0x10c084
}
  100cd0:	5d                   	pop    %ebp
  100cd1:	c3                   	ret    

00100cd2 <idt_set_gate>:
struct idt_entry idt[256];
struct idt_ptr idt_p;

extern void idt_load();

void idt_set_gate(unsigned char num, unsigned long base, unsigned short sel, unsigned char flags){
  100cd2:	55                   	push   %ebp
  100cd3:	89 e5                	mov    %esp,%ebp
  100cd5:	83 ec 0c             	sub    $0xc,%esp
  100cd8:	8b 4d 08             	mov    0x8(%ebp),%ecx
  100cdb:	8b 55 10             	mov    0x10(%ebp),%edx
  100cde:	8b 45 14             	mov    0x14(%ebp),%eax
  100ce1:	88 4d fc             	mov    %cl,-0x4(%ebp)
  100ce4:	66 89 55 f8          	mov    %dx,-0x8(%ebp)
  100ce8:	88 45 f4             	mov    %al,-0xc(%ebp)
	idt[num].base_hi = (base >> 16) & 0xFFFF;
  100ceb:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
  100cef:	8b 55 0c             	mov    0xc(%ebp),%edx
  100cf2:	c1 ea 10             	shr    $0x10,%edx
  100cf5:	66 89 14 c5 c6 c1 10 	mov    %dx,0x10c1c6(,%eax,8)
  100cfc:	00 
	idt[num].base_lo = base & 0xFFFF;
  100cfd:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
  100d01:	8b 55 0c             	mov    0xc(%ebp),%edx
  100d04:	66 89 14 c5 c0 c1 10 	mov    %dx,0x10c1c0(,%eax,8)
  100d0b:	00 
	idt[num].sel = sel;
  100d0c:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
  100d10:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
  100d14:	66 89 14 c5 c2 c1 10 	mov    %dx,0x10c1c2(,%eax,8)
  100d1b:	00 
	idt[num].always0 = 0;
  100d1c:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
  100d20:	c6 04 c5 c4 c1 10 00 	movb   $0x0,0x10c1c4(,%eax,8)
  100d27:	00 
	idt[num].flags = flags;
  100d28:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
  100d2c:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
  100d30:	88 14 c5 c5 c1 10 00 	mov    %dl,0x10c1c5(,%eax,8)
}
  100d37:	c9                   	leave  
  100d38:	c3                   	ret    

00100d39 <idt_init>:

void idt_init() {
  100d39:	55                   	push   %ebp
  100d3a:	89 e5                	mov    %esp,%ebp
  100d3c:	83 ec 08             	sub    $0x8,%esp
	idt_p.limit = sizeof(idt) - 1;
  100d3f:	66 c7 05 80 c1 10 00 	movw   $0x7ff,0x10c180
  100d46:	ff 07 
	idt_p.base = (unsigned int) &idt;
  100d48:	b8 c0 c1 10 00       	mov    $0x10c1c0,%eax
  100d4d:	a3 82 c1 10 00       	mov    %eax,0x10c182
	memset(&idt, 0, sizeof(idt));
  100d52:	83 ec 04             	sub    $0x4,%esp
  100d55:	68 00 08 00 00       	push   $0x800
  100d5a:	6a 00                	push   $0x0
  100d5c:	68 c0 c1 10 00       	push   $0x10c1c0
  100d61:	e8 2a 35 00 00       	call   104290 <memset>
  100d66:	83 c4 10             	add    $0x10,%esp
	idt_load();
  100d69:	e8 8c fa ff ff       	call   1007fa <idt_load>
}
  100d6e:	c9                   	leave  
  100d6f:	c3                   	ret    

00100d70 <isr_init>:



void *isr_routines[256];

void isr_init() {
  100d70:	55                   	push   %ebp
  100d71:	89 e5                	mov    %esp,%ebp
  100d73:	83 ec 08             	sub    $0x8,%esp
	idt_set_gate(0, (unsigned)isr0, 0x08, 0x8E);
  100d76:	b8 02 08 10 00       	mov    $0x100802,%eax
  100d7b:	68 8e 00 00 00       	push   $0x8e
  100d80:	6a 08                	push   $0x8
  100d82:	50                   	push   %eax
  100d83:	6a 00                	push   $0x0
  100d85:	e8 48 ff ff ff       	call   100cd2 <idt_set_gate>
  100d8a:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(1, (unsigned)isr1, 0x08, 0x8E);
  100d8d:	b8 0c 08 10 00       	mov    $0x10080c,%eax
  100d92:	68 8e 00 00 00       	push   $0x8e
  100d97:	6a 08                	push   $0x8
  100d99:	50                   	push   %eax
  100d9a:	6a 01                	push   $0x1
  100d9c:	e8 31 ff ff ff       	call   100cd2 <idt_set_gate>
  100da1:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(2, (unsigned)isr2, 0x08, 0x8E);
  100da4:	b8 16 08 10 00       	mov    $0x100816,%eax
  100da9:	68 8e 00 00 00       	push   $0x8e
  100dae:	6a 08                	push   $0x8
  100db0:	50                   	push   %eax
  100db1:	6a 02                	push   $0x2
  100db3:	e8 1a ff ff ff       	call   100cd2 <idt_set_gate>
  100db8:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(3, (unsigned)isr3, 0x08, 0x8E);
  100dbb:	b8 20 08 10 00       	mov    $0x100820,%eax
  100dc0:	68 8e 00 00 00       	push   $0x8e
  100dc5:	6a 08                	push   $0x8
  100dc7:	50                   	push   %eax
  100dc8:	6a 03                	push   $0x3
  100dca:	e8 03 ff ff ff       	call   100cd2 <idt_set_gate>
  100dcf:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(4, (unsigned)isr4, 0x08, 0x8E);
  100dd2:	b8 2a 08 10 00       	mov    $0x10082a,%eax
  100dd7:	68 8e 00 00 00       	push   $0x8e
  100ddc:	6a 08                	push   $0x8
  100dde:	50                   	push   %eax
  100ddf:	6a 04                	push   $0x4
  100de1:	e8 ec fe ff ff       	call   100cd2 <idt_set_gate>
  100de6:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(5, (unsigned)isr5, 0x08, 0x8E);
  100de9:	b8 34 08 10 00       	mov    $0x100834,%eax
  100dee:	68 8e 00 00 00       	push   $0x8e
  100df3:	6a 08                	push   $0x8
  100df5:	50                   	push   %eax
  100df6:	6a 05                	push   $0x5
  100df8:	e8 d5 fe ff ff       	call   100cd2 <idt_set_gate>
  100dfd:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(6, (unsigned)isr6, 0x08, 0x8E);
  100e00:	b8 3e 08 10 00       	mov    $0x10083e,%eax
  100e05:	68 8e 00 00 00       	push   $0x8e
  100e0a:	6a 08                	push   $0x8
  100e0c:	50                   	push   %eax
  100e0d:	6a 06                	push   $0x6
  100e0f:	e8 be fe ff ff       	call   100cd2 <idt_set_gate>
  100e14:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(7, (unsigned)isr7, 0x08, 0x8E);
  100e17:	b8 48 08 10 00       	mov    $0x100848,%eax
  100e1c:	68 8e 00 00 00       	push   $0x8e
  100e21:	6a 08                	push   $0x8
  100e23:	50                   	push   %eax
  100e24:	6a 07                	push   $0x7
  100e26:	e8 a7 fe ff ff       	call   100cd2 <idt_set_gate>
  100e2b:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(8, (unsigned)isr8, 0x08, 0x8E);
  100e2e:	b8 52 08 10 00       	mov    $0x100852,%eax
  100e33:	68 8e 00 00 00       	push   $0x8e
  100e38:	6a 08                	push   $0x8
  100e3a:	50                   	push   %eax
  100e3b:	6a 08                	push   $0x8
  100e3d:	e8 90 fe ff ff       	call   100cd2 <idt_set_gate>
  100e42:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(9, (unsigned)isr9, 0x08, 0x8E);
  100e45:	b8 5a 08 10 00       	mov    $0x10085a,%eax
  100e4a:	68 8e 00 00 00       	push   $0x8e
  100e4f:	6a 08                	push   $0x8
  100e51:	50                   	push   %eax
  100e52:	6a 09                	push   $0x9
  100e54:	e8 79 fe ff ff       	call   100cd2 <idt_set_gate>
  100e59:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(10, (unsigned)isr10, 0x08, 0x8E);
  100e5c:	b8 64 08 10 00       	mov    $0x100864,%eax
  100e61:	68 8e 00 00 00       	push   $0x8e
  100e66:	6a 08                	push   $0x8
  100e68:	50                   	push   %eax
  100e69:	6a 0a                	push   $0xa
  100e6b:	e8 62 fe ff ff       	call   100cd2 <idt_set_gate>
  100e70:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(11, (unsigned)isr11, 0x08, 0x8E);
  100e73:	b8 6c 08 10 00       	mov    $0x10086c,%eax
  100e78:	68 8e 00 00 00       	push   $0x8e
  100e7d:	6a 08                	push   $0x8
  100e7f:	50                   	push   %eax
  100e80:	6a 0b                	push   $0xb
  100e82:	e8 4b fe ff ff       	call   100cd2 <idt_set_gate>
  100e87:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(12, (unsigned)isr12, 0x08, 0x8E);
  100e8a:	b8 74 08 10 00       	mov    $0x100874,%eax
  100e8f:	68 8e 00 00 00       	push   $0x8e
  100e94:	6a 08                	push   $0x8
  100e96:	50                   	push   %eax
  100e97:	6a 0c                	push   $0xc
  100e99:	e8 34 fe ff ff       	call   100cd2 <idt_set_gate>
  100e9e:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(13, (unsigned)isr13, 0x08, 0x8E);
  100ea1:	b8 7c 08 10 00       	mov    $0x10087c,%eax
  100ea6:	68 8e 00 00 00       	push   $0x8e
  100eab:	6a 08                	push   $0x8
  100ead:	50                   	push   %eax
  100eae:	6a 0d                	push   $0xd
  100eb0:	e8 1d fe ff ff       	call   100cd2 <idt_set_gate>
  100eb5:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(14, (unsigned)isr14, 0x08, 0x8E);
  100eb8:	b8 84 08 10 00       	mov    $0x100884,%eax
  100ebd:	68 8e 00 00 00       	push   $0x8e
  100ec2:	6a 08                	push   $0x8
  100ec4:	50                   	push   %eax
  100ec5:	6a 0e                	push   $0xe
  100ec7:	e8 06 fe ff ff       	call   100cd2 <idt_set_gate>
  100ecc:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(15, (unsigned)isr15, 0x08, 0x8E);
  100ecf:	b8 8c 08 10 00       	mov    $0x10088c,%eax
  100ed4:	68 8e 00 00 00       	push   $0x8e
  100ed9:	6a 08                	push   $0x8
  100edb:	50                   	push   %eax
  100edc:	6a 0f                	push   $0xf
  100ede:	e8 ef fd ff ff       	call   100cd2 <idt_set_gate>
  100ee3:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(16, (unsigned)isr16, 0x08, 0x8E);
  100ee6:	b8 93 08 10 00       	mov    $0x100893,%eax
  100eeb:	68 8e 00 00 00       	push   $0x8e
  100ef0:	6a 08                	push   $0x8
  100ef2:	50                   	push   %eax
  100ef3:	6a 10                	push   $0x10
  100ef5:	e8 d8 fd ff ff       	call   100cd2 <idt_set_gate>
  100efa:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(17, (unsigned)isr17, 0x08, 0x8E);
  100efd:	b8 9a 08 10 00       	mov    $0x10089a,%eax
  100f02:	68 8e 00 00 00       	push   $0x8e
  100f07:	6a 08                	push   $0x8
  100f09:	50                   	push   %eax
  100f0a:	6a 11                	push   $0x11
  100f0c:	e8 c1 fd ff ff       	call   100cd2 <idt_set_gate>
  100f11:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(18, (unsigned)isr18, 0x08, 0x8E);
  100f14:	b8 a1 08 10 00       	mov    $0x1008a1,%eax
  100f19:	68 8e 00 00 00       	push   $0x8e
  100f1e:	6a 08                	push   $0x8
  100f20:	50                   	push   %eax
  100f21:	6a 12                	push   $0x12
  100f23:	e8 aa fd ff ff       	call   100cd2 <idt_set_gate>
  100f28:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(19, (unsigned)isr19, 0x08, 0x8E);
  100f2b:	b8 a8 08 10 00       	mov    $0x1008a8,%eax
  100f30:	68 8e 00 00 00       	push   $0x8e
  100f35:	6a 08                	push   $0x8
  100f37:	50                   	push   %eax
  100f38:	6a 13                	push   $0x13
  100f3a:	e8 93 fd ff ff       	call   100cd2 <idt_set_gate>
  100f3f:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(20, (unsigned)isr20, 0x08, 0x8E);
  100f42:	b8 af 08 10 00       	mov    $0x1008af,%eax
  100f47:	68 8e 00 00 00       	push   $0x8e
  100f4c:	6a 08                	push   $0x8
  100f4e:	50                   	push   %eax
  100f4f:	6a 14                	push   $0x14
  100f51:	e8 7c fd ff ff       	call   100cd2 <idt_set_gate>
  100f56:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(21, (unsigned)isr21, 0x08, 0x8E);
  100f59:	b8 b6 08 10 00       	mov    $0x1008b6,%eax
  100f5e:	68 8e 00 00 00       	push   $0x8e
  100f63:	6a 08                	push   $0x8
  100f65:	50                   	push   %eax
  100f66:	6a 15                	push   $0x15
  100f68:	e8 65 fd ff ff       	call   100cd2 <idt_set_gate>
  100f6d:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(22, (unsigned)isr22, 0x08, 0x8E);
  100f70:	b8 bd 08 10 00       	mov    $0x1008bd,%eax
  100f75:	68 8e 00 00 00       	push   $0x8e
  100f7a:	6a 08                	push   $0x8
  100f7c:	50                   	push   %eax
  100f7d:	6a 16                	push   $0x16
  100f7f:	e8 4e fd ff ff       	call   100cd2 <idt_set_gate>
  100f84:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(23, (unsigned)isr23, 0x08, 0x8E);
  100f87:	b8 c4 08 10 00       	mov    $0x1008c4,%eax
  100f8c:	68 8e 00 00 00       	push   $0x8e
  100f91:	6a 08                	push   $0x8
  100f93:	50                   	push   %eax
  100f94:	6a 17                	push   $0x17
  100f96:	e8 37 fd ff ff       	call   100cd2 <idt_set_gate>
  100f9b:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(24, (unsigned)isr24, 0x08, 0x8E);
  100f9e:	b8 cb 08 10 00       	mov    $0x1008cb,%eax
  100fa3:	68 8e 00 00 00       	push   $0x8e
  100fa8:	6a 08                	push   $0x8
  100faa:	50                   	push   %eax
  100fab:	6a 18                	push   $0x18
  100fad:	e8 20 fd ff ff       	call   100cd2 <idt_set_gate>
  100fb2:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(25, (unsigned)isr25, 0x08, 0x8E);
  100fb5:	b8 d2 08 10 00       	mov    $0x1008d2,%eax
  100fba:	68 8e 00 00 00       	push   $0x8e
  100fbf:	6a 08                	push   $0x8
  100fc1:	50                   	push   %eax
  100fc2:	6a 19                	push   $0x19
  100fc4:	e8 09 fd ff ff       	call   100cd2 <idt_set_gate>
  100fc9:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(26, (unsigned)isr26, 0x08, 0x8E);
  100fcc:	b8 d9 08 10 00       	mov    $0x1008d9,%eax
  100fd1:	68 8e 00 00 00       	push   $0x8e
  100fd6:	6a 08                	push   $0x8
  100fd8:	50                   	push   %eax
  100fd9:	6a 1a                	push   $0x1a
  100fdb:	e8 f2 fc ff ff       	call   100cd2 <idt_set_gate>
  100fe0:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(27, (unsigned)isr27, 0x08, 0x8E);
  100fe3:	b8 e0 08 10 00       	mov    $0x1008e0,%eax
  100fe8:	68 8e 00 00 00       	push   $0x8e
  100fed:	6a 08                	push   $0x8
  100fef:	50                   	push   %eax
  100ff0:	6a 1b                	push   $0x1b
  100ff2:	e8 db fc ff ff       	call   100cd2 <idt_set_gate>
  100ff7:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(28, (unsigned)isr28, 0x08, 0x8E);
  100ffa:	b8 e7 08 10 00       	mov    $0x1008e7,%eax
  100fff:	68 8e 00 00 00       	push   $0x8e
  101004:	6a 08                	push   $0x8
  101006:	50                   	push   %eax
  101007:	6a 1c                	push   $0x1c
  101009:	e8 c4 fc ff ff       	call   100cd2 <idt_set_gate>
  10100e:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(29, (unsigned)isr29, 0x08, 0x8E);
  101011:	b8 ee 08 10 00       	mov    $0x1008ee,%eax
  101016:	68 8e 00 00 00       	push   $0x8e
  10101b:	6a 08                	push   $0x8
  10101d:	50                   	push   %eax
  10101e:	6a 1d                	push   $0x1d
  101020:	e8 ad fc ff ff       	call   100cd2 <idt_set_gate>
  101025:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(30, (unsigned)isr30, 0x08, 0x8E);
  101028:	b8 f5 08 10 00       	mov    $0x1008f5,%eax
  10102d:	68 8e 00 00 00       	push   $0x8e
  101032:	6a 08                	push   $0x8
  101034:	50                   	push   %eax
  101035:	6a 1e                	push   $0x1e
  101037:	e8 96 fc ff ff       	call   100cd2 <idt_set_gate>
  10103c:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(31, (unsigned)isr31, 0x08, 0x8E);
  10103f:	b8 fc 08 10 00       	mov    $0x1008fc,%eax
  101044:	68 8e 00 00 00       	push   $0x8e
  101049:	6a 08                	push   $0x8
  10104b:	50                   	push   %eax
  10104c:	6a 1f                	push   $0x1f
  10104e:	e8 7f fc ff ff       	call   100cd2 <idt_set_gate>
  101053:	83 c4 10             	add    $0x10,%esp

	idt_set_gate(128, (unsigned)isr128, 0x08, 0xee); // EE - DPL3
  101056:	b8 03 09 10 00       	mov    $0x100903,%eax
  10105b:	68 ee 00 00 00       	push   $0xee
  101060:	6a 08                	push   $0x8
  101062:	50                   	push   %eax
  101063:	68 80 00 00 00       	push   $0x80
  101068:	e8 65 fc ff ff       	call   100cd2 <idt_set_gate>
  10106d:	83 c4 10             	add    $0x10,%esp

	memset(isr_routines, 0, sizeof(isr_routines));
  101070:	83 ec 04             	sub    $0x4,%esp
  101073:	68 00 04 00 00       	push   $0x400
  101078:	6a 00                	push   $0x0
  10107a:	68 c0 c9 10 00       	push   $0x10c9c0
  10107f:	e8 0c 32 00 00       	call   104290 <memset>
  101084:	83 c4 10             	add    $0x10,%esp

}
  101087:	c9                   	leave  
  101088:	c3                   	ret    

00101089 <fault_handler>:
	"Reserved Exceptions 29",
	"Reserved Exceptions 30",
	"Reserved Exceptions 31",
};

void fault_handler(struct iregs *r) {
  101089:	55                   	push   %ebp
  10108a:	89 e5                	mov    %esp,%ebp
  10108c:	53                   	push   %ebx
  10108d:	83 ec 14             	sub    $0x14,%esp
	int ret = 0;
  101090:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if(r->int_no < 32) {
  101097:	8b 45 08             	mov    0x8(%ebp),%eax
  10109a:	8b 40 30             	mov    0x30(%eax),%eax
  10109d:	83 f8 1f             	cmp    $0x1f,%eax
  1010a0:	0f 87 17 01 00 00    	ja     1011bd <fault_handler+0x134>
		if(r->int_no == 14) {
  1010a6:	8b 45 08             	mov    0x8(%ebp),%eax
  1010a9:	8b 40 30             	mov    0x30(%eax),%eax
  1010ac:	83 f8 0e             	cmp    $0xe,%eax
  1010af:	75 1c                	jne    1010cd <fault_handler+0x44>
			ret = page_fault(r);
  1010b1:	83 ec 0c             	sub    $0xc,%esp
  1010b4:	ff 75 08             	pushl  0x8(%ebp)
  1010b7:	e8 e8 08 00 00       	call   1019a4 <page_fault>
  1010bc:	83 c4 10             	add    $0x10,%esp
  1010bf:	89 45 f4             	mov    %eax,-0xc(%ebp)
			if(ret) {
  1010c2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  1010c6:	74 23                	je     1010eb <fault_handler+0x62>
				return;
  1010c8:	e9 f0 00 00 00       	jmp    1011bd <fault_handler+0x134>
			}
		} else {
			kprintf("%s Exception\n", exception_msgs[r->int_no]);
  1010cd:	8b 45 08             	mov    0x8(%ebp),%eax
  1010d0:	8b 40 30             	mov    0x30(%eax),%eax
  1010d3:	8b 04 85 c0 61 10 00 	mov    0x1061c0(,%eax,4),%eax
  1010da:	83 ec 08             	sub    $0x8,%esp
  1010dd:	50                   	push   %eax
  1010de:	68 3c 68 10 00       	push   $0x10683c
  1010e3:	e8 c0 f2 ff ff       	call   1003a8 <kprintf>
  1010e8:	83 c4 10             	add    $0x10,%esp
		}
		kprintf("  ds:  0x%-8X  es:  0x%-8X  fs:   0x%-8X  gs:   0x%-8X\n", r->ds, r->es, r->fs, r->gs);
  1010eb:	8b 45 08             	mov    0x8(%ebp),%eax
  1010ee:	8b 18                	mov    (%eax),%ebx
  1010f0:	8b 45 08             	mov    0x8(%ebp),%eax
  1010f3:	8b 48 04             	mov    0x4(%eax),%ecx
  1010f6:	8b 45 08             	mov    0x8(%ebp),%eax
  1010f9:	8b 50 08             	mov    0x8(%eax),%edx
  1010fc:	8b 45 08             	mov    0x8(%ebp),%eax
  1010ff:	8b 40 0c             	mov    0xc(%eax),%eax
  101102:	83 ec 0c             	sub    $0xc,%esp
  101105:	53                   	push   %ebx
  101106:	51                   	push   %ecx
  101107:	52                   	push   %edx
  101108:	50                   	push   %eax
  101109:	68 4c 68 10 00       	push   $0x10684c
  10110e:	e8 95 f2 ff ff       	call   1003a8 <kprintf>
  101113:	83 c4 20             	add    $0x20,%esp
		kprintf("  edi: 0x%-8X  esi: 0x%-8X  ebp:  0x%-8X  esp:  0x%-8X\n", r->edi, r->esi, r->ebp, r->esp);
  101116:	8b 45 08             	mov    0x8(%ebp),%eax
  101119:	8b 58 1c             	mov    0x1c(%eax),%ebx
  10111c:	8b 45 08             	mov    0x8(%ebp),%eax
  10111f:	8b 48 18             	mov    0x18(%eax),%ecx
  101122:	8b 45 08             	mov    0x8(%ebp),%eax
  101125:	8b 50 14             	mov    0x14(%eax),%edx
  101128:	8b 45 08             	mov    0x8(%ebp),%eax
  10112b:	8b 40 10             	mov    0x10(%eax),%eax
  10112e:	83 ec 0c             	sub    $0xc,%esp
  101131:	53                   	push   %ebx
  101132:	51                   	push   %ecx
  101133:	52                   	push   %edx
  101134:	50                   	push   %eax
  101135:	68 84 68 10 00       	push   $0x106884
  10113a:	e8 69 f2 ff ff       	call   1003a8 <kprintf>
  10113f:	83 c4 20             	add    $0x20,%esp
		kprintf("  eax: 0x%-8X  ebx: 0x%-8X  ecx:  0x%-8X  edx:  0x%-8X\n", r->eax, r->ebx, r->ecx, r->edx);
  101142:	8b 45 08             	mov    0x8(%ebp),%eax
  101145:	8b 58 24             	mov    0x24(%eax),%ebx
  101148:	8b 45 08             	mov    0x8(%ebp),%eax
  10114b:	8b 48 28             	mov    0x28(%eax),%ecx
  10114e:	8b 45 08             	mov    0x8(%ebp),%eax
  101151:	8b 50 20             	mov    0x20(%eax),%edx
  101154:	8b 45 08             	mov    0x8(%ebp),%eax
  101157:	8b 40 2c             	mov    0x2c(%eax),%eax
  10115a:	83 ec 0c             	sub    $0xc,%esp
  10115d:	53                   	push   %ebx
  10115e:	51                   	push   %ecx
  10115f:	52                   	push   %edx
  101160:	50                   	push   %eax
  101161:	68 bc 68 10 00       	push   $0x1068bc
  101166:	e8 3d f2 ff ff       	call   1003a8 <kprintf>
  10116b:	83 c4 20             	add    $0x20,%esp
		kprintf("  cs:  0x%-8X  eip: 0x%-8X  flgs: 0x%-8X  uesp: 0x%-8X\n", r->cs, r->eip, r->eflags, r->useresp);
  10116e:	8b 45 08             	mov    0x8(%ebp),%eax
  101171:	8b 58 44             	mov    0x44(%eax),%ebx
  101174:	8b 45 08             	mov    0x8(%ebp),%eax
  101177:	8b 48 40             	mov    0x40(%eax),%ecx
  10117a:	8b 45 08             	mov    0x8(%ebp),%eax
  10117d:	8b 50 38             	mov    0x38(%eax),%edx
  101180:	8b 45 08             	mov    0x8(%ebp),%eax
  101183:	8b 40 3c             	mov    0x3c(%eax),%eax
  101186:	83 ec 0c             	sub    $0xc,%esp
  101189:	53                   	push   %ebx
  10118a:	51                   	push   %ecx
  10118b:	52                   	push   %edx
  10118c:	50                   	push   %eax
  10118d:	68 f4 68 10 00       	push   $0x1068f4
  101192:	e8 11 f2 ff ff       	call   1003a8 <kprintf>
  101197:	83 c4 20             	add    $0x20,%esp
		kprintf("  ss:  0x%-8X  errcode: %-8X\n", r->ss, r->err_code);
  10119a:	8b 45 08             	mov    0x8(%ebp),%eax
  10119d:	8b 50 34             	mov    0x34(%eax),%edx
  1011a0:	8b 45 08             	mov    0x8(%ebp),%eax
  1011a3:	8b 40 48             	mov    0x48(%eax),%eax
  1011a6:	83 ec 04             	sub    $0x4,%esp
  1011a9:	52                   	push   %edx
  1011aa:	50                   	push   %eax
  1011ab:	68 2c 69 10 00       	push   $0x10692c
  1011b0:	e8 f3 f1 ff ff       	call   1003a8 <kprintf>
  1011b5:	83 c4 10             	add    $0x10,%esp
		halt();
  1011b8:	e8 1e f6 ff ff       	call   1007db <halt>
	}
}
  1011bd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1011c0:	c9                   	leave  
  1011c1:	c3                   	ret    

001011c2 <isr_install_handler>:


void isr_install_handler(int isr, unsigned int (*handler)(struct iregs *r))
{
  1011c2:	55                   	push   %ebp
  1011c3:	89 e5                	mov    %esp,%ebp
	isr_routines[isr] = handler;
  1011c5:	8b 45 08             	mov    0x8(%ebp),%eax
  1011c8:	8b 55 0c             	mov    0xc(%ebp),%edx
  1011cb:	89 14 85 c0 c9 10 00 	mov    %edx,0x10c9c0(,%eax,4)
}
  1011d2:	5d                   	pop    %ebp
  1011d3:	c3                   	ret    

001011d4 <isr_uninstall_handler>:

void isr_uninstall_handler(int isr)
{
  1011d4:	55                   	push   %ebp
  1011d5:	89 e5                	mov    %esp,%ebp
	isr_routines[isr] = 0;
  1011d7:	8b 45 08             	mov    0x8(%ebp),%eax
  1011da:	c7 04 85 c0 c9 10 00 	movl   $0x0,0x10c9c0(,%eax,4)
  1011e1:	00 00 00 00 
}
  1011e5:	5d                   	pop    %ebp
  1011e6:	c3                   	ret    

001011e7 <isr_handler>:


unsigned int isr_handler(struct iregs *r)
{
  1011e7:	55                   	push   %ebp
  1011e8:	89 e5                	mov    %esp,%ebp
  1011ea:	83 ec 18             	sub    $0x18,%esp
	unsigned int int_no = 0xFF & r->int_no;
  1011ed:	8b 45 08             	mov    0x8(%ebp),%eax
  1011f0:	8b 40 30             	mov    0x30(%eax),%eax
  1011f3:	25 ff 00 00 00       	and    $0xff,%eax
  1011f8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	unsigned int (*handler) (struct iregs *r);

	handler = isr_routines[int_no];
  1011fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1011fe:	8b 04 85 c0 c9 10 00 	mov    0x10c9c0(,%eax,4),%eax
  101205:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if(handler) {
  101208:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  10120c:	74 10                	je     10121e <isr_handler+0x37>
		return handler(r);
  10120e:	83 ec 0c             	sub    $0xc,%esp
  101211:	ff 75 08             	pushl  0x8(%ebp)
  101214:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101217:	ff d0                	call   *%eax
  101219:	83 c4 10             	add    $0x10,%esp
  10121c:	eb 13                	jmp    101231 <isr_handler+0x4a>
	}
	else {
		fault_handler(r);
  10121e:	83 ec 0c             	sub    $0xc,%esp
  101221:	ff 75 08             	pushl  0x8(%ebp)
  101224:	e8 60 fe ff ff       	call   101089 <fault_handler>
  101229:	83 c4 10             	add    $0x10,%esp
		return 0;
  10122c:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
  101231:	c9                   	leave  
  101232:	c3                   	ret    

00101233 <irq_install_handler>:
void *irq_routines[16] = {
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0
};

void irq_install_handler(int irq, void (*handler)(struct iregs *r)) {
  101233:	55                   	push   %ebp
  101234:	89 e5                	mov    %esp,%ebp
	irq_routines[irq] = handler;
  101236:	8b 45 08             	mov    0x8(%ebp),%eax
  101239:	8b 55 0c             	mov    0xc(%ebp),%edx
  10123c:	89 14 85 40 b0 10 00 	mov    %edx,0x10b040(,%eax,4)
}
  101243:	5d                   	pop    %ebp
  101244:	c3                   	ret    

00101245 <irq_uninstall_handler>:

void irq_uninstall_handler(int irq){
  101245:	55                   	push   %ebp
  101246:	89 e5                	mov    %esp,%ebp
	irq_routines[irq] = 0;
  101248:	8b 45 08             	mov    0x8(%ebp),%eax
  10124b:	c7 04 85 40 b0 10 00 	movl   $0x0,0x10b040(,%eax,4)
  101252:	00 00 00 00 
}
  101256:	5d                   	pop    %ebp
  101257:	c3                   	ret    

00101258 <irq_remap>:


void irq_remap(void) {
  101258:	55                   	push   %ebp
  101259:	89 e5                	mov    %esp,%ebp
  10125b:	83 ec 08             	sub    $0x8,%esp
	outb(port_8259M, 0x11); // init master
  10125e:	83 ec 08             	sub    $0x8,%esp
  101261:	6a 11                	push   $0x11
  101263:	6a 20                	push   $0x20
  101265:	e8 96 ed ff ff       	call   100000 <outb>
  10126a:	83 c4 10             	add    $0x10,%esp
	outb(port_8259S, 0x11); // init slave
  10126d:	83 ec 08             	sub    $0x8,%esp
  101270:	6a 11                	push   $0x11
  101272:	68 a0 00 00 00       	push   $0xa0
  101277:	e8 84 ed ff ff       	call   100000 <outb>
  10127c:	83 c4 10             	add    $0x10,%esp

	outb(port_8259M+1, 0x20);	// intreruperea de baza pt master - 0x20 (remapate dupa primele 32 entries in IDT, care sunt isrs)
  10127f:	83 ec 08             	sub    $0x8,%esp
  101282:	6a 20                	push   $0x20
  101284:	6a 21                	push   $0x21
  101286:	e8 75 ed ff ff       	call   100000 <outb>
  10128b:	83 c4 10             	add    $0x10,%esp
	outb(port_8259S+1, 0x28);	// intreruperea de baza pt slave - 0x20+8
  10128e:	83 ec 08             	sub    $0x8,%esp
  101291:	6a 28                	push   $0x28
  101293:	68 a1 00 00 00       	push   $0xa1
  101298:	e8 63 ed ff ff       	call   100000 <outb>
  10129d:	83 c4 10             	add    $0x10,%esp

	outb(port_8259M+1, 0x04);	// primul chip e master
  1012a0:	83 ec 08             	sub    $0x8,%esp
  1012a3:	6a 04                	push   $0x4
  1012a5:	6a 21                	push   $0x21
  1012a7:	e8 54 ed ff ff       	call   100000 <outb>
  1012ac:	83 c4 10             	add    $0x10,%esp
	outb(port_8259S+1, 0x02);	// al doilea chip e slave
  1012af:	83 ec 08             	sub    $0x8,%esp
  1012b2:	6a 02                	push   $0x2
  1012b4:	68 a1 00 00 00       	push   $0xa1
  1012b9:	e8 42 ed ff ff       	call   100000 <outb>
  1012be:	83 c4 10             	add    $0x10,%esp

	outb(port_8259M+1, 0x01);	// mod 8086 pt amandoua
  1012c1:	83 ec 08             	sub    $0x8,%esp
  1012c4:	6a 01                	push   $0x1
  1012c6:	6a 21                	push   $0x21
  1012c8:	e8 33 ed ff ff       	call   100000 <outb>
  1012cd:	83 c4 10             	add    $0x10,%esp
	outb(port_8259S+1, 0x01);
  1012d0:	83 ec 08             	sub    $0x8,%esp
  1012d3:	6a 01                	push   $0x1
  1012d5:	68 a1 00 00 00       	push   $0xa1
  1012da:	e8 21 ed ff ff       	call   100000 <outb>
  1012df:	83 c4 10             	add    $0x10,%esp

	outb(port_8259M+1, 0x0);	// mascam porturile
  1012e2:	83 ec 08             	sub    $0x8,%esp
  1012e5:	6a 00                	push   $0x0
  1012e7:	6a 21                	push   $0x21
  1012e9:	e8 12 ed ff ff       	call   100000 <outb>
  1012ee:	83 c4 10             	add    $0x10,%esp
	outb(port_8259S+1, 0x0);
  1012f1:	83 ec 08             	sub    $0x8,%esp
  1012f4:	6a 00                	push   $0x0
  1012f6:	68 a1 00 00 00       	push   $0xa1
  1012fb:	e8 00 ed ff ff       	call   100000 <outb>
  101300:	83 c4 10             	add    $0x10,%esp
}
  101303:	c9                   	leave  
  101304:	c3                   	ret    

00101305 <irq_install>:

void irq_install(void){
  101305:	55                   	push   %ebp
  101306:	89 e5                	mov    %esp,%ebp
  101308:	83 ec 08             	sub    $0x8,%esp
	irq_remap();
  10130b:	e8 48 ff ff ff       	call   101258 <irq_remap>
	idt_set_gate(32, (unsigned) irq0, 0x08, 0x8E);
  101310:	b8 34 09 10 00       	mov    $0x100934,%eax
  101315:	68 8e 00 00 00       	push   $0x8e
  10131a:	6a 08                	push   $0x8
  10131c:	50                   	push   %eax
  10131d:	6a 20                	push   $0x20
  10131f:	e8 ae f9 ff ff       	call   100cd2 <idt_set_gate>
  101324:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(33, (unsigned) irq1, 0x08, 0x8E);
  101327:	b8 3b 09 10 00       	mov    $0x10093b,%eax
  10132c:	68 8e 00 00 00       	push   $0x8e
  101331:	6a 08                	push   $0x8
  101333:	50                   	push   %eax
  101334:	6a 21                	push   $0x21
  101336:	e8 97 f9 ff ff       	call   100cd2 <idt_set_gate>
  10133b:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(34, (unsigned) irq2, 0x08, 0x8E);
  10133e:	b8 42 09 10 00       	mov    $0x100942,%eax
  101343:	68 8e 00 00 00       	push   $0x8e
  101348:	6a 08                	push   $0x8
  10134a:	50                   	push   %eax
  10134b:	6a 22                	push   $0x22
  10134d:	e8 80 f9 ff ff       	call   100cd2 <idt_set_gate>
  101352:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(35, (unsigned) irq3, 0x08, 0x8E);
  101355:	b8 49 09 10 00       	mov    $0x100949,%eax
  10135a:	68 8e 00 00 00       	push   $0x8e
  10135f:	6a 08                	push   $0x8
  101361:	50                   	push   %eax
  101362:	6a 23                	push   $0x23
  101364:	e8 69 f9 ff ff       	call   100cd2 <idt_set_gate>
  101369:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(36, (unsigned) irq4, 0x08, 0x8E);
  10136c:	b8 50 09 10 00       	mov    $0x100950,%eax
  101371:	68 8e 00 00 00       	push   $0x8e
  101376:	6a 08                	push   $0x8
  101378:	50                   	push   %eax
  101379:	6a 24                	push   $0x24
  10137b:	e8 52 f9 ff ff       	call   100cd2 <idt_set_gate>
  101380:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(37, (unsigned) irq5, 0x08, 0x8E);
  101383:	b8 57 09 10 00       	mov    $0x100957,%eax
  101388:	68 8e 00 00 00       	push   $0x8e
  10138d:	6a 08                	push   $0x8
  10138f:	50                   	push   %eax
  101390:	6a 25                	push   $0x25
  101392:	e8 3b f9 ff ff       	call   100cd2 <idt_set_gate>
  101397:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(38, (unsigned) irq6, 0x08, 0x8E);
  10139a:	b8 5e 09 10 00       	mov    $0x10095e,%eax
  10139f:	68 8e 00 00 00       	push   $0x8e
  1013a4:	6a 08                	push   $0x8
  1013a6:	50                   	push   %eax
  1013a7:	6a 26                	push   $0x26
  1013a9:	e8 24 f9 ff ff       	call   100cd2 <idt_set_gate>
  1013ae:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(39, (unsigned) irq7, 0x08, 0x8E);
  1013b1:	b8 65 09 10 00       	mov    $0x100965,%eax
  1013b6:	68 8e 00 00 00       	push   $0x8e
  1013bb:	6a 08                	push   $0x8
  1013bd:	50                   	push   %eax
  1013be:	6a 27                	push   $0x27
  1013c0:	e8 0d f9 ff ff       	call   100cd2 <idt_set_gate>
  1013c5:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(40, (unsigned) irq8, 0x08, 0x8E);
  1013c8:	b8 6c 09 10 00       	mov    $0x10096c,%eax
  1013cd:	68 8e 00 00 00       	push   $0x8e
  1013d2:	6a 08                	push   $0x8
  1013d4:	50                   	push   %eax
  1013d5:	6a 28                	push   $0x28
  1013d7:	e8 f6 f8 ff ff       	call   100cd2 <idt_set_gate>
  1013dc:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(41, (unsigned) irq9, 0x08, 0x8E);
  1013df:	b8 73 09 10 00       	mov    $0x100973,%eax
  1013e4:	68 8e 00 00 00       	push   $0x8e
  1013e9:	6a 08                	push   $0x8
  1013eb:	50                   	push   %eax
  1013ec:	6a 29                	push   $0x29
  1013ee:	e8 df f8 ff ff       	call   100cd2 <idt_set_gate>
  1013f3:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(42, (unsigned) irq10, 0x08, 0x8E);
  1013f6:	b8 7a 09 10 00       	mov    $0x10097a,%eax
  1013fb:	68 8e 00 00 00       	push   $0x8e
  101400:	6a 08                	push   $0x8
  101402:	50                   	push   %eax
  101403:	6a 2a                	push   $0x2a
  101405:	e8 c8 f8 ff ff       	call   100cd2 <idt_set_gate>
  10140a:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(43, (unsigned) irq11, 0x08, 0x8E);
  10140d:	b8 81 09 10 00       	mov    $0x100981,%eax
  101412:	68 8e 00 00 00       	push   $0x8e
  101417:	6a 08                	push   $0x8
  101419:	50                   	push   %eax
  10141a:	6a 2b                	push   $0x2b
  10141c:	e8 b1 f8 ff ff       	call   100cd2 <idt_set_gate>
  101421:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(44, (unsigned) irq12, 0x08, 0x8E);
  101424:	b8 88 09 10 00       	mov    $0x100988,%eax
  101429:	68 8e 00 00 00       	push   $0x8e
  10142e:	6a 08                	push   $0x8
  101430:	50                   	push   %eax
  101431:	6a 2c                	push   $0x2c
  101433:	e8 9a f8 ff ff       	call   100cd2 <idt_set_gate>
  101438:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(45, (unsigned) irq13, 0x08, 0x8E);
  10143b:	b8 8f 09 10 00       	mov    $0x10098f,%eax
  101440:	68 8e 00 00 00       	push   $0x8e
  101445:	6a 08                	push   $0x8
  101447:	50                   	push   %eax
  101448:	6a 2d                	push   $0x2d
  10144a:	e8 83 f8 ff ff       	call   100cd2 <idt_set_gate>
  10144f:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(46, (unsigned) irq14, 0x08, 0x8E);
  101452:	b8 96 09 10 00       	mov    $0x100996,%eax
  101457:	68 8e 00 00 00       	push   $0x8e
  10145c:	6a 08                	push   $0x8
  10145e:	50                   	push   %eax
  10145f:	6a 2e                	push   $0x2e
  101461:	e8 6c f8 ff ff       	call   100cd2 <idt_set_gate>
  101466:	83 c4 10             	add    $0x10,%esp
	idt_set_gate(47, (unsigned) irq15, 0x08, 0x8E);
  101469:	b8 9d 09 10 00       	mov    $0x10099d,%eax
  10146e:	68 8e 00 00 00       	push   $0x8e
  101473:	6a 08                	push   $0x8
  101475:	50                   	push   %eax
  101476:	6a 2f                	push   $0x2f
  101478:	e8 55 f8 ff ff       	call   100cd2 <idt_set_gate>
  10147d:	83 c4 10             	add    $0x10,%esp
}
  101480:	c9                   	leave  
  101481:	c3                   	ret    

00101482 <irq_handler>:

void irq_handler(struct iregs *r) {
  101482:	55                   	push   %ebp
  101483:	89 e5                	mov    %esp,%ebp
  101485:	83 ec 18             	sub    $0x18,%esp
	// a blank function pointer //

	if(r->int_no >= 0x28) {	// daca e intrerupere pe slave, send end of interrupt
  101488:	8b 45 08             	mov    0x8(%ebp),%eax
  10148b:	8b 40 30             	mov    0x30(%eax),%eax
  10148e:	83 f8 27             	cmp    $0x27,%eax
  101491:	76 12                	jbe    1014a5 <irq_handler+0x23>
		outb(port_8259S, 0x20);
  101493:	83 ec 08             	sub    $0x8,%esp
  101496:	6a 20                	push   $0x20
  101498:	68 a0 00 00 00       	push   $0xa0
  10149d:	e8 5e eb ff ff       	call   100000 <outb>
  1014a2:	83 c4 10             	add    $0x10,%esp
	}
	// trimite end of interrupt pe master indiferent (sclavul e legat la master irq2, triggereaza ambele)
	outb(port_8259M, 0x20);
  1014a5:	83 ec 08             	sub    $0x8,%esp
  1014a8:	6a 20                	push   $0x20
  1014aa:	6a 20                	push   $0x20
  1014ac:	e8 4f eb ff ff       	call   100000 <outb>
  1014b1:	83 c4 10             	add    $0x10,%esp

	void (*handler) (struct iregs *r);
	handler = irq_routines[r->int_no - 32];
  1014b4:	8b 45 08             	mov    0x8(%ebp),%eax
  1014b7:	8b 40 30             	mov    0x30(%eax),%eax
  1014ba:	83 e8 20             	sub    $0x20,%eax
  1014bd:	8b 04 85 40 b0 10 00 	mov    0x10b040(,%eax,4),%eax
  1014c4:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(handler) {
  1014c7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  1014cb:	74 0e                	je     1014db <irq_handler+0x59>
		handler(r);
  1014cd:	83 ec 0c             	sub    $0xc,%esp
  1014d0:	ff 75 08             	pushl  0x8(%ebp)
  1014d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1014d6:	ff d0                	call   *%eax
  1014d8:	83 c4 10             	add    $0x10,%esp
	}
}
  1014db:	c9                   	leave  
  1014dc:	c3                   	ret    

001014dd <timer_phase>:
#define pit_data2 0x41		// data channel 2 register - sys specific
#define pit_data3 0x42		// data channel 3 register - speaker
#define pit_cmmnd 0x43		// command register


void timer_phase (int hz) {
  1014dd:	55                   	push   %ebp
  1014de:	89 e5                	mov    %esp,%ebp
  1014e0:	83 ec 18             	sub    $0x18,%esp
	int divisor = 1193180 / hz;		// compute divisor //
  1014e3:	b8 dc 34 12 00       	mov    $0x1234dc,%eax
  1014e8:	99                   	cltd   
  1014e9:	f7 7d 08             	idivl  0x8(%ebp)
  1014ec:	89 45 f4             	mov    %eax,-0xc(%ebp)
	outb(pit_cmmnd, 0x36);
  1014ef:	83 ec 08             	sub    $0x8,%esp
  1014f2:	6a 36                	push   $0x36
  1014f4:	6a 43                	push   $0x43
  1014f6:	e8 05 eb ff ff       	call   100000 <outb>
  1014fb:	83 c4 10             	add    $0x10,%esp
	outb(pit_data1, divisor & 0xFF); // set low byte of divisor
  1014fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101501:	0f b6 c0             	movzbl %al,%eax
  101504:	83 ec 08             	sub    $0x8,%esp
  101507:	50                   	push   %eax
  101508:	6a 40                	push   $0x40
  10150a:	e8 f1 ea ff ff       	call   100000 <outb>
  10150f:	83 c4 10             	add    $0x10,%esp
	outb(pit_data1, divisor >> 8);	// high byte of divisor
  101512:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101515:	c1 f8 08             	sar    $0x8,%eax
  101518:	0f b6 c0             	movzbl %al,%eax
  10151b:	83 ec 08             	sub    $0x8,%esp
  10151e:	50                   	push   %eax
  10151f:	6a 40                	push   $0x40
  101521:	e8 da ea ff ff       	call   100000 <outb>
  101526:	83 c4 10             	add    $0x10,%esp
}
  101529:	c9                   	leave  
  10152a:	c3                   	ret    

0010152b <timer_handler>:

void timer_handler(struct iregs *r) {
  10152b:	55                   	push   %ebp
  10152c:	89 e5                	mov    %esp,%ebp
  10152e:	83 ec 08             	sub    $0x8,%esp
	timer_ticks++;
  101531:	a1 fc c0 10 00       	mov    0x10c0fc,%eax
  101536:	83 c0 01             	add    $0x1,%eax
  101539:	a3 fc c0 10 00       	mov    %eax,0x10c0fc
	// if(timer_ticks % 1000 == 0) {
		task_switch(r);
  10153e:	83 ec 0c             	sub    $0xc,%esp
  101541:	ff 75 08             	pushl  0x8(%ebp)
  101544:	e8 0c 2b 00 00       	call   104055 <task_switch>
  101549:	83 c4 10             	add    $0x10,%esp
	// }
//	if(timer_ticks % 100 == 0) {
//		kprintf(".");
//	}
}
  10154c:	c9                   	leave  
  10154d:	c3                   	ret    

0010154e <timer_install>:


void timer_install(void) {
  10154e:	55                   	push   %ebp
  10154f:	89 e5                	mov    %esp,%ebp
  101551:	83 ec 08             	sub    $0x8,%esp
	timer_ticks = 0;
  101554:	c7 05 fc c0 10 00 00 	movl   $0x0,0x10c0fc
  10155b:	00 00 00 
	timer_phase(100); // o intrerupere la a suta parte din secunda
  10155e:	83 ec 0c             	sub    $0xc,%esp
  101561:	6a 64                	push   $0x64
  101563:	e8 75 ff ff ff       	call   1014dd <timer_phase>
  101568:	83 c4 10             	add    $0x10,%esp
	irq_install_handler(0, timer_handler); // seteaza timerul pe intreruperea 0
  10156b:	83 ec 08             	sub    $0x8,%esp
  10156e:	68 2b 15 10 00       	push   $0x10152b
  101573:	6a 00                	push   $0x0
  101575:	e8 b9 fc ff ff       	call   101233 <irq_install_handler>
  10157a:	83 c4 10             	add    $0x10,%esp
}
  10157d:	c9                   	leave  
  10157e:	c3                   	ret    

0010157f <timer_wait>:


void timer_wait(int ms)
{
  10157f:	55                   	push   %ebp
  101580:	89 e5                	mov    %esp,%ebp
  101582:	83 ec 10             	sub    $0x10,%esp
	ms = ms / 10;
  101585:	8b 4d 08             	mov    0x8(%ebp),%ecx
  101588:	ba 67 66 66 66       	mov    $0x66666667,%edx
  10158d:	89 c8                	mov    %ecx,%eax
  10158f:	f7 ea                	imul   %edx
  101591:	c1 fa 02             	sar    $0x2,%edx
  101594:	89 c8                	mov    %ecx,%eax
  101596:	c1 f8 1f             	sar    $0x1f,%eax
  101599:	29 c2                	sub    %eax,%edx
  10159b:	89 d0                	mov    %edx,%eax
  10159d:	89 45 08             	mov    %eax,0x8(%ebp)
	unsigned long eticks;
	eticks = timer_ticks + ms;
  1015a0:	8b 15 fc c0 10 00    	mov    0x10c0fc,%edx
  1015a6:	8b 45 08             	mov    0x8(%ebp),%eax
  1015a9:	01 d0                	add    %edx,%eax
  1015ab:	89 45 fc             	mov    %eax,-0x4(%ebp)
	while(timer_ticks < eticks) {
  1015ae:	eb 01                	jmp    1015b1 <timer_wait+0x32>
		nop();
  1015b0:	90                   	nop
void timer_wait(int ms)
{
	ms = ms / 10;
	unsigned long eticks;
	eticks = timer_ticks + ms;
	while(timer_ticks < eticks) {
  1015b1:	a1 fc c0 10 00       	mov    0x10c0fc,%eax
  1015b6:	3b 45 fc             	cmp    -0x4(%ebp),%eax
  1015b9:	72 f5                	jb     1015b0 <timer_wait+0x31>
		nop();
	}
}
  1015bb:	c9                   	leave  
  1015bc:	c3                   	ret    

001015bd <kbd_handler>:
		0
};

bool shift_pressed = false;

void kbd_handler() {
  1015bd:	55                   	push   %ebp
  1015be:	89 e5                	mov    %esp,%ebp
  1015c0:	83 ec 18             	sub    $0x18,%esp
	unsigned char scancode = 0;
  1015c3:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
	if(inb(0x64) & 1)
  1015c7:	83 ec 0c             	sub    $0xc,%esp
  1015ca:	6a 64                	push   $0x64
  1015cc:	e8 5a ea ff ff       	call   10002b <inb>
  1015d1:	83 c4 10             	add    $0x10,%esp
  1015d4:	0f b6 c0             	movzbl %al,%eax
  1015d7:	83 e0 01             	and    $0x1,%eax
  1015da:	85 c0                	test   %eax,%eax
  1015dc:	74 10                	je     1015ee <kbd_handler+0x31>
	scancode = inb(0x60);
  1015de:	83 ec 0c             	sub    $0xc,%esp
  1015e1:	6a 60                	push   $0x60
  1015e3:	e8 43 ea ff ff       	call   10002b <inb>
  1015e8:	83 c4 10             	add    $0x10,%esp
  1015eb:	88 45 f7             	mov    %al,-0x9(%ebp)
//	kprintf("%X ", scancode);
//	return;
	if(scancode & 0x80) {
  1015ee:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
  1015f2:	84 c0                	test   %al,%al
  1015f4:	79 1c                	jns    101612 <kbd_handler+0x55>
		// when key release //
		if(scancode == 0x2A || scancode == 0x36) {
  1015f6:	80 7d f7 2a          	cmpb   $0x2a,-0x9(%ebp)
  1015fa:	74 0a                	je     101606 <kbd_handler+0x49>
  1015fc:	80 7d f7 36          	cmpb   $0x36,-0x9(%ebp)
  101600:	0f 85 ee 00 00 00    	jne    1016f4 <kbd_handler+0x137>
			shift_pressed = false;
  101606:	c6 05 84 b0 10 00 00 	movb   $0x0,0x10b084
			return;
  10160d:	e9 e3 00 00 00       	jmp    1016f5 <kbd_handler+0x138>
		}
	} else {
		scancode = scancode & 0x7F;
  101612:	80 65 f7 7f          	andb   $0x7f,-0x9(%ebp)
		// 0x4D -> a right
		// 0x50 -> a down
		// 0x51 -> page down
		// 0x47 -> home
		// 0x4F -> end
		serial_debug("%X ", scancode);
  101616:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
  10161a:	83 ec 08             	sub    $0x8,%esp
  10161d:	50                   	push   %eax
  10161e:	68 4a 69 10 00       	push   $0x10694a
  101623:	e8 a9 01 00 00       	call   1017d1 <serial_debug>
  101628:	83 c4 10             	add    $0x10,%esp
		if(scancode == 0x48) {
  10162b:	80 7d f7 48          	cmpb   $0x48,-0x9(%ebp)
  10162f:	75 0a                	jne    10163b <kbd_handler+0x7e>
			scroll_up();
  101631:	e8 5e eb ff ff       	call   100194 <scroll_up>
			return;
  101636:	e9 ba 00 00 00       	jmp    1016f5 <kbd_handler+0x138>
		}
		if(scancode == 0x50) {
  10163b:	80 7d f7 50          	cmpb   $0x50,-0x9(%ebp)
  10163f:	75 0a                	jne    10164b <kbd_handler+0x8e>
			scroll_down();
  101641:	e8 65 eb ff ff       	call   1001ab <scroll_down>
			return;
  101646:	e9 aa 00 00 00       	jmp    1016f5 <kbd_handler+0x138>
		}
		if (scancode == 0x1) {
  10164b:	80 7d f7 01          	cmpb   $0x1,-0x9(%ebp)
  10164f:	75 43                	jne    101694 <kbd_handler+0xd7>
			kprintf("Shut down\n");
  101651:	83 ec 0c             	sub    $0xc,%esp
  101654:	68 4e 69 10 00       	push   $0x10694e
  101659:	e8 4a ed ff ff       	call   1003a8 <kprintf>
  10165e:	83 c4 10             	add    $0x10,%esp
			char *c = "Shutdown";
  101661:	c7 45 f0 59 69 10 00 	movl   $0x106959,-0x10(%ebp)
			while (*c) {
  101668:	eb 20                	jmp    10168a <kbd_handler+0xcd>
				outb(0x8900, *c++);
  10166a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10166d:	8d 50 01             	lea    0x1(%eax),%edx
  101670:	89 55 f0             	mov    %edx,-0x10(%ebp)
  101673:	0f b6 00             	movzbl (%eax),%eax
  101676:	0f b6 c0             	movzbl %al,%eax
  101679:	83 ec 08             	sub    $0x8,%esp
  10167c:	50                   	push   %eax
  10167d:	68 00 89 00 00       	push   $0x8900
  101682:	e8 79 e9 ff ff       	call   100000 <outb>
  101687:	83 c4 10             	add    $0x10,%esp
			return;
		}
		if (scancode == 0x1) {
			kprintf("Shut down\n");
			char *c = "Shutdown";
			while (*c) {
  10168a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10168d:	0f b6 00             	movzbl (%eax),%eax
  101690:	84 c0                	test   %al,%al
  101692:	75 d6                	jne    10166a <kbd_handler+0xad>
				outb(0x8900, *c++);
			}
		}
//		kprintf("%c", scancode);
		// when key pressed //
		if(scancode == 0x2A || scancode == 0x36) {
  101694:	80 7d f7 2a          	cmpb   $0x2a,-0x9(%ebp)
  101698:	74 06                	je     1016a0 <kbd_handler+0xe3>
  10169a:	80 7d f7 36          	cmpb   $0x36,-0x9(%ebp)
  10169e:	75 09                	jne    1016a9 <kbd_handler+0xec>
			shift_pressed = true;
  1016a0:	c6 05 84 b0 10 00 01 	movb   $0x1,0x10b084
			return;
  1016a7:	eb 4c                	jmp    1016f5 <kbd_handler+0x138>
		}
		if(shift_pressed) {
  1016a9:	0f b6 05 84 b0 10 00 	movzbl 0x10b084,%eax
  1016b0:	84 c0                	test   %al,%al
  1016b2:	74 21                	je     1016d5 <kbd_handler+0x118>
			kprintf("%c", kbd_map_shift[scancode]);
  1016b4:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
  1016b8:	0f b6 80 c0 62 10 00 	movzbl 0x1062c0(%eax),%eax
  1016bf:	0f b6 c0             	movzbl %al,%eax
  1016c2:	83 ec 08             	sub    $0x8,%esp
  1016c5:	50                   	push   %eax
  1016c6:	68 62 69 10 00       	push   $0x106962
  1016cb:	e8 d8 ec ff ff       	call   1003a8 <kprintf>
  1016d0:	83 c4 10             	add    $0x10,%esp
  1016d3:	eb 1f                	jmp    1016f4 <kbd_handler+0x137>
		} else {
			kprintf("%c", kbd_map[scancode]);
  1016d5:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
  1016d9:	0f b6 80 40 62 10 00 	movzbl 0x106240(%eax),%eax
  1016e0:	0f b6 c0             	movzbl %al,%eax
  1016e3:	83 ec 08             	sub    $0x8,%esp
  1016e6:	50                   	push   %eax
  1016e7:	68 62 69 10 00       	push   $0x106962
  1016ec:	e8 b7 ec ff ff       	call   1003a8 <kprintf>
  1016f1:	83 c4 10             	add    $0x10,%esp
		}
	}
	return;
  1016f4:	90                   	nop
}
  1016f5:	c9                   	leave  
  1016f6:	c3                   	ret    

001016f7 <kbd_install>:

void kbd_install() {
  1016f7:	55                   	push   %ebp
  1016f8:	89 e5                	mov    %esp,%ebp
  1016fa:	83 ec 08             	sub    $0x8,%esp
	irq_install_handler(0x1, kbd_handler); // seteaza timerul pe intreruperea 0
  1016fd:	83 ec 08             	sub    $0x8,%esp
  101700:	68 bd 15 10 00       	push   $0x1015bd
  101705:	6a 01                	push   $0x1
  101707:	e8 27 fb ff ff       	call   101233 <irq_install_handler>
  10170c:	83 c4 10             	add    $0x10,%esp
	return;
  10170f:	90                   	nop
}
  101710:	c9                   	leave  
  101711:	c3                   	ret    

00101712 <serial_received>:
#include "serial.h"
#define PORT 0x3f8   /* COM1 */



int serial_received() {
  101712:	55                   	push   %ebp
  101713:	89 e5                	mov    %esp,%ebp
  101715:	83 ec 08             	sub    $0x8,%esp
	return inb(PORT + 5) & 1;
  101718:	83 ec 0c             	sub    $0xc,%esp
  10171b:	68 fd 03 00 00       	push   $0x3fd
  101720:	e8 06 e9 ff ff       	call   10002b <inb>
  101725:	83 c4 10             	add    $0x10,%esp
  101728:	0f b6 c0             	movzbl %al,%eax
  10172b:	83 e0 01             	and    $0x1,%eax
}
  10172e:	c9                   	leave  
  10172f:	c3                   	ret    

00101730 <serial_read>:

char serial_read() {
  101730:	55                   	push   %ebp
  101731:	89 e5                	mov    %esp,%ebp
  101733:	83 ec 08             	sub    $0x8,%esp
	while (serial_received() == 0);
  101736:	90                   	nop
  101737:	e8 d6 ff ff ff       	call   101712 <serial_received>
  10173c:	85 c0                	test   %eax,%eax
  10173e:	74 f7                	je     101737 <serial_read+0x7>
	return inb(PORT);
  101740:	83 ec 0c             	sub    $0xc,%esp
  101743:	68 f8 03 00 00       	push   $0x3f8
  101748:	e8 de e8 ff ff       	call   10002b <inb>
  10174d:	83 c4 10             	add    $0x10,%esp
}
  101750:	c9                   	leave  
  101751:	c3                   	ret    

00101752 <is_transmit_empty>:

int is_transmit_empty() {
  101752:	55                   	push   %ebp
  101753:	89 e5                	mov    %esp,%ebp
  101755:	83 ec 08             	sub    $0x8,%esp
	return inb(PORT + 5) & 0x20;
  101758:	83 ec 0c             	sub    $0xc,%esp
  10175b:	68 fd 03 00 00       	push   $0x3fd
  101760:	e8 c6 e8 ff ff       	call   10002b <inb>
  101765:	83 c4 10             	add    $0x10,%esp
  101768:	0f b6 c0             	movzbl %al,%eax
  10176b:	83 e0 20             	and    $0x20,%eax
}
  10176e:	c9                   	leave  
  10176f:	c3                   	ret    

00101770 <serial_putc>:

void serial_putc(char a) {
  101770:	55                   	push   %ebp
  101771:	89 e5                	mov    %esp,%ebp
  101773:	83 ec 18             	sub    $0x18,%esp
  101776:	8b 45 08             	mov    0x8(%ebp),%eax
  101779:	88 45 f4             	mov    %al,-0xc(%ebp)
	while (is_transmit_empty() == 0);
  10177c:	90                   	nop
  10177d:	e8 d0 ff ff ff       	call   101752 <is_transmit_empty>
  101782:	85 c0                	test   %eax,%eax
  101784:	74 f7                	je     10177d <serial_putc+0xd>
	outb(PORT,a);
  101786:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
  10178a:	0f b6 c0             	movzbl %al,%eax
  10178d:	83 ec 08             	sub    $0x8,%esp
  101790:	50                   	push   %eax
  101791:	68 f8 03 00 00       	push   $0x3f8
  101796:	e8 65 e8 ff ff       	call   100000 <outb>
  10179b:	83 c4 10             	add    $0x10,%esp
}
  10179e:	c9                   	leave  
  10179f:	c3                   	ret    

001017a0 <serial_write>:
void serial_write(char *buf) {
  1017a0:	55                   	push   %ebp
  1017a1:	89 e5                	mov    %esp,%ebp
  1017a3:	83 ec 08             	sub    $0x8,%esp
	for (;;) {
		if(*buf == 0) {
  1017a6:	8b 45 08             	mov    0x8(%ebp),%eax
  1017a9:	0f b6 00             	movzbl (%eax),%eax
  1017ac:	84 c0                	test   %al,%al
  1017ae:	75 02                	jne    1017b2 <serial_write+0x12>
			break;
  1017b0:	eb 1d                	jmp    1017cf <serial_write+0x2f>
		}
		serial_putc(*buf++);
  1017b2:	8b 45 08             	mov    0x8(%ebp),%eax
  1017b5:	8d 50 01             	lea    0x1(%eax),%edx
  1017b8:	89 55 08             	mov    %edx,0x8(%ebp)
  1017bb:	0f b6 00             	movzbl (%eax),%eax
  1017be:	0f be c0             	movsbl %al,%eax
  1017c1:	83 ec 0c             	sub    $0xc,%esp
  1017c4:	50                   	push   %eax
  1017c5:	e8 a6 ff ff ff       	call   101770 <serial_putc>
  1017ca:	83 c4 10             	add    $0x10,%esp
	}
  1017cd:	eb d7                	jmp    1017a6 <serial_write+0x6>
}
  1017cf:	c9                   	leave  
  1017d0:	c3                   	ret    

001017d1 <serial_debug>:

void serial_debug(char *fmt, ...) {
  1017d1:	55                   	push   %ebp
  1017d2:	89 e5                	mov    %esp,%ebp
  1017d4:	81 ec 18 04 00 00    	sub    $0x418,%esp
	char buf[1024];
	va_list args;
	va_start(args, fmt);
  1017da:	8d 45 0c             	lea    0xc(%ebp),%eax
  1017dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
	vsprintf(buf, fmt, args);
  1017e0:	8b 45 08             	mov    0x8(%ebp),%eax
  1017e3:	83 ec 04             	sub    $0x4,%esp
  1017e6:	ff 75 f4             	pushl  -0xc(%ebp)
  1017e9:	50                   	push   %eax
  1017ea:	8d 85 f4 fb ff ff    	lea    -0x40c(%ebp),%eax
  1017f0:	50                   	push   %eax
  1017f1:	e8 3a 2d 00 00       	call   104530 <vsprintf>
  1017f6:	83 c4 10             	add    $0x10,%esp
	va_end(args);
	serial_write(buf);
  1017f9:	83 ec 0c             	sub    $0xc,%esp
  1017fc:	8d 85 f4 fb ff ff    	lea    -0x40c(%ebp),%eax
  101802:	50                   	push   %eax
  101803:	e8 98 ff ff ff       	call   1017a0 <serial_write>
  101808:	83 c4 10             	add    $0x10,%esp
	return;
  10180b:	90                   	nop
}
  10180c:	c9                   	leave  
  10180d:	c3                   	ret    

0010180e <serial_init>:


void serial_init() {
  10180e:	55                   	push   %ebp
  10180f:	89 e5                	mov    %esp,%ebp
  101811:	83 ec 08             	sub    $0x8,%esp
	outb(PORT + 1, 0x00);    // Disable all interrupts
  101814:	83 ec 08             	sub    $0x8,%esp
  101817:	6a 00                	push   $0x0
  101819:	68 f9 03 00 00       	push   $0x3f9
  10181e:	e8 dd e7 ff ff       	call   100000 <outb>
  101823:	83 c4 10             	add    $0x10,%esp
	outb(PORT + 3, 0x80);    // Enable DLAB (set baud rate divisor)
  101826:	83 ec 08             	sub    $0x8,%esp
  101829:	68 80 00 00 00       	push   $0x80
  10182e:	68 fb 03 00 00       	push   $0x3fb
  101833:	e8 c8 e7 ff ff       	call   100000 <outb>
  101838:	83 c4 10             	add    $0x10,%esp
	outb(PORT + 0, 0x03);    // Set divisor to 3 (lo byte) 38400 baud
  10183b:	83 ec 08             	sub    $0x8,%esp
  10183e:	6a 03                	push   $0x3
  101840:	68 f8 03 00 00       	push   $0x3f8
  101845:	e8 b6 e7 ff ff       	call   100000 <outb>
  10184a:	83 c4 10             	add    $0x10,%esp
	outb(PORT + 1, 0x00);    //                  (hi byte)
  10184d:	83 ec 08             	sub    $0x8,%esp
  101850:	6a 00                	push   $0x0
  101852:	68 f9 03 00 00       	push   $0x3f9
  101857:	e8 a4 e7 ff ff       	call   100000 <outb>
  10185c:	83 c4 10             	add    $0x10,%esp
	outb(PORT + 3, 0x03);    // 8 bits, no parity, one stop bit
  10185f:	83 ec 08             	sub    $0x8,%esp
  101862:	6a 03                	push   $0x3
  101864:	68 fb 03 00 00       	push   $0x3fb
  101869:	e8 92 e7 ff ff       	call   100000 <outb>
  10186e:	83 c4 10             	add    $0x10,%esp
	outb(PORT + 2, 0xC7);    // Enable FIFO, clear them, with 14-byte threshold
  101871:	83 ec 08             	sub    $0x8,%esp
  101874:	68 c7 00 00 00       	push   $0xc7
  101879:	68 fa 03 00 00       	push   $0x3fa
  10187e:	e8 7d e7 ff ff       	call   100000 <outb>
  101883:	83 c4 10             	add    $0x10,%esp
	outb(PORT + 4, 0x0B);    // IRQs enabled, RTS/DSR set
  101886:	83 ec 08             	sub    $0x8,%esp
  101889:	6a 0b                	push   $0xb
  10188b:	68 fc 03 00 00       	push   $0x3fc
  101890:	e8 6b e7 ff ff       	call   100000 <outb>
  101895:	83 c4 10             	add    $0x10,%esp
}
  101898:	c9                   	leave  
  101899:	c3                   	ret    

0010189a <__delay>:
#include "delay.h"
#include "timer.h"

static unsigned long delay_cnt = 1;

static void __delay(unsigned long loops) {
  10189a:	55                   	push   %ebp
  10189b:	89 e5                	mov    %esp,%ebp
  10189d:	83 ec 10             	sub    $0x10,%esp
	unsigned long i;
	for(i=0; i<loops; i++);
  1018a0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1018a7:	eb 04                	jmp    1018ad <__delay+0x13>
  1018a9:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  1018ad:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1018b0:	3b 45 08             	cmp    0x8(%ebp),%eax
  1018b3:	72 f4                	jb     1018a9 <__delay+0xf>
}
  1018b5:	c9                   	leave  
  1018b6:	c3                   	ret    

001018b7 <delay>:

void delay(unsigned long miliseconds) {
  1018b7:	55                   	push   %ebp
  1018b8:	89 e5                	mov    %esp,%ebp
	__delay(miliseconds * delay_cnt);
  1018ba:	a1 40 63 10 00       	mov    0x106340,%eax
  1018bf:	0f af 45 08          	imul   0x8(%ebp),%eax
  1018c3:	50                   	push   %eax
  1018c4:	e8 d1 ff ff ff       	call   10189a <__delay>
  1018c9:	83 c4 04             	add    $0x4,%esp
}
  1018cc:	c9                   	leave  
  1018cd:	c3                   	ret    

001018ce <calibrate_delay_loop>:

unsigned long calibrate_delay_loop(void){
  1018ce:	55                   	push   %ebp
  1018cf:	89 e5                	mov    %esp,%ebp
  1018d1:	83 ec 10             	sub    $0x10,%esp
	unsigned long prev_tick;
	unsigned int diff;
	// 1 - brute aproximation -> how many delay loops until one tick pass
	do {
		delay_cnt *= 2;
  1018d4:	a1 40 63 10 00       	mov    0x106340,%eax
  1018d9:	01 c0                	add    %eax,%eax
  1018db:	a3 40 63 10 00       	mov    %eax,0x106340
		prev_tick = timer_ticks;
  1018e0:	a1 fc c0 10 00       	mov    0x10c0fc,%eax
  1018e5:	89 45 f8             	mov    %eax,-0x8(%ebp)
		while(prev_tick == timer_ticks);	// wait for the next tick
  1018e8:	90                   	nop
  1018e9:	a1 fc c0 10 00       	mov    0x10c0fc,%eax
  1018ee:	39 45 f8             	cmp    %eax,-0x8(%ebp)
  1018f1:	74 f6                	je     1018e9 <calibrate_delay_loop+0x1b>
		prev_tick = timer_ticks;
  1018f3:	a1 fc c0 10 00       	mov    0x10c0fc,%eax
  1018f8:	89 45 f8             	mov    %eax,-0x8(%ebp)
		__delay(delay_cnt);
  1018fb:	a1 40 63 10 00       	mov    0x106340,%eax
  101900:	50                   	push   %eax
  101901:	e8 94 ff ff ff       	call   10189a <__delay>
  101906:	83 c4 04             	add    $0x4,%esp
	}
	while (prev_tick == timer_ticks);
  101909:	a1 fc c0 10 00       	mov    0x10c0fc,%eax
  10190e:	39 45 f8             	cmp    %eax,-0x8(%ebp)
  101911:	74 c1                	je     1018d4 <calibrate_delay_loop+0x6>

	diff = delay_cnt;
  101913:	a1 40 63 10 00       	mov    0x106340,%eax
  101918:	89 45 fc             	mov    %eax,-0x4(%ebp)
	// 2 - fine aproximation by adding/deleting half of diff each loop
	do {
		diff /= 2;
  10191b:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10191e:	d1 e8                	shr    %eax
  101920:	89 45 fc             	mov    %eax,-0x4(%ebp)
		prev_tick = timer_ticks;
  101923:	a1 fc c0 10 00       	mov    0x10c0fc,%eax
  101928:	89 45 f8             	mov    %eax,-0x8(%ebp)
		while(prev_tick == timer_ticks);
  10192b:	90                   	nop
  10192c:	a1 fc c0 10 00       	mov    0x10c0fc,%eax
  101931:	39 45 f8             	cmp    %eax,-0x8(%ebp)
  101934:	74 f6                	je     10192c <calibrate_delay_loop+0x5e>
		prev_tick = timer_ticks;
  101936:	a1 fc c0 10 00       	mov    0x10c0fc,%eax
  10193b:	89 45 f8             	mov    %eax,-0x8(%ebp)
		__delay(delay_cnt);
  10193e:	a1 40 63 10 00       	mov    0x106340,%eax
  101943:	50                   	push   %eax
  101944:	e8 51 ff ff ff       	call   10189a <__delay>
  101949:	83 c4 04             	add    $0x4,%esp
		if(prev_tick == timer_ticks) {
  10194c:	a1 fc c0 10 00       	mov    0x10c0fc,%eax
  101951:	39 45 f8             	cmp    %eax,-0x8(%ebp)
  101954:	75 12                	jne    101968 <calibrate_delay_loop+0x9a>
			delay_cnt += diff;
  101956:	8b 15 40 63 10 00    	mov    0x106340,%edx
  10195c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10195f:	01 d0                	add    %edx,%eax
  101961:	a3 40 63 10 00       	mov    %eax,0x106340
  101966:	eb 0d                	jmp    101975 <calibrate_delay_loop+0xa7>
		} else {
			delay_cnt -= diff;
  101968:	a1 40 63 10 00       	mov    0x106340,%eax
  10196d:	2b 45 fc             	sub    -0x4(%ebp),%eax
  101970:	a3 40 63 10 00       	mov    %eax,0x106340
		}
	} while(diff >= MS_PER_TICK);
  101975:	83 7d fc 09          	cmpl   $0x9,-0x4(%ebp)
  101979:	77 a0                	ja     10191b <calibrate_delay_loop+0x4d>

	delay_cnt /= MS_PER_TICK; // 10 ms per tick;
  10197b:	a1 40 63 10 00       	mov    0x106340,%eax
  101980:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
  101985:	f7 e2                	mul    %edx
  101987:	89 d0                	mov    %edx,%eax
  101989:	c1 e8 03             	shr    $0x3,%eax
  10198c:	a3 40 63 10 00       	mov    %eax,0x106340

	return delay_cnt;
  101991:	a1 40 63 10 00       	mov    0x106340,%eax
}
  101996:	c9                   	leave  
  101997:	c3                   	ret    

00101998 <paging_on>:

extern void shutdown();
extern void halt();

bool paging_on()
{
  101998:	55                   	push   %ebp
  101999:	89 e5                	mov    %esp,%ebp
	return pg_on;
  10199b:	0f b6 05 90 b0 10 00 	movzbl 0x10b090,%eax
}
  1019a2:	5d                   	pop    %ebp
  1019a3:	c3                   	ret    

001019a4 <page_fault>:
int fault_counter = 0;
/**
 * Page fault isr
 */
int page_fault(struct iregs *r)
{
  1019a4:	55                   	push   %ebp
  1019a5:	89 e5                	mov    %esp,%ebp
  1019a7:	53                   	push   %ebx
  1019a8:	83 ec 14             	sub    $0x14,%esp
	unsigned int fault_addr;
	asm volatile("mov %%cr2, %0" : "=r" (fault_addr));
  1019ab:	0f 20 d0             	mov    %cr2,%eax
  1019ae:	89 45 f4             	mov    %eax,-0xc(%ebp)
	unsigned short int table_idx = fault_addr >> 22;
  1019b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1019b4:	c1 e8 16             	shr    $0x16,%eax
  1019b7:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
	unsigned short int page_idx = fault_addr >> 12 & 0x03FF;
  1019bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1019be:	c1 e8 0c             	shr    $0xc,%eax
  1019c1:	66 25 ff 03          	and    $0x3ff,%ax
  1019c5:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
	extern unsigned int get_esp();
	fault_counter++;
  1019c9:	a1 94 b0 10 00       	mov    0x10b094,%eax
  1019ce:	83 c0 01             	add    $0x1,%eax
  1019d1:	a3 94 b0 10 00       	mov    %eax,0x10b094
	if (fault_counter > 10) {
  1019d6:	a1 94 b0 10 00       	mov    0x10b094,%eax
  1019db:	83 f8 0a             	cmp    $0xa,%eax
  1019de:	7e 13                	jle    1019f3 <page_fault+0x4f>
		halt("Too many faults, addr: 0x%X\n", fault_addr);
  1019e0:	83 ec 08             	sub    $0x8,%esp
  1019e3:	ff 75 f4             	pushl  -0xc(%ebp)
  1019e6:	68 68 69 10 00       	push   $0x106968
  1019eb:	e8 eb ed ff ff       	call   1007db <halt>
  1019f0:	83 c4 10             	add    $0x10,%esp
	}
	kprintf("____\nFAULT: %s addr: %p, ", r->err_code & P_PRESENT ? "page violation" : "not present", fault_addr);
  1019f3:	8b 45 08             	mov    0x8(%ebp),%eax
  1019f6:	8b 40 34             	mov    0x34(%eax),%eax
  1019f9:	83 e0 01             	and    $0x1,%eax
  1019fc:	85 c0                	test   %eax,%eax
  1019fe:	74 07                	je     101a07 <page_fault+0x63>
  101a00:	b8 85 69 10 00       	mov    $0x106985,%eax
  101a05:	eb 05                	jmp    101a0c <page_fault+0x68>
  101a07:	b8 94 69 10 00       	mov    $0x106994,%eax
  101a0c:	83 ec 04             	sub    $0x4,%esp
  101a0f:	ff 75 f4             	pushl  -0xc(%ebp)
  101a12:	50                   	push   %eax
  101a13:	68 a0 69 10 00       	push   $0x1069a0
  101a18:	e8 8b e9 ff ff       	call   1003a8 <kprintf>
  101a1d:	83 c4 10             	add    $0x10,%esp
	kprintf("stack: 0x%X\n", get_esp());
  101a20:	e8 71 ed ff ff       	call   100796 <get_esp>
  101a25:	83 ec 08             	sub    $0x8,%esp
  101a28:	50                   	push   %eax
  101a29:	68 ba 69 10 00       	push   $0x1069ba
  101a2e:	e8 75 e9 ff ff       	call   1003a8 <kprintf>
  101a33:	83 c4 10             	add    $0x10,%esp

	kprintf("eip: 0x%p\n", r->eip);
  101a36:	8b 45 08             	mov    0x8(%ebp),%eax
  101a39:	8b 40 38             	mov    0x38(%eax),%eax
  101a3c:	83 ec 08             	sub    $0x8,%esp
  101a3f:	50                   	push   %eax
  101a40:	68 c7 69 10 00       	push   $0x1069c7
  101a45:	e8 5e e9 ff ff       	call   1003a8 <kprintf>
  101a4a:	83 c4 10             	add    $0x10,%esp
	kprintf("vaddr: %p, dir_idx: %i, table_idx: %i\n", table_idx*1024*PAGE_SIZE+page_idx*PAGE_SIZE, table_idx, page_idx);
  101a4d:	0f b7 55 f0          	movzwl -0x10(%ebp),%edx
  101a51:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
  101a55:	0f b7 4d f2          	movzwl -0xe(%ebp),%ecx
  101a59:	89 cb                	mov    %ecx,%ebx
  101a5b:	c1 e3 0a             	shl    $0xa,%ebx
  101a5e:	0f b7 4d f0          	movzwl -0x10(%ebp),%ecx
  101a62:	01 d9                	add    %ebx,%ecx
  101a64:	c1 e1 0c             	shl    $0xc,%ecx
  101a67:	52                   	push   %edx
  101a68:	50                   	push   %eax
  101a69:	51                   	push   %ecx
  101a6a:	68 d4 69 10 00       	push   $0x1069d4
  101a6f:	e8 34 e9 ff ff       	call   1003a8 <kprintf>
  101a74:	83 c4 10             	add    $0x10,%esp
	kprintf("%s, ", r->err_code & P_READ_WRITE ? "write" : "read", fault_addr);
  101a77:	8b 45 08             	mov    0x8(%ebp),%eax
  101a7a:	8b 40 34             	mov    0x34(%eax),%eax
  101a7d:	83 e0 02             	and    $0x2,%eax
  101a80:	85 c0                	test   %eax,%eax
  101a82:	74 07                	je     101a8b <page_fault+0xe7>
  101a84:	b8 fb 69 10 00       	mov    $0x1069fb,%eax
  101a89:	eb 05                	jmp    101a90 <page_fault+0xec>
  101a8b:	b8 01 6a 10 00       	mov    $0x106a01,%eax
  101a90:	83 ec 04             	sub    $0x4,%esp
  101a93:	ff 75 f4             	pushl  -0xc(%ebp)
  101a96:	50                   	push   %eax
  101a97:	68 06 6a 10 00       	push   $0x106a06
  101a9c:	e8 07 e9 ff ff       	call   1003a8 <kprintf>
  101aa1:	83 c4 10             	add    $0x10,%esp
	kprintf("%s\n", r->err_code & P_USER ? "user-mode" : "kernel", fault_addr);
  101aa4:	8b 45 08             	mov    0x8(%ebp),%eax
  101aa7:	8b 40 34             	mov    0x34(%eax),%eax
  101aaa:	83 e0 04             	and    $0x4,%eax
  101aad:	85 c0                	test   %eax,%eax
  101aaf:	74 07                	je     101ab8 <page_fault+0x114>
  101ab1:	b8 0b 6a 10 00       	mov    $0x106a0b,%eax
  101ab6:	eb 05                	jmp    101abd <page_fault+0x119>
  101ab8:	b8 15 6a 10 00       	mov    $0x106a15,%eax
  101abd:	83 ec 04             	sub    $0x4,%esp
  101ac0:	ff 75 f4             	pushl  -0xc(%ebp)
  101ac3:	50                   	push   %eax
  101ac4:	68 1c 6a 10 00       	push   $0x106a1c
  101ac9:	e8 da e8 ff ff       	call   1003a8 <kprintf>
  101ace:	83 c4 10             	add    $0x10,%esp
	kprintf("%s", is_mapped(fault_addr) ? "mapped" : "not mapped");
  101ad1:	83 ec 0c             	sub    $0xc,%esp
  101ad4:	ff 75 f4             	pushl  -0xc(%ebp)
  101ad7:	e8 e2 05 00 00       	call   1020be <is_mapped>
  101adc:	83 c4 10             	add    $0x10,%esp
  101adf:	84 c0                	test   %al,%al
  101ae1:	74 07                	je     101aea <page_fault+0x146>
  101ae3:	b8 20 6a 10 00       	mov    $0x106a20,%eax
  101ae8:	eb 05                	jmp    101aef <page_fault+0x14b>
  101aea:	b8 27 6a 10 00       	mov    $0x106a27,%eax
  101aef:	83 ec 08             	sub    $0x8,%esp
  101af2:	50                   	push   %eax
  101af3:	68 32 6a 10 00       	push   $0x106a32
  101af8:	e8 ab e8 ff ff       	call   1003a8 <kprintf>
  101afd:	83 c4 10             	add    $0x10,%esp
	if (HEAP_START < fault_addr && fault_addr < HEAP_END) {
  101b00:	81 7d f4 00 00 00 d0 	cmpl   $0xd0000000,-0xc(%ebp)
  101b07:	76 2f                	jbe    101b38 <page_fault+0x194>
  101b09:	81 7d f4 ff ff ff df 	cmpl   $0xdfffffff,-0xc(%ebp)
  101b10:	77 26                	ja     101b38 <page_fault+0x194>
		kprintf(", in heap\n");
  101b12:	83 ec 0c             	sub    $0xc,%esp
  101b15:	68 35 6a 10 00       	push   $0x106a35
  101b1a:	e8 89 e8 ff ff       	call   1003a8 <kprintf>
  101b1f:	83 c4 10             	add    $0x10,%esp
		heap_dump();
  101b22:	e8 4f 0f 00 00       	call   102a76 <heap_dump>
		debug_dump_list(first_block);
  101b27:	a1 00 c1 10 00       	mov    0x10c100,%eax
  101b2c:	83 ec 0c             	sub    $0xc,%esp
  101b2f:	50                   	push   %eax
  101b30:	e8 13 0e 00 00       	call   102948 <debug_dump_list>
  101b35:	83 c4 10             	add    $0x10,%esp
	}
	kprintf("\n%s", paging_on() ? "paging ON" : "paging OFF");
  101b38:	e8 5b fe ff ff       	call   101998 <paging_on>
  101b3d:	84 c0                	test   %al,%al
  101b3f:	74 07                	je     101b48 <page_fault+0x1a4>
  101b41:	b8 40 6a 10 00       	mov    $0x106a40,%eax
  101b46:	eb 05                	jmp    101b4d <page_fault+0x1a9>
  101b48:	b8 4a 6a 10 00       	mov    $0x106a4a,%eax
  101b4d:	83 ec 08             	sub    $0x8,%esp
  101b50:	50                   	push   %eax
  101b51:	68 55 6a 10 00       	push   $0x106a55
  101b56:	e8 4d e8 ff ff       	call   1003a8 <kprintf>
  101b5b:	83 c4 10             	add    $0x10,%esp
	//	panic("\npanic\n____");
	//shutdown();
	return false;
  101b5e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  101b63:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  101b66:	c9                   	leave  
  101b67:	c3                   	ret    

00101b68 <frame_alloc>:
//	ptr->next pointer to next free page
//	page 4096-4
//  .........
//
phys_t *frame_alloc()
{
  101b68:	55                   	push   %ebp
  101b69:	89 e5                	mov    %esp,%ebp
  101b6b:	83 ec 18             	sub    $0x18,%esp
	phys_t *addr;
	KASSERT(last_free_page != 0);
  101b6e:	a1 8c b0 10 00       	mov    0x10b08c,%eax
  101b73:	85 c0                	test   %eax,%eax
  101b75:	75 26                	jne    101b9d <frame_alloc+0x35>
  101b77:	83 ec 0c             	sub    $0xc,%esp
  101b7a:	6a 45                	push   $0x45
  101b7c:	68 59 6a 10 00       	push   $0x106a59
  101b81:	68 a4 6b 10 00       	push   $0x106ba4
  101b86:	68 5f 6a 10 00       	push   $0x106a5f
  101b8b:	68 74 6a 10 00       	push   $0x106a74
  101b90:	e8 13 e8 ff ff       	call   1003a8 <kprintf>
  101b95:	83 c4 20             	add    $0x20,%esp
  101b98:	e8 3e ec ff ff       	call   1007db <halt>
	addr = (phys_t *)last_free_page;
  101b9d:	a1 8c b0 10 00       	mov    0x10b08c,%eax
  101ba2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(paging_on()) {
  101ba5:	e8 ee fd ff ff       	call   101998 <paging_on>
  101baa:	84 c0                	test   %al,%al
  101bac:	74 3f                	je     101bed <frame_alloc+0x85>
		map(RESV_PAGE, (phys_t)addr, P_PRESENT|P_READ_WRITE);
  101bae:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101bb1:	83 ec 04             	sub    $0x4,%esp
  101bb4:	6a 03                	push   $0x3
  101bb6:	50                   	push   %eax
  101bb7:	68 00 e0 bf ff       	push   $0xffbfe000
  101bbc:	e8 55 06 00 00       	call   102216 <map>
  101bc1:	83 c4 10             	add    $0x10,%esp
		last_free_page = *((phys_t *)RESV_PAGE);
  101bc4:	b8 00 e0 bf ff       	mov    $0xffbfe000,%eax
  101bc9:	8b 00                	mov    (%eax),%eax
  101bcb:	a3 8c b0 10 00       	mov    %eax,0x10b08c
		*((phys_t *)RESV_PAGE) = 0;
  101bd0:	b8 00 e0 bf ff       	mov    $0xffbfe000,%eax
  101bd5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		unmap(RESV_PAGE);
  101bdb:	83 ec 0c             	sub    $0xc,%esp
  101bde:	68 00 e0 bf ff       	push   $0xffbfe000
  101be3:	e8 14 06 00 00       	call   1021fc <unmap>
  101be8:	83 c4 10             	add    $0x10,%esp
  101beb:	eb 13                	jmp    101c00 <frame_alloc+0x98>
	} else {
		last_free_page = *addr;
  101bed:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101bf0:	8b 00                	mov    (%eax),%eax
  101bf2:	a3 8c b0 10 00       	mov    %eax,0x10b08c
		*addr = 0; // unlink next //
  101bf7:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101bfa:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	}
	num_pages--;
  101c00:	a1 00 c0 10 00       	mov    0x10c000,%eax
  101c05:	83 e8 01             	sub    $0x1,%eax
  101c08:	a3 00 c0 10 00       	mov    %eax,0x10c000
	return addr;
  101c0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
  101c10:	c9                   	leave  
  101c11:	c3                   	ret    

00101c12 <frame_calloc>:

// allocs and bzero PAGE_SIZE frame //
phys_t *frame_calloc()
{
  101c12:	55                   	push   %ebp
  101c13:	89 e5                	mov    %esp,%ebp
  101c15:	83 ec 18             	sub    $0x18,%esp
	phys_t *addr;
	addr = frame_alloc();
  101c18:	e8 4b ff ff ff       	call   101b68 <frame_alloc>
  101c1d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(paging_on()) {
  101c20:	e8 73 fd ff ff       	call   101998 <paging_on>
  101c25:	84 c0                	test   %al,%al
  101c27:	74 3f                	je     101c68 <frame_calloc+0x56>
		map(RESV_PAGE, (phys_t)addr, P_PRESENT|P_READ_WRITE);
  101c29:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101c2c:	83 ec 04             	sub    $0x4,%esp
  101c2f:	6a 03                	push   $0x3
  101c31:	50                   	push   %eax
  101c32:	68 00 e0 bf ff       	push   $0xffbfe000
  101c37:	e8 da 05 00 00       	call   102216 <map>
  101c3c:	83 c4 10             	add    $0x10,%esp
		memset((void *)RESV_PAGE, 0, PAGE_SIZE);
  101c3f:	83 ec 04             	sub    $0x4,%esp
  101c42:	68 00 10 00 00       	push   $0x1000
  101c47:	6a 00                	push   $0x0
  101c49:	68 00 e0 bf ff       	push   $0xffbfe000
  101c4e:	e8 3d 26 00 00       	call   104290 <memset>
  101c53:	83 c4 10             	add    $0x10,%esp
		unmap(RESV_PAGE);
  101c56:	83 ec 0c             	sub    $0xc,%esp
  101c59:	68 00 e0 bf ff       	push   $0xffbfe000
  101c5e:	e8 99 05 00 00       	call   1021fc <unmap>
  101c63:	83 c4 10             	add    $0x10,%esp
  101c66:	eb 15                	jmp    101c7d <frame_calloc+0x6b>
	} else {
		memset(addr, 0, PAGE_SIZE);
  101c68:	83 ec 04             	sub    $0x4,%esp
  101c6b:	68 00 10 00 00       	push   $0x1000
  101c70:	6a 00                	push   $0x0
  101c72:	ff 75 f4             	pushl  -0xc(%ebp)
  101c75:	e8 16 26 00 00       	call   104290 <memset>
  101c7a:	83 c4 10             	add    $0x10,%esp
	}
	return addr;
  101c7d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
  101c80:	c9                   	leave  
  101c81:	c3                   	ret    

00101c82 <frame_free>:

void frame_free(phys_t addr)
{
  101c82:	55                   	push   %ebp
  101c83:	89 e5                	mov    %esp,%ebp
  101c85:	83 ec 08             	sub    $0x8,%esp
	KASSERT(!(addr & 0xFFF));
  101c88:	8b 45 08             	mov    0x8(%ebp),%eax
  101c8b:	25 ff 0f 00 00       	and    $0xfff,%eax
  101c90:	85 c0                	test   %eax,%eax
  101c92:	74 26                	je     101cba <frame_free+0x38>
  101c94:	83 ec 0c             	sub    $0xc,%esp
  101c97:	6a 65                	push   $0x65
  101c99:	68 59 6a 10 00       	push   $0x106a59
  101c9e:	68 b0 6b 10 00       	push   $0x106bb0
  101ca3:	68 a4 6a 10 00       	push   $0x106aa4
  101ca8:	68 74 6a 10 00       	push   $0x106a74
  101cad:	e8 f6 e6 ff ff       	call   1003a8 <kprintf>
  101cb2:	83 c4 20             	add    $0x20,%esp
  101cb5:	e8 21 eb ff ff       	call   1007db <halt>
	if(paging_on()){
  101cba:	e8 d9 fc ff ff       	call   101998 <paging_on>
  101cbf:	84 c0                	test   %al,%al
  101cc1:	74 33                	je     101cf6 <frame_free+0x74>
		map(RESV_PAGE, (phys_t)addr, P_PRESENT|P_READ_WRITE);
  101cc3:	83 ec 04             	sub    $0x4,%esp
  101cc6:	6a 03                	push   $0x3
  101cc8:	ff 75 08             	pushl  0x8(%ebp)
  101ccb:	68 00 e0 bf ff       	push   $0xffbfe000
  101cd0:	e8 41 05 00 00       	call   102216 <map>
  101cd5:	83 c4 10             	add    $0x10,%esp
		*((phys_t *)RESV_PAGE) = last_free_page;
  101cd8:	ba 00 e0 bf ff       	mov    $0xffbfe000,%edx
  101cdd:	a1 8c b0 10 00       	mov    0x10b08c,%eax
  101ce2:	89 02                	mov    %eax,(%edx)
		unmap(RESV_PAGE);
  101ce4:	83 ec 0c             	sub    $0xc,%esp
  101ce7:	68 00 e0 bf ff       	push   $0xffbfe000
  101cec:	e8 0b 05 00 00       	call   1021fc <unmap>
  101cf1:	83 c4 10             	add    $0x10,%esp
  101cf4:	eb 0b                	jmp    101d01 <frame_free+0x7f>
	} else {
		*((phys_t *)addr) = last_free_page;
  101cf6:	8b 45 08             	mov    0x8(%ebp),%eax
  101cf9:	8b 15 8c b0 10 00    	mov    0x10b08c,%edx
  101cff:	89 10                	mov    %edx,(%eax)
	}
	last_free_page = addr;
  101d01:	8b 45 08             	mov    0x8(%ebp),%eax
  101d04:	a3 8c b0 10 00       	mov    %eax,0x10b08c
	num_pages++;
  101d09:	a1 00 c0 10 00       	mov    0x10c000,%eax
  101d0e:	83 c0 01             	add    $0x1,%eax
  101d11:	a3 00 c0 10 00       	mov    %eax,0x10c000
}
  101d16:	c9                   	leave  
  101d17:	c3                   	ret    

00101d18 <round_page_up>:

static phys_t round_page_up(phys_t addr) {
  101d18:	55                   	push   %ebp
  101d19:	89 e5                	mov    %esp,%ebp
	return ((addr/PAGE_SIZE)+1) * PAGE_SIZE;
  101d1b:	8b 45 08             	mov    0x8(%ebp),%eax
  101d1e:	c1 e8 0c             	shr    $0xc,%eax
  101d21:	83 c0 01             	add    $0x1,%eax
  101d24:	c1 e0 0c             	shl    $0xc,%eax
}
  101d27:	5d                   	pop    %ebp
  101d28:	c3                   	ret    

00101d29 <reserve_region>:


static void reserve_region(phys_t addr, size_t length, multiboot_header *mb)
{
  101d29:	55                   	push   %ebp
  101d2a:	89 e5                	mov    %esp,%ebp
  101d2c:	83 ec 38             	sub    $0x38,%esp
	struct	kinfo_t kinfo;
	phys_t	ptr;
	phys_t	initrd_location = 0,
  101d2f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			initrd_end = 0;
  101d36:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

	if (mb && mb->mods_count > 0) {
  101d3d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  101d41:	74 31                	je     101d74 <reserve_region+0x4b>
  101d43:	8b 45 10             	mov    0x10(%ebp),%eax
  101d46:	8b 40 14             	mov    0x14(%eax),%eax
  101d49:	85 c0                	test   %eax,%eax
  101d4b:	74 27                	je     101d74 <reserve_region+0x4b>
		initrd_location = *((unsigned int *) mb->mods_addr);
  101d4d:	8b 45 10             	mov    0x10(%ebp),%eax
  101d50:	8b 40 18             	mov    0x18(%eax),%eax
  101d53:	8b 00                	mov    (%eax),%eax
  101d55:	89 45 f0             	mov    %eax,-0x10(%ebp)
		initrd_end = *(unsigned int *) (mb->mods_addr + 4);
  101d58:	8b 45 10             	mov    0x10(%ebp),%eax
  101d5b:	8b 40 18             	mov    0x18(%eax),%eax
  101d5e:	83 c0 04             	add    $0x4,%eax
  101d61:	8b 00                	mov    (%eax),%eax
  101d63:	89 45 ec             	mov    %eax,-0x14(%ebp)
		initrd_end = round_page_up(initrd_end);
  101d66:	ff 75 ec             	pushl  -0x14(%ebp)
  101d69:	e8 aa ff ff ff       	call   101d18 <round_page_up>
  101d6e:	83 c4 04             	add    $0x4,%esp
  101d71:	89 45 ec             	mov    %eax,-0x14(%ebp)
	}

	get_kernel_info(&kinfo);
  101d74:	83 ec 0c             	sub    $0xc,%esp
  101d77:	8d 45 cc             	lea    -0x34(%ebp),%eax
  101d7a:	50                   	push   %eax
  101d7b:	e8 23 ea ff ff       	call   1007a3 <get_kernel_info>
  101d80:	83 c4 10             	add    $0x10,%esp

	for(ptr = addr; ptr - addr < length; ptr+=PAGE_SIZE) {
  101d83:	8b 45 08             	mov    0x8(%ebp),%eax
  101d86:	89 45 f4             	mov    %eax,-0xc(%ebp)
  101d89:	eb 51                	jmp    101ddc <reserve_region+0xb3>
		// we will not use first frame //
		if(ptr == 0) {
  101d8b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  101d8f:	75 0b                	jne    101d9c <reserve_region+0x73>
			*((phys_t *) addr) = 0;
  101d91:	8b 45 08             	mov    0x8(%ebp),%eax
  101d94:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			continue;
  101d9a:	eb 39                	jmp    101dd5 <reserve_region+0xac>
		}
		// skip frames from vga start addr to end of the kernel //
		if(ptr >= VGA_FB_ADDR && ptr <= kinfo.end) {
  101d9c:	81 7d f4 ff 7f 0b 00 	cmpl   $0xb7fff,-0xc(%ebp)
  101da3:	76 0a                	jbe    101daf <reserve_region+0x86>
  101da5:	8b 45 dc             	mov    -0x24(%ebp),%eax
  101da8:	3b 45 f4             	cmp    -0xc(%ebp),%eax
  101dab:	72 02                	jb     101daf <reserve_region+0x86>
			continue;
  101dad:	eb 26                	jmp    101dd5 <reserve_region+0xac>
		}
		// skip frames that belongs to initrd section //
		if(initrd_location) {
  101daf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  101db3:	74 12                	je     101dc7 <reserve_region+0x9e>
			if(ptr >= initrd_location && ptr <= initrd_end) {
  101db5:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101db8:	3b 45 f0             	cmp    -0x10(%ebp),%eax
  101dbb:	72 0a                	jb     101dc7 <reserve_region+0x9e>
  101dbd:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101dc0:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  101dc3:	77 02                	ja     101dc7 <reserve_region+0x9e>
				continue;
  101dc5:	eb 0e                	jmp    101dd5 <reserve_region+0xac>
			}
		}

		frame_free(ptr);
  101dc7:	83 ec 0c             	sub    $0xc,%esp
  101dca:	ff 75 f4             	pushl  -0xc(%ebp)
  101dcd:	e8 b0 fe ff ff       	call   101c82 <frame_free>
  101dd2:	83 c4 10             	add    $0x10,%esp
		initrd_end = round_page_up(initrd_end);
	}

	get_kernel_info(&kinfo);

	for(ptr = addr; ptr - addr < length; ptr+=PAGE_SIZE) {
  101dd5:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
  101ddc:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101ddf:	2b 45 08             	sub    0x8(%ebp),%eax
  101de2:	3b 45 0c             	cmp    0xc(%ebp),%eax
  101de5:	72 a4                	jb     101d8b <reserve_region+0x62>
			}
		}

		frame_free(ptr);
	}
}
  101de7:	c9                   	leave  
  101de8:	c3                   	ret    

00101de9 <reserve_memory>:


static void reserve_memory(multiboot_header *mb)
{
  101de9:	55                   	push   %ebp
  101dea:	89 e5                	mov    %esp,%ebp
  101dec:	83 ec 18             	sub    $0x18,%esp
	memory_map *mm;
	mm = (memory_map *) mb->mmap_addr;
  101def:	8b 45 08             	mov    0x8(%ebp),%eax
  101df2:	8b 40 30             	mov    0x30(%eax),%eax
  101df5:	89 45 f4             	mov    %eax,-0xc(%ebp)
	do {
		if(mm->type == 1) {
  101df8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101dfb:	8b 40 14             	mov    0x14(%eax),%eax
  101dfe:	83 f8 01             	cmp    $0x1,%eax
  101e01:	75 40                	jne    101e43 <reserve_memory+0x5a>
			phys_t addr;
			size_t length;
			addr = (mm->base_addr_high << 16) + mm->base_addr_low;
  101e03:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101e06:	8b 40 08             	mov    0x8(%eax),%eax
  101e09:	c1 e0 10             	shl    $0x10,%eax
  101e0c:	89 c2                	mov    %eax,%edx
  101e0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101e11:	8b 40 04             	mov    0x4(%eax),%eax
  101e14:	01 d0                	add    %edx,%eax
  101e16:	89 45 f0             	mov    %eax,-0x10(%ebp)
			length = (mm->length_high << 16) + mm->length_low;
  101e19:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101e1c:	8b 40 10             	mov    0x10(%eax),%eax
  101e1f:	c1 e0 10             	shl    $0x10,%eax
  101e22:	89 c2                	mov    %eax,%edx
  101e24:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101e27:	8b 40 0c             	mov    0xc(%eax),%eax
  101e2a:	01 d0                	add    %edx,%eax
  101e2c:	89 45 ec             	mov    %eax,-0x14(%ebp)
			reserve_region(addr, length, mb);
  101e2f:	83 ec 04             	sub    $0x4,%esp
  101e32:	ff 75 08             	pushl  0x8(%ebp)
  101e35:	ff 75 ec             	pushl  -0x14(%ebp)
  101e38:	ff 75 f0             	pushl  -0x10(%ebp)
  101e3b:	e8 e9 fe ff ff       	call   101d29 <reserve_region>
  101e40:	83 c4 10             	add    $0x10,%esp
		}
		mm = (memory_map *) ((unsigned long) mm + mm->size + sizeof(mm->size));
  101e43:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101e46:	8b 10                	mov    (%eax),%edx
  101e48:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101e4b:	01 d0                	add    %edx,%eax
  101e4d:	83 c0 04             	add    $0x4,%eax
  101e50:	89 45 f4             	mov    %eax,-0xc(%ebp)
	} while((unsigned long) mm < mb->mmap_addr + mb->mmap_length);
  101e53:	8b 55 f4             	mov    -0xc(%ebp),%edx
  101e56:	8b 45 08             	mov    0x8(%ebp),%eax
  101e59:	8b 48 30             	mov    0x30(%eax),%ecx
  101e5c:	8b 45 08             	mov    0x8(%ebp),%eax
  101e5f:	8b 40 2c             	mov    0x2c(%eax),%eax
  101e62:	01 c8                	add    %ecx,%eax
  101e64:	39 c2                	cmp    %eax,%edx
  101e66:	72 90                	jb     101df8 <reserve_memory+0xf>
}
  101e68:	c9                   	leave  
  101e69:	c3                   	ret    

00101e6a <recursively_map_page_directory>:

static void recursively_map_page_directory(dir_t *dir)
{
  101e6a:	55                   	push   %ebp
  101e6b:	89 e5                	mov    %esp,%ebp
  101e6d:	83 ec 08             	sub    $0x8,%esp
	if(paging_on()){
  101e70:	e8 23 fb ff ff       	call   101998 <paging_on>
  101e75:	84 c0                	test   %al,%al
  101e77:	74 35                	je     101eae <recursively_map_page_directory+0x44>
		map(RESV_PAGE, (phys_t) dir, P_PRESENT | P_READ_WRITE);
  101e79:	8b 45 08             	mov    0x8(%ebp),%eax
  101e7c:	83 ec 04             	sub    $0x4,%esp
  101e7f:	6a 03                	push   $0x3
  101e81:	50                   	push   %eax
  101e82:	68 00 e0 bf ff       	push   $0xffbfe000
  101e87:	e8 8a 03 00 00       	call   102216 <map>
  101e8c:	83 c4 10             	add    $0x10,%esp
		((virt_t *) RESV_PAGE)[1023] = (phys_t)dir | P_PRESENT | P_READ_WRITE;
  101e8f:	ba fc ef bf ff       	mov    $0xffbfeffc,%edx
  101e94:	8b 45 08             	mov    0x8(%ebp),%eax
  101e97:	83 c8 03             	or     $0x3,%eax
  101e9a:	89 02                	mov    %eax,(%edx)
		unmap(RESV_PAGE);
  101e9c:	83 ec 0c             	sub    $0xc,%esp
  101e9f:	68 00 e0 bf ff       	push   $0xffbfe000
  101ea4:	e8 53 03 00 00       	call   1021fc <unmap>
  101ea9:	83 c4 10             	add    $0x10,%esp
  101eac:	eb 10                	jmp    101ebe <recursively_map_page_directory+0x54>
	} else {
		dir[1023] = (phys_t) dir | P_PRESENT | P_READ_WRITE;
  101eae:	8b 45 08             	mov    0x8(%ebp),%eax
  101eb1:	05 fc 0f 00 00       	add    $0xffc,%eax
  101eb6:	8b 55 08             	mov    0x8(%ebp),%edx
  101eb9:	83 ca 03             	or     $0x3,%edx
  101ebc:	89 10                	mov    %edx,(%eax)
	}
}
  101ebe:	c9                   	leave  
  101ebf:	c3                   	ret    

00101ec0 <identity_map_page>:

// identity maps a PAGE_SIZE page located at addr
static void identity_map_page(dir_t *dir, phys_t addr)
{
  101ec0:	55                   	push   %ebp
  101ec1:	89 e5                	mov    %esp,%ebp
  101ec3:	53                   	push   %ebx
  101ec4:	83 ec 14             	sub    $0x14,%esp
	phys_t *table;
	int dir_idx, tbl_idx;
	dir_idx = (addr / PAGE_SIZE) / 1024;
  101ec7:	8b 45 0c             	mov    0xc(%ebp),%eax
  101eca:	c1 e8 16             	shr    $0x16,%eax
  101ecd:	89 45 f4             	mov    %eax,-0xc(%ebp)
	tbl_idx = (addr / PAGE_SIZE) % 1024;
  101ed0:	8b 45 0c             	mov    0xc(%ebp),%eax
  101ed3:	c1 e8 0c             	shr    $0xc,%eax
  101ed6:	25 ff 03 00 00       	and    $0x3ff,%eax
  101edb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if(!(dir[dir_idx] & P_PRESENT)) {
  101ede:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101ee1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  101ee8:	8b 45 08             	mov    0x8(%ebp),%eax
  101eeb:	01 d0                	add    %edx,%eax
  101eed:	8b 00                	mov    (%eax),%eax
  101eef:	83 e0 01             	and    $0x1,%eax
  101ef2:	85 c0                	test   %eax,%eax
  101ef4:	75 1a                	jne    101f10 <identity_map_page+0x50>
		dir[dir_idx] = (uint32_t) frame_calloc() | P_PRESENT | P_READ_WRITE;
  101ef6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101ef9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  101f00:	8b 45 08             	mov    0x8(%ebp),%eax
  101f03:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
  101f06:	e8 07 fd ff ff       	call   101c12 <frame_calloc>
  101f0b:	83 c8 03             	or     $0x3,%eax
  101f0e:	89 03                	mov    %eax,(%ebx)
	}
	table = (phys_t *)(dir[dir_idx] & 0xFFFFF000);
  101f10:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101f13:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  101f1a:	8b 45 08             	mov    0x8(%ebp),%eax
  101f1d:	01 d0                	add    %edx,%eax
  101f1f:	8b 00                	mov    (%eax),%eax
  101f21:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  101f26:	89 45 ec             	mov    %eax,-0x14(%ebp)
	table[tbl_idx] = addr | P_PRESENT | P_READ_WRITE;
  101f29:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101f2c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  101f33:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101f36:	01 d0                	add    %edx,%eax
  101f38:	8b 55 0c             	mov    0xc(%ebp),%edx
  101f3b:	83 ca 03             	or     $0x3,%edx
  101f3e:	89 10                	mov    %edx,(%eax)
}
  101f40:	83 c4 14             	add    $0x14,%esp
  101f43:	5b                   	pop    %ebx
  101f44:	5d                   	pop    %ebp
  101f45:	c3                   	ret    

00101f46 <identity_map_kernel>:

static void identity_map_kernel(dir_t *dir, multiboot_header *mb)
{
  101f46:	55                   	push   %ebp
  101f47:	89 e5                	mov    %esp,%ebp
  101f49:	53                   	push   %ebx
  101f4a:	83 ec 14             	sub    $0x14,%esp
	phys_t addr;

	// identity maps pages from VGA addr to kernel end //
	for(addr = VGA_FB_ADDR; addr <= kinfo.end; addr += PAGE_SIZE) {
  101f4d:	c7 45 f4 00 80 0b 00 	movl   $0xb8000,-0xc(%ebp)
  101f54:	eb 18                	jmp    101f6e <identity_map_kernel+0x28>
		identity_map_page(dir, addr);
  101f56:	83 ec 08             	sub    $0x8,%esp
  101f59:	ff 75 f4             	pushl  -0xc(%ebp)
  101f5c:	ff 75 08             	pushl  0x8(%ebp)
  101f5f:	e8 5c ff ff ff       	call   101ec0 <identity_map_page>
  101f64:	83 c4 10             	add    $0x10,%esp
static void identity_map_kernel(dir_t *dir, multiboot_header *mb)
{
	phys_t addr;

	// identity maps pages from VGA addr to kernel end //
	for(addr = VGA_FB_ADDR; addr <= kinfo.end; addr += PAGE_SIZE) {
  101f67:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
  101f6e:	a1 30 c0 10 00       	mov    0x10c030,%eax
  101f73:	3b 45 f4             	cmp    -0xc(%ebp),%eax
  101f76:	73 de                	jae    101f56 <identity_map_kernel+0x10>
		identity_map_page(dir, addr);
	}

	// identity maps from initrd_location to initrd_end -> used by initrd, later
	// maibe we will move it up into the memory and not ident,
	if (mb->mods_count > 0) {
  101f78:	8b 45 0c             	mov    0xc(%ebp),%eax
  101f7b:	8b 40 14             	mov    0x14(%eax),%eax
  101f7e:	85 c0                	test   %eax,%eax
  101f80:	74 60                	je     101fe2 <identity_map_kernel+0x9c>
		phys_t	initrd_location = 0, initrd_end = 0;
  101f82:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  101f89:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		initrd_location = *((unsigned int *) mb->mods_addr);
  101f90:	8b 45 0c             	mov    0xc(%ebp),%eax
  101f93:	8b 40 18             	mov    0x18(%eax),%eax
  101f96:	8b 00                	mov    (%eax),%eax
  101f98:	89 45 f0             	mov    %eax,-0x10(%ebp)
		initrd_end = *(unsigned int *) (mb->mods_addr + 4);
  101f9b:	8b 45 0c             	mov    0xc(%ebp),%eax
  101f9e:	8b 40 18             	mov    0x18(%eax),%eax
  101fa1:	83 c0 04             	add    $0x4,%eax
  101fa4:	8b 00                	mov    (%eax),%eax
  101fa6:	89 45 ec             	mov    %eax,-0x14(%ebp)
		initrd_end = round_page_up(initrd_end);
  101fa9:	83 ec 0c             	sub    $0xc,%esp
  101fac:	ff 75 ec             	pushl  -0x14(%ebp)
  101faf:	e8 64 fd ff ff       	call   101d18 <round_page_up>
  101fb4:	83 c4 10             	add    $0x10,%esp
  101fb7:	89 45 ec             	mov    %eax,-0x14(%ebp)
		for(addr = initrd_location; addr <= initrd_end; addr += PAGE_SIZE) {
  101fba:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101fbd:	89 45 f4             	mov    %eax,-0xc(%ebp)
  101fc0:	eb 18                	jmp    101fda <identity_map_kernel+0x94>
			identity_map_page(dir, addr);
  101fc2:	83 ec 08             	sub    $0x8,%esp
  101fc5:	ff 75 f4             	pushl  -0xc(%ebp)
  101fc8:	ff 75 08             	pushl  0x8(%ebp)
  101fcb:	e8 f0 fe ff ff       	call   101ec0 <identity_map_page>
  101fd0:	83 c4 10             	add    $0x10,%esp
	if (mb->mods_count > 0) {
		phys_t	initrd_location = 0, initrd_end = 0;
		initrd_location = *((unsigned int *) mb->mods_addr);
		initrd_end = *(unsigned int *) (mb->mods_addr + 4);
		initrd_end = round_page_up(initrd_end);
		for(addr = initrd_location; addr <= initrd_end; addr += PAGE_SIZE) {
  101fd3:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
  101fda:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101fdd:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  101fe0:	76 e0                	jbe    101fc2 <identity_map_kernel+0x7c>
		}
	}

	// create table for reserved_page //
	int dir_idx;
	dir_idx = (RESV_PAGE/PAGE_SIZE) / 1024;
  101fe2:	c7 45 e8 fe 03 00 00 	movl   $0x3fe,-0x18(%ebp)
	dir[dir_idx] = (uint32_t)frame_calloc() | P_PRESENT | P_READ_WRITE;
  101fe9:	8b 45 e8             	mov    -0x18(%ebp),%eax
  101fec:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  101ff3:	8b 45 08             	mov    0x8(%ebp),%eax
  101ff6:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
  101ff9:	e8 14 fc ff ff       	call   101c12 <frame_calloc>
  101ffe:	83 c8 03             	or     $0x3,%eax
  102001:	89 03                	mov    %eax,(%ebx)
}
  102003:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  102006:	c9                   	leave  
  102007:	c3                   	ret    

00102008 <dump_dir>:


void dump_dir()
{
  102008:	55                   	push   %ebp
  102009:	89 e5                	mov    %esp,%ebp
  10200b:	83 ec 18             	sub    $0x18,%esp
	int dir_idx, tbl_idx;
	dir_t *dir = (dir_t *)PDIR_ADDR;
  10200e:	c7 45 ec 00 f0 ff ff 	movl   $0xfffff000,-0x14(%ebp)
	virt_t *table;
	for(dir_idx = 0; dir_idx < 1024; dir_idx++)
  102015:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  10201c:	e9 8e 00 00 00       	jmp    1020af <dump_dir+0xa7>
	{
		if(dir[dir_idx] & P_PRESENT) {
  102021:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102024:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  10202b:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10202e:	01 d0                	add    %edx,%eax
  102030:	8b 00                	mov    (%eax),%eax
  102032:	83 e0 01             	and    $0x1,%eax
  102035:	85 c0                	test   %eax,%eax
  102037:	74 72                	je     1020ab <dump_dir+0xa3>
			kprintf("Dir: %d\n", dir_idx);
  102039:	83 ec 08             	sub    $0x8,%esp
  10203c:	ff 75 f4             	pushl  -0xc(%ebp)
  10203f:	68 b4 6a 10 00       	push   $0x106ab4
  102044:	e8 5f e3 ff ff       	call   1003a8 <kprintf>
  102049:	83 c4 10             	add    $0x10,%esp
			for(tbl_idx=0; tbl_idx < 1024; tbl_idx++) {
  10204c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  102053:	eb 3d                	jmp    102092 <dump_dir+0x8a>
				table = (uint32_t *) (PTABLES_ADDR + dir_idx * PAGE_SIZE);
  102055:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102058:	c1 e0 0c             	shl    $0xc,%eax
  10205b:	2d 00 00 40 00       	sub    $0x400000,%eax
  102060:	89 45 e8             	mov    %eax,-0x18(%ebp)
				if(table[tbl_idx] & P_PRESENT) {
  102063:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102066:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  10206d:	8b 45 e8             	mov    -0x18(%ebp),%eax
  102070:	01 d0                	add    %edx,%eax
  102072:	8b 00                	mov    (%eax),%eax
  102074:	83 e0 01             	and    $0x1,%eax
  102077:	85 c0                	test   %eax,%eax
  102079:	74 13                	je     10208e <dump_dir+0x86>
					kprintf("%d ",tbl_idx);
  10207b:	83 ec 08             	sub    $0x8,%esp
  10207e:	ff 75 f0             	pushl  -0x10(%ebp)
  102081:	68 bd 6a 10 00       	push   $0x106abd
  102086:	e8 1d e3 ff ff       	call   1003a8 <kprintf>
  10208b:	83 c4 10             	add    $0x10,%esp
	virt_t *table;
	for(dir_idx = 0; dir_idx < 1024; dir_idx++)
	{
		if(dir[dir_idx] & P_PRESENT) {
			kprintf("Dir: %d\n", dir_idx);
			for(tbl_idx=0; tbl_idx < 1024; tbl_idx++) {
  10208e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
  102092:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
  102099:	7e ba                	jle    102055 <dump_dir+0x4d>
				table = (uint32_t *) (PTABLES_ADDR + dir_idx * PAGE_SIZE);
				if(table[tbl_idx] & P_PRESENT) {
					kprintf("%d ",tbl_idx);
				}
			}
			kprintf("\n");
  10209b:	83 ec 0c             	sub    $0xc,%esp
  10209e:	68 c1 6a 10 00       	push   $0x106ac1
  1020a3:	e8 00 e3 ff ff       	call   1003a8 <kprintf>
  1020a8:	83 c4 10             	add    $0x10,%esp
void dump_dir()
{
	int dir_idx, tbl_idx;
	dir_t *dir = (dir_t *)PDIR_ADDR;
	virt_t *table;
	for(dir_idx = 0; dir_idx < 1024; dir_idx++)
  1020ab:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
  1020af:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
  1020b6:	0f 8e 65 ff ff ff    	jle    102021 <dump_dir+0x19>
				}
			}
			kprintf("\n");
		}
	}
}
  1020bc:	c9                   	leave  
  1020bd:	c3                   	ret    

001020be <is_mapped>:

bool is_mapped(virt_t addr)
{
  1020be:	55                   	push   %ebp
  1020bf:	89 e5                	mov    %esp,%ebp
  1020c1:	83 ec 18             	sub    $0x18,%esp
	dir_t *dir = (dir_t *) PDIR_ADDR;
  1020c4:	c7 45 f4 00 f0 ff ff 	movl   $0xfffff000,-0xc(%ebp)
	virt_t *table;
	if(addr & 0xFFF) {
  1020cb:	8b 45 08             	mov    0x8(%ebp),%eax
  1020ce:	25 ff 0f 00 00       	and    $0xfff,%eax
  1020d3:	85 c0                	test   %eax,%eax
  1020d5:	74 13                	je     1020ea <is_mapped+0x2c>
		kprintf("is_mapped(): Not aligned: %p\n", addr);
  1020d7:	83 ec 08             	sub    $0x8,%esp
  1020da:	ff 75 08             	pushl  0x8(%ebp)
  1020dd:	68 c3 6a 10 00       	push   $0x106ac3
  1020e2:	e8 c1 e2 ff ff       	call   1003a8 <kprintf>
  1020e7:	83 c4 10             	add    $0x10,%esp
	}
	int dir_idx = (addr / PAGE_SIZE) / 1024;
  1020ea:	8b 45 08             	mov    0x8(%ebp),%eax
  1020ed:	c1 e8 16             	shr    $0x16,%eax
  1020f0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int tbl_idx = (addr / PAGE_SIZE) % 1024;
  1020f3:	8b 45 08             	mov    0x8(%ebp),%eax
  1020f6:	c1 e8 0c             	shr    $0xc,%eax
  1020f9:	25 ff 03 00 00       	and    $0x3ff,%eax
  1020fe:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(!(dir[dir_idx] & P_PRESENT)) {
  102101:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102104:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  10210b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10210e:	01 d0                	add    %edx,%eax
  102110:	8b 00                	mov    (%eax),%eax
  102112:	83 e0 01             	and    $0x1,%eax
  102115:	85 c0                	test   %eax,%eax
  102117:	75 07                	jne    102120 <is_mapped+0x62>
		return false;
  102119:	b8 00 00 00 00       	mov    $0x0,%eax
  10211e:	eb 32                	jmp    102152 <is_mapped+0x94>
	}
	table = (virt_t *) (PTABLES_ADDR + dir_idx * PAGE_SIZE);
  102120:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102123:	c1 e0 0c             	shl    $0xc,%eax
  102126:	2d 00 00 40 00       	sub    $0x400000,%eax
  10212b:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if(!(table[tbl_idx] & P_PRESENT)) {
  10212e:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102131:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  102138:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10213b:	01 d0                	add    %edx,%eax
  10213d:	8b 00                	mov    (%eax),%eax
  10213f:	83 e0 01             	and    $0x1,%eax
  102142:	85 c0                	test   %eax,%eax
  102144:	75 07                	jne    10214d <is_mapped+0x8f>
		return false;
  102146:	b8 00 00 00 00       	mov    $0x0,%eax
  10214b:	eb 05                	jmp    102152 <is_mapped+0x94>
	}
	return true;
  10214d:	b8 01 00 00 00       	mov    $0x1,%eax
}
  102152:	c9                   	leave  
  102153:	c3                   	ret    

00102154 <virt_to_phys>:

phys_t virt_to_phys(virt_t addr)
{
  102154:	55                   	push   %ebp
  102155:	89 e5                	mov    %esp,%ebp
  102157:	83 ec 18             	sub    $0x18,%esp
	virt_t *table;
	int dir_idx = (addr / PAGE_SIZE) / 1024;
  10215a:	8b 45 08             	mov    0x8(%ebp),%eax
  10215d:	c1 e8 16             	shr    $0x16,%eax
  102160:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int tbl_idx = (addr / PAGE_SIZE) % 1024;
  102163:	8b 45 08             	mov    0x8(%ebp),%eax
  102166:	c1 e8 0c             	shr    $0xc,%eax
  102169:	25 ff 03 00 00       	and    $0x3ff,%eax
  10216e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	KASSERT(!(addr & 0xFFF));
  102171:	8b 45 08             	mov    0x8(%ebp),%eax
  102174:	25 ff 0f 00 00       	and    $0xfff,%eax
  102179:	85 c0                	test   %eax,%eax
  10217b:	74 29                	je     1021a6 <virt_to_phys+0x52>
  10217d:	83 ec 0c             	sub    $0xc,%esp
  102180:	68 0c 01 00 00       	push   $0x10c
  102185:	68 59 6a 10 00       	push   $0x106a59
  10218a:	68 bb 6b 10 00       	push   $0x106bbb
  10218f:	68 a4 6a 10 00       	push   $0x106aa4
  102194:	68 74 6a 10 00       	push   $0x106a74
  102199:	e8 0a e2 ff ff       	call   1003a8 <kprintf>
  10219e:	83 c4 20             	add    $0x20,%esp
  1021a1:	e8 35 e6 ff ff       	call   1007db <halt>
	if(! is_mapped(addr)) {
  1021a6:	83 ec 0c             	sub    $0xc,%esp
  1021a9:	ff 75 08             	pushl  0x8(%ebp)
  1021ac:	e8 0d ff ff ff       	call   1020be <is_mapped>
  1021b1:	83 c4 10             	add    $0x10,%esp
  1021b4:	84 c0                	test   %al,%al
  1021b6:	75 13                	jne    1021cb <virt_to_phys+0x77>
		panic("%p is not mapped\n", addr);
  1021b8:	83 ec 08             	sub    $0x8,%esp
  1021bb:	ff 75 08             	pushl  0x8(%ebp)
  1021be:	68 e1 6a 10 00       	push   $0x106ae1
  1021c3:	e8 7c e2 ff ff       	call   100444 <panic>
  1021c8:	83 c4 10             	add    $0x10,%esp
	}
	table = (virt_t *) (PTABLES_ADDR + dir_idx * PAGE_SIZE);
  1021cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1021ce:	c1 e0 0c             	shl    $0xc,%eax
  1021d1:	2d 00 00 40 00       	sub    $0x400000,%eax
  1021d6:	89 45 ec             	mov    %eax,-0x14(%ebp)
	return table[tbl_idx] & 0xFFFFF000;
  1021d9:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1021dc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  1021e3:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1021e6:	01 d0                	add    %edx,%eax
  1021e8:	8b 00                	mov    (%eax),%eax
  1021ea:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
  1021ef:	c9                   	leave  
  1021f0:	c3                   	ret    

001021f1 <invlpg>:

static void invlpg(virt_t addr)
{
  1021f1:	55                   	push   %ebp
  1021f2:	89 e5                	mov    %esp,%ebp
	asm volatile("invlpg (%0)"::"r" (addr) : "memory");
  1021f4:	8b 45 08             	mov    0x8(%ebp),%eax
  1021f7:	0f 01 38             	invlpg (%eax)
}
  1021fa:	5d                   	pop    %ebp
  1021fb:	c3                   	ret    

001021fc <unmap>:

// todo more testing //
void unmap(virt_t virtual_addr)
{
  1021fc:	55                   	push   %ebp
  1021fd:	89 e5                	mov    %esp,%ebp
  1021ff:	83 ec 08             	sub    $0x8,%esp
	map(virtual_addr, 0, 0);
  102202:	83 ec 04             	sub    $0x4,%esp
  102205:	6a 00                	push   $0x0
  102207:	6a 00                	push   $0x0
  102209:	ff 75 08             	pushl  0x8(%ebp)
  10220c:	e8 05 00 00 00       	call   102216 <map>
  102211:	83 c4 10             	add    $0x10,%esp
}
  102214:	c9                   	leave  
  102215:	c3                   	ret    

00102216 <map>:

void map(virt_t virtual_addr, phys_t physical_addr, flags_t flags)
{
  102216:	55                   	push   %ebp
  102217:	89 e5                	mov    %esp,%ebp
  102219:	53                   	push   %ebx
  10221a:	83 ec 24             	sub    $0x24,%esp
  10221d:	8b 45 10             	mov    0x10(%ebp),%eax
  102220:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
	dir_t *dir = (dir_t *) PDIR_ADDR;
  102224:	c7 45 f4 00 f0 ff ff 	movl   $0xfffff000,-0xc(%ebp)
	virt_t *table;
	int dir_idx = (virtual_addr / PAGE_SIZE) / 1024;
  10222b:	8b 45 08             	mov    0x8(%ebp),%eax
  10222e:	c1 e8 16             	shr    $0x16,%eax
  102231:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int tbl_idx = (virtual_addr / PAGE_SIZE) % 1024;
  102234:	8b 45 08             	mov    0x8(%ebp),%eax
  102237:	c1 e8 0c             	shr    $0xc,%eax
  10223a:	25 ff 03 00 00       	and    $0x3ff,%eax
  10223f:	89 45 ec             	mov    %eax,-0x14(%ebp)

	table = (virt_t *)(PTABLES_ADDR + dir_idx * PAGE_SIZE);
  102242:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102245:	c1 e0 0c             	shl    $0xc,%eax
  102248:	2d 00 00 40 00       	sub    $0x400000,%eax
  10224d:	89 45 e8             	mov    %eax,-0x18(%ebp)

	if(! dir[dir_idx] & P_PRESENT) {
  102250:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102253:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  10225a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10225d:	01 d0                	add    %edx,%eax
  10225f:	8b 00                	mov    (%eax),%eax
  102261:	85 c0                	test   %eax,%eax
  102263:	75 43                	jne    1022a8 <map+0x92>
		dir[dir_idx] = (phys_t) frame_alloc() | flags;
  102265:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102268:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  10226f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102272:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
  102275:	e8 ee f8 ff ff       	call   101b68 <frame_alloc>
  10227a:	89 c2                	mov    %eax,%edx
  10227c:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  102280:	09 d0                	or     %edx,%eax
  102282:	89 03                	mov    %eax,(%ebx)
		invlpg((virt_t) table);
  102284:	8b 45 e8             	mov    -0x18(%ebp),%eax
  102287:	83 ec 0c             	sub    $0xc,%esp
  10228a:	50                   	push   %eax
  10228b:	e8 61 ff ff ff       	call   1021f1 <invlpg>
  102290:	83 c4 10             	add    $0x10,%esp
		memset(table, 0, PAGE_SIZE);
  102293:	83 ec 04             	sub    $0x4,%esp
  102296:	68 00 10 00 00       	push   $0x1000
  10229b:	6a 00                	push   $0x0
  10229d:	ff 75 e8             	pushl  -0x18(%ebp)
  1022a0:	e8 eb 1f 00 00       	call   104290 <memset>
  1022a5:	83 c4 10             	add    $0x10,%esp
	}
	table[tbl_idx] = physical_addr | flags;
  1022a8:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1022ab:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  1022b2:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1022b5:	01 c2                	add    %eax,%edx
  1022b7:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  1022bb:	0b 45 0c             	or     0xc(%ebp),%eax
  1022be:	89 02                	mov    %eax,(%edx)
	invlpg(virtual_addr);
  1022c0:	83 ec 0c             	sub    $0xc,%esp
  1022c3:	ff 75 08             	pushl  0x8(%ebp)
  1022c6:	e8 26 ff ff ff       	call   1021f1 <invlpg>
  1022cb:	83 c4 10             	add    $0x10,%esp
}
  1022ce:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1022d1:	c9                   	leave  
  1022d2:	c3                   	ret    

001022d3 <setup_heap>:

static void setup_heap()
{
  1022d3:	55                   	push   %ebp
  1022d4:	89 e5                	mov    %esp,%ebp
  1022d6:	83 ec 18             	sub    $0x18,%esp
	heap->start_addr = HEAP_START;
  1022d9:	a1 44 63 10 00       	mov    0x106344,%eax
  1022de:	c7 00 00 00 00 d0    	movl   $0xd0000000,(%eax)
	heap->end_addr = HEAP_START + HEAP_INITIAL_SIZE;
  1022e4:	a1 44 63 10 00       	mov    0x106344,%eax
  1022e9:	c7 40 04 00 00 01 d0 	movl   $0xd0010000,0x4(%eax)
	heap->max_addr = HEAP_END;
  1022f0:	a1 44 63 10 00       	mov    0x106344,%eax
  1022f5:	c7 40 08 00 00 00 e0 	movl   $0xe0000000,0x8(%eax)
	heap->readonly = false;
  1022fc:	a1 44 63 10 00       	mov    0x106344,%eax
  102301:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
	heap->supervisor = true;
  102305:	a1 44 63 10 00       	mov    0x106344,%eax
  10230a:	c6 40 0c 01          	movb   $0x1,0xc(%eax)
	virt_t p;
	for(p = heap->start_addr; p < heap->end_addr; p += PAGE_SIZE) {
  10230e:	a1 44 63 10 00       	mov    0x106344,%eax
  102313:	8b 00                	mov    (%eax),%eax
  102315:	89 45 f4             	mov    %eax,-0xc(%ebp)
  102318:	eb 1d                	jmp    102337 <setup_heap+0x64>
		map(p, (phys_t) frame_alloc(), P_PRESENT | P_READ_WRITE);
  10231a:	e8 49 f8 ff ff       	call   101b68 <frame_alloc>
  10231f:	83 ec 04             	sub    $0x4,%esp
  102322:	6a 03                	push   $0x3
  102324:	50                   	push   %eax
  102325:	ff 75 f4             	pushl  -0xc(%ebp)
  102328:	e8 e9 fe ff ff       	call   102216 <map>
  10232d:	83 c4 10             	add    $0x10,%esp
	heap->end_addr = HEAP_START + HEAP_INITIAL_SIZE;
	heap->max_addr = HEAP_END;
	heap->readonly = false;
	heap->supervisor = true;
	virt_t p;
	for(p = heap->start_addr; p < heap->end_addr; p += PAGE_SIZE) {
  102330:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
  102337:	a1 44 63 10 00       	mov    0x106344,%eax
  10233c:	8b 40 04             	mov    0x4(%eax),%eax
  10233f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
  102342:	77 d6                	ja     10231a <setup_heap+0x47>
		map(p, (phys_t) frame_alloc(), P_PRESENT | P_READ_WRITE);
	}
}
  102344:	c9                   	leave  
  102345:	c3                   	ret    

00102346 <sbrk>:

void *sbrk(unsigned int increment) {
  102346:	55                   	push   %ebp
  102347:	89 e5                	mov    %esp,%ebp
  102349:	83 ec 18             	sub    $0x18,%esp
	unsigned int start = heap->end_addr;
  10234c:	a1 44 63 10 00       	mov    0x106344,%eax
  102351:	8b 40 04             	mov    0x4(%eax),%eax
  102354:	89 45 ec             	mov    %eax,-0x14(%ebp)
	unsigned int frame, i;
	unsigned int iterations;
	KASSERT(heap);
  102357:	a1 44 63 10 00       	mov    0x106344,%eax
  10235c:	85 c0                	test   %eax,%eax
  10235e:	75 29                	jne    102389 <sbrk+0x43>
  102360:	83 ec 0c             	sub    $0xc,%esp
  102363:	68 42 01 00 00       	push   $0x142
  102368:	68 59 6a 10 00       	push   $0x106a59
  10236d:	68 c8 6b 10 00       	push   $0x106bc8
  102372:	68 f3 6a 10 00       	push   $0x106af3
  102377:	68 74 6a 10 00       	push   $0x106a74
  10237c:	e8 27 e0 ff ff       	call   1003a8 <kprintf>
  102381:	83 c4 20             	add    $0x20,%esp
  102384:	e8 52 e4 ff ff       	call   1007db <halt>
	KASSERT(!(increment & 0xFFF));
  102389:	8b 45 08             	mov    0x8(%ebp),%eax
  10238c:	25 ff 0f 00 00       	and    $0xfff,%eax
  102391:	85 c0                	test   %eax,%eax
  102393:	74 29                	je     1023be <sbrk+0x78>
  102395:	83 ec 0c             	sub    $0xc,%esp
  102398:	68 43 01 00 00       	push   $0x143
  10239d:	68 59 6a 10 00       	push   $0x106a59
  1023a2:	68 c8 6b 10 00       	push   $0x106bc8
  1023a7:	68 f8 6a 10 00       	push   $0x106af8
  1023ac:	68 74 6a 10 00       	push   $0x106a74
  1023b1:	e8 f2 df ff ff       	call   1003a8 <kprintf>
  1023b6:	83 c4 20             	add    $0x20,%esp
  1023b9:	e8 1d e4 ff ff       	call   1007db <halt>
	if(increment == 0) {
  1023be:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  1023c2:	75 0d                	jne    1023d1 <sbrk+0x8b>
		return (void *)heap->end_addr;
  1023c4:	a1 44 63 10 00       	mov    0x106344,%eax
  1023c9:	8b 40 04             	mov    0x4(%eax),%eax
  1023cc:	e9 19 01 00 00       	jmp    1024ea <sbrk+0x1a4>
	}
	iterations = increment / PAGE_SIZE;
  1023d1:	8b 45 08             	mov    0x8(%ebp),%eax
  1023d4:	c1 e8 0c             	shr    $0xc,%eax
  1023d7:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (iterations < 1) {
  1023da:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  1023de:	75 04                	jne    1023e4 <sbrk+0x9e>
		iterations++;
  1023e0:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
	}
	for (i = 0; i < iterations; ++i) {
  1023e4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  1023eb:	e9 eb 00 00 00       	jmp    1024db <sbrk+0x195>
		frame = (phys_t) frame_alloc();
  1023f0:	e8 73 f7 ff ff       	call   101b68 <frame_alloc>
  1023f5:	89 45 e8             	mov    %eax,-0x18(%ebp)
		KASSERT(!(heap->end_addr & 0xFFF));
  1023f8:	a1 44 63 10 00       	mov    0x106344,%eax
  1023fd:	8b 40 04             	mov    0x4(%eax),%eax
  102400:	25 ff 0f 00 00       	and    $0xfff,%eax
  102405:	85 c0                	test   %eax,%eax
  102407:	74 29                	je     102432 <sbrk+0xec>
  102409:	83 ec 0c             	sub    $0xc,%esp
  10240c:	68 4d 01 00 00       	push   $0x14d
  102411:	68 59 6a 10 00       	push   $0x106a59
  102416:	68 c8 6b 10 00       	push   $0x106bc8
  10241b:	68 0d 6b 10 00       	push   $0x106b0d
  102420:	68 74 6a 10 00       	push   $0x106a74
  102425:	e8 7e df ff ff       	call   1003a8 <kprintf>
  10242a:	83 c4 20             	add    $0x20,%esp
  10242d:	e8 a9 e3 ff ff       	call   1007db <halt>
		KASSERT(frame);
  102432:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
  102436:	75 29                	jne    102461 <sbrk+0x11b>
  102438:	83 ec 0c             	sub    $0xc,%esp
  10243b:	68 4e 01 00 00       	push   $0x14e
  102440:	68 59 6a 10 00       	push   $0x106a59
  102445:	68 c8 6b 10 00       	push   $0x106bc8
  10244a:	68 27 6b 10 00       	push   $0x106b27
  10244f:	68 74 6a 10 00       	push   $0x106a74
  102454:	e8 4f df ff ff       	call   1003a8 <kprintf>
  102459:	83 c4 20             	add    $0x20,%esp
  10245c:	e8 7a e3 ff ff       	call   1007db <halt>
		map(heap->end_addr, frame, P_PRESENT);
  102461:	a1 44 63 10 00       	mov    0x106344,%eax
  102466:	8b 40 04             	mov    0x4(%eax),%eax
  102469:	83 ec 04             	sub    $0x4,%esp
  10246c:	6a 01                	push   $0x1
  10246e:	ff 75 e8             	pushl  -0x18(%ebp)
  102471:	50                   	push   %eax
  102472:	e8 9f fd ff ff       	call   102216 <map>
  102477:	83 c4 10             	add    $0x10,%esp
		heap->end_addr += PAGE_SIZE;
  10247a:	a1 44 63 10 00       	mov    0x106344,%eax
  10247f:	8b 15 44 63 10 00    	mov    0x106344,%edx
  102485:	8b 52 04             	mov    0x4(%edx),%edx
  102488:	81 c2 00 10 00 00    	add    $0x1000,%edx
  10248e:	89 50 04             	mov    %edx,0x4(%eax)
		if (heap->end_addr >= heap->max_addr) {
  102491:	a1 44 63 10 00       	mov    0x106344,%eax
  102496:	8b 50 04             	mov    0x4(%eax),%edx
  102499:	a1 44 63 10 00       	mov    0x106344,%eax
  10249e:	8b 40 08             	mov    0x8(%eax),%eax
  1024a1:	39 c2                	cmp    %eax,%edx
  1024a3:	72 32                	jb     1024d7 <sbrk+0x191>
			panic("Out of memory in sbrk: heap end addr: 0x%X08, size: %iM\n", heap->end_addr,
					(heap->end_addr - heap->start_addr) / 1024 / 1024);
  1024a5:	a1 44 63 10 00       	mov    0x106344,%eax
  1024aa:	8b 50 04             	mov    0x4(%eax),%edx
  1024ad:	a1 44 63 10 00       	mov    0x106344,%eax
  1024b2:	8b 00                	mov    (%eax),%eax
  1024b4:	29 c2                	sub    %eax,%edx
  1024b6:	89 d0                	mov    %edx,%eax
		KASSERT(!(heap->end_addr & 0xFFF));
		KASSERT(frame);
		map(heap->end_addr, frame, P_PRESENT);
		heap->end_addr += PAGE_SIZE;
		if (heap->end_addr >= heap->max_addr) {
			panic("Out of memory in sbrk: heap end addr: 0x%X08, size: %iM\n", heap->end_addr,
  1024b8:	c1 e8 14             	shr    $0x14,%eax
  1024bb:	89 c2                	mov    %eax,%edx
  1024bd:	a1 44 63 10 00       	mov    0x106344,%eax
  1024c2:	8b 40 04             	mov    0x4(%eax),%eax
  1024c5:	83 ec 04             	sub    $0x4,%esp
  1024c8:	52                   	push   %edx
  1024c9:	50                   	push   %eax
  1024ca:	68 30 6b 10 00       	push   $0x106b30
  1024cf:	e8 70 df ff ff       	call   100444 <panic>
  1024d4:	83 c4 10             	add    $0x10,%esp
	}
	iterations = increment / PAGE_SIZE;
	if (iterations < 1) {
		iterations++;
	}
	for (i = 0; i < iterations; ++i) {
  1024d7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
  1024db:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1024de:	3b 45 f0             	cmp    -0x10(%ebp),%eax
  1024e1:	0f 82 09 ff ff ff    	jb     1023f0 <sbrk+0xaa>
		if (heap->end_addr >= heap->max_addr) {
			panic("Out of memory in sbrk: heap end addr: 0x%X08, size: %iM\n", heap->end_addr,
					(heap->end_addr - heap->start_addr) / 1024 / 1024);
		}
	}
	return (void *) start;
  1024e7:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
  1024ea:	c9                   	leave  
  1024eb:	c3                   	ret    

001024ec <temp_map>:

// temporary maps a physical frame to a known virtual address so we can change it
// when paging is on
virt_t *temp_map(phys_t *page)
{
  1024ec:	55                   	push   %ebp
  1024ed:	89 e5                	mov    %esp,%ebp
  1024ef:	83 ec 08             	sub    $0x8,%esp
	map(RESV_PAGE, (phys_t)page, P_PRESENT|P_READ_WRITE);
  1024f2:	8b 45 08             	mov    0x8(%ebp),%eax
  1024f5:	83 ec 04             	sub    $0x4,%esp
  1024f8:	6a 03                	push   $0x3
  1024fa:	50                   	push   %eax
  1024fb:	68 00 e0 bf ff       	push   $0xffbfe000
  102500:	e8 11 fd ff ff       	call   102216 <map>
  102505:	83 c4 10             	add    $0x10,%esp
	return (virt_t *)RESV_PAGE;
  102508:	b8 00 e0 bf ff       	mov    $0xffbfe000,%eax
}
  10250d:	c9                   	leave  
  10250e:	c3                   	ret    

0010250f <temp_unmap>:

// unmaps known virtual addr //
void temp_unmap()
{
  10250f:	55                   	push   %ebp
  102510:	89 e5                	mov    %esp,%ebp
  102512:	83 ec 08             	sub    $0x8,%esp
	unmap(RESV_PAGE);
  102515:	83 ec 0c             	sub    $0xc,%esp
  102518:	68 00 e0 bf ff       	push   $0xffbfe000
  10251d:	e8 da fc ff ff       	call   1021fc <unmap>
  102522:	83 c4 10             	add    $0x10,%esp
}
  102525:	c9                   	leave  
  102526:	c3                   	ret    

00102527 <clone_directory>:

// clone current address space //
dir_t *clone_directory()
{
  102527:	55                   	push   %ebp
  102528:	89 e5                	mov    %esp,%ebp
  10252a:	83 ec 38             	sub    $0x38,%esp
	static int iter = 0;
	unsigned int dir_idx, tbl_idx;
	dir_t *curr_dir = (dir_t *)PDIR_ADDR;
  10252d:	c7 45 ec 00 f0 ff ff 	movl   $0xfffff000,-0x14(%ebp)
	dir_t *new_dir = (dir_t *)frame_calloc();
  102534:	e8 d9 f6 ff ff       	call   101c12 <frame_calloc>
  102539:	89 45 e8             	mov    %eax,-0x18(%ebp)
	virt_t *table, *addr;
	phys_t *frame;
	virt_t *from_addr;
	// extern unsigned int stack_size;

	cli();
  10253c:	fa                   	cli    
	for(dir_idx = 0; dir_idx < 1023; dir_idx++) {
  10253d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  102544:	e9 9b 01 00 00       	jmp    1026e4 <clone_directory+0x1bd>
		if(curr_dir[dir_idx] & P_PRESENT) {
  102549:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10254c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  102553:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102556:	01 d0                	add    %edx,%eax
  102558:	8b 00                	mov    (%eax),%eax
  10255a:	83 e0 01             	and    $0x1,%eax
  10255d:	85 c0                	test   %eax,%eax
  10255f:	0f 84 7b 01 00 00    	je     1026e0 <clone_directory+0x1b9>
			// link the pages - from 0 to user stack low, and the kernel heap
			if((dir_idx < ((USER_STACK_LOW)/1024/PAGE_SIZE)) || (dir_idx >= (HEAP_START/1024/PAGE_SIZE) && dir_idx < (HEAP_END/1024/PAGE_SIZE))) {
  102565:	83 7d f4 3e          	cmpl   $0x3e,-0xc(%ebp)
  102569:	76 12                	jbe    10257d <clone_directory+0x56>
  10256b:	81 7d f4 3f 03 00 00 	cmpl   $0x33f,-0xc(%ebp)
  102572:	76 46                	jbe    1025ba <clone_directory+0x93>
  102574:	81 7d f4 7f 03 00 00 	cmpl   $0x37f,-0xc(%ebp)
  10257b:	77 3d                	ja     1025ba <clone_directory+0x93>
				addr = temp_map(new_dir);
  10257d:	83 ec 0c             	sub    $0xc,%esp
  102580:	ff 75 e8             	pushl  -0x18(%ebp)
  102583:	e8 64 ff ff ff       	call   1024ec <temp_map>
  102588:	83 c4 10             	add    $0x10,%esp
  10258b:	89 45 dc             	mov    %eax,-0x24(%ebp)
				addr[dir_idx] = curr_dir[dir_idx];
  10258e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102591:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  102598:	8b 45 dc             	mov    -0x24(%ebp),%eax
  10259b:	01 c2                	add    %eax,%edx
  10259d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1025a0:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
  1025a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1025aa:	01 c8                	add    %ecx,%eax
  1025ac:	8b 00                	mov    (%eax),%eax
  1025ae:	89 02                	mov    %eax,(%edx)
				temp_unmap();
  1025b0:	e8 5a ff ff ff       	call   10250f <temp_unmap>
  1025b5:	e9 26 01 00 00       	jmp    1026e0 <clone_directory+0x1b9>
				// kprintf("Link dir: %p\n", (dir_idx * 1024 * PAGE_SIZE));
			}
			// we clone the rest -> to do, P_USER only on USER stack, USER prog,
			else {
				int dir_flags = curr_dir[dir_idx] & 0xFFF;
  1025ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1025bd:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  1025c4:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1025c7:	01 d0                	add    %edx,%eax
  1025c9:	8b 00                	mov    (%eax),%eax
  1025cb:	25 ff 0f 00 00       	and    $0xfff,%eax
  1025d0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				new_table = frame_calloc();
  1025d3:	e8 3a f6 ff ff       	call   101c12 <frame_calloc>
  1025d8:	89 45 e0             	mov    %eax,-0x20(%ebp)
				addr = temp_map(new_dir);
  1025db:	83 ec 0c             	sub    $0xc,%esp
  1025de:	ff 75 e8             	pushl  -0x18(%ebp)
  1025e1:	e8 06 ff ff ff       	call   1024ec <temp_map>
  1025e6:	83 c4 10             	add    $0x10,%esp
  1025e9:	89 45 dc             	mov    %eax,-0x24(%ebp)
				addr[dir_idx] = (phys_t)new_table | dir_flags;
  1025ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1025ef:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  1025f6:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1025f9:	01 d0                	add    %edx,%eax
  1025fb:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  1025fe:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  102601:	09 ca                	or     %ecx,%edx
  102603:	89 10                	mov    %edx,(%eax)
				temp_unmap();
  102605:	e8 05 ff ff ff       	call   10250f <temp_unmap>

				table = (virt_t *) (PTABLES_ADDR + dir_idx * PAGE_SIZE);
  10260a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10260d:	05 00 fc 0f 00       	add    $0xffc00,%eax
  102612:	c1 e0 0c             	shl    $0xc,%eax
  102615:	89 45 d8             	mov    %eax,-0x28(%ebp)
				for(tbl_idx = 0; tbl_idx < 1024; tbl_idx++) {
  102618:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  10261f:	e9 af 00 00 00       	jmp    1026d3 <clone_directory+0x1ac>
					if(table[tbl_idx] & P_PRESENT) {
  102624:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102627:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  10262e:	8b 45 d8             	mov    -0x28(%ebp),%eax
  102631:	01 d0                	add    %edx,%eax
  102633:	8b 00                	mov    (%eax),%eax
  102635:	83 e0 01             	and    $0x1,%eax
  102638:	85 c0                	test   %eax,%eax
  10263a:	0f 84 8f 00 00 00    	je     1026cf <clone_directory+0x1a8>

						int table_flags = table[tbl_idx] & 0xFFF;
  102640:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102643:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  10264a:	8b 45 d8             	mov    -0x28(%ebp),%eax
  10264d:	01 d0                	add    %edx,%eax
  10264f:	8b 00                	mov    (%eax),%eax
  102651:	25 ff 0f 00 00       	and    $0xfff,%eax
  102656:	89 45 d4             	mov    %eax,-0x2c(%ebp)

						frame = (phys_t *)frame_calloc();
  102659:	e8 b4 f5 ff ff       	call   101c12 <frame_calloc>
  10265e:	89 45 d0             	mov    %eax,-0x30(%ebp)
						from_addr = (virt_t *)(dir_idx * 1024 * PAGE_SIZE + tbl_idx * PAGE_SIZE);
  102661:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102664:	c1 e0 0a             	shl    $0xa,%eax
  102667:	89 c2                	mov    %eax,%edx
  102669:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10266c:	01 d0                	add    %edx,%eax
  10266e:	c1 e0 0c             	shl    $0xc,%eax
  102671:	89 45 cc             	mov    %eax,-0x34(%ebp)
						//kprintf("copy phys: %p->%p, flags: 0x%3x\n", from_addr, frame, table_flags);
						addr = temp_map(frame);
  102674:	83 ec 0c             	sub    $0xc,%esp
  102677:	ff 75 d0             	pushl  -0x30(%ebp)
  10267a:	e8 6d fe ff ff       	call   1024ec <temp_map>
  10267f:	83 c4 10             	add    $0x10,%esp
  102682:	89 45 dc             	mov    %eax,-0x24(%ebp)
						memcpy(addr, from_addr, PAGE_SIZE);
  102685:	83 ec 04             	sub    $0x4,%esp
  102688:	68 00 10 00 00       	push   $0x1000
  10268d:	ff 75 cc             	pushl  -0x34(%ebp)
  102690:	ff 75 dc             	pushl  -0x24(%ebp)
  102693:	e8 28 1b 00 00       	call   1041c0 <memcpy>
  102698:	83 c4 10             	add    $0x10,%esp
						temp_unmap();
  10269b:	e8 6f fe ff ff       	call   10250f <temp_unmap>

						addr = temp_map(new_table);
  1026a0:	83 ec 0c             	sub    $0xc,%esp
  1026a3:	ff 75 e0             	pushl  -0x20(%ebp)
  1026a6:	e8 41 fe ff ff       	call   1024ec <temp_map>
  1026ab:	83 c4 10             	add    $0x10,%esp
  1026ae:	89 45 dc             	mov    %eax,-0x24(%ebp)
						addr[tbl_idx] = (phys_t)frame | table_flags;
  1026b1:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1026b4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  1026bb:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1026be:	01 d0                	add    %edx,%eax
  1026c0:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  1026c3:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  1026c6:	09 ca                	or     %ecx,%edx
  1026c8:	89 10                	mov    %edx,(%eax)
						temp_unmap();
  1026ca:	e8 40 fe ff ff       	call   10250f <temp_unmap>
				addr = temp_map(new_dir);
				addr[dir_idx] = (phys_t)new_table | dir_flags;
				temp_unmap();

				table = (virt_t *) (PTABLES_ADDR + dir_idx * PAGE_SIZE);
				for(tbl_idx = 0; tbl_idx < 1024; tbl_idx++) {
  1026cf:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
  1026d3:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
  1026da:	0f 86 44 ff ff ff    	jbe    102624 <clone_directory+0xfd>
	phys_t *frame;
	virt_t *from_addr;
	// extern unsigned int stack_size;

	cli();
	for(dir_idx = 0; dir_idx < 1023; dir_idx++) {
  1026e0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
  1026e4:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
  1026eb:	0f 86 58 fe ff ff    	jbe    102549 <clone_directory+0x22>
					}
				}
			}
		}
	}
	recursively_map_page_directory(new_dir);
  1026f1:	83 ec 0c             	sub    $0xc,%esp
  1026f4:	ff 75 e8             	pushl  -0x18(%ebp)
  1026f7:	e8 6e f7 ff ff       	call   101e6a <recursively_map_page_directory>
  1026fc:	83 c4 10             	add    $0x10,%esp
	iter++;
  1026ff:	a1 98 b0 10 00       	mov    0x10b098,%eax
  102704:	83 c0 01             	add    $0x1,%eax
  102707:	a3 98 b0 10 00       	mov    %eax,0x10b098
	sti();
  10270c:	fb                   	sti    
	return new_dir;
  10270d:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
  102710:	c9                   	leave  
  102711:	c3                   	ret    

00102712 <move_stack_up>:


// Moving stack up in memory (KERNEL_STACK_HI)
// so clone_directory() will clone it instead of linking it
void move_stack_up()
{
  102712:	55                   	push   %ebp
  102713:	89 e5                	mov    %esp,%ebp
  102715:	83 ec 38             	sub    $0x38,%esp
	KASSERT(pg_on);
  102718:	0f b6 05 90 b0 10 00 	movzbl 0x10b090,%eax
  10271f:	84 c0                	test   %al,%al
  102721:	75 29                	jne    10274c <move_stack_up+0x3a>
  102723:	83 ec 0c             	sub    $0xc,%esp
  102726:	68 a6 01 00 00       	push   $0x1a6
  10272b:	68 59 6a 10 00       	push   $0x106a59
  102730:	68 cd 6b 10 00       	push   $0x106bcd
  102735:	68 69 6b 10 00       	push   $0x106b69
  10273a:	68 74 6a 10 00       	push   $0x106a74
  10273f:	e8 64 dc ff ff       	call   1003a8 <kprintf>
  102744:	83 c4 20             	add    $0x20,%esp
  102747:	e8 8f e0 ff ff       	call   1007db <halt>
	cli();
  10274c:	fa                   	cli    
	phys_t *frame;
	extern unsigned int stack_ptr, stack_size;
	unsigned int *p, *k, i;
	unsigned int offset = KERNEL_STACK_HI - stack_ptr;
  10274d:	a1 e8 c0 10 00       	mov    0x10c0e8,%eax
  102752:	ba 00 80 11 ff       	mov    $0xff118000,%edx
  102757:	29 c2                	sub    %eax,%edx
  102759:	89 d0                	mov    %edx,%eax
  10275b:	89 45 ec             	mov    %eax,-0x14(%ebp)

	for(i = stack_size / PAGE_SIZE; i; i--) {
  10275e:	a1 f4 c0 10 00       	mov    0x10c0f4,%eax
  102763:	c1 e8 0c             	shr    $0xc,%eax
  102766:	89 45 f0             	mov    %eax,-0x10(%ebp)
  102769:	e9 ae 00 00 00       	jmp    10281c <move_stack_up+0x10a>
		frame = frame_calloc();
  10276e:	e8 9f f4 ff ff       	call   101c12 <frame_calloc>
  102773:	89 45 e8             	mov    %eax,-0x18(%ebp)
		map(KERNEL_STACK_HI - PAGE_SIZE * i, (unsigned int)frame, P_PRESENT | P_READ_WRITE);
  102776:	8b 55 e8             	mov    -0x18(%ebp),%edx
  102779:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10277c:	b8 00 00 00 00       	mov    $0x0,%eax
  102781:	29 c8                	sub    %ecx,%eax
  102783:	c1 e0 0c             	shl    $0xc,%eax
  102786:	2d 00 80 ee 00       	sub    $0xee8000,%eax
  10278b:	83 ec 04             	sub    $0x4,%esp
  10278e:	6a 03                	push   $0x3
  102790:	52                   	push   %edx
  102791:	50                   	push   %eax
  102792:	e8 7f fa ff ff       	call   102216 <map>
  102797:	83 c4 10             	add    $0x10,%esp
		for(p = (unsigned int *)(stack_ptr-PAGE_SIZE*i); (unsigned int)p < stack_ptr-PAGE_SIZE*(i-1); p++) {
  10279a:	a1 e8 c0 10 00       	mov    0x10c0e8,%eax
  10279f:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1027a2:	c1 e2 0c             	shl    $0xc,%edx
  1027a5:	29 d0                	sub    %edx,%eax
  1027a7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1027aa:	eb 51                	jmp    1027fd <move_stack_up+0xeb>
			k = (unsigned int*)((unsigned int)p+offset);
  1027ac:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1027af:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1027b2:	01 d0                	add    %edx,%eax
  1027b4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			if(*p < stack_ptr && *p >= stack_ptr-stack_size) {
  1027b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1027ba:	8b 10                	mov    (%eax),%edx
  1027bc:	a1 e8 c0 10 00       	mov    0x10c0e8,%eax
  1027c1:	39 c2                	cmp    %eax,%edx
  1027c3:	73 2a                	jae    1027ef <move_stack_up+0xdd>
  1027c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1027c8:	8b 00                	mov    (%eax),%eax
  1027ca:	8b 0d e8 c0 10 00    	mov    0x10c0e8,%ecx
  1027d0:	8b 15 f4 c0 10 00    	mov    0x10c0f4,%edx
  1027d6:	29 d1                	sub    %edx,%ecx
  1027d8:	89 ca                	mov    %ecx,%edx
  1027da:	39 d0                	cmp    %edx,%eax
  1027dc:	72 11                	jb     1027ef <move_stack_up+0xdd>
				*k = (unsigned int)*p + offset;
  1027de:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1027e1:	8b 10                	mov    (%eax),%edx
  1027e3:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1027e6:	01 c2                	add    %eax,%edx
  1027e8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1027eb:	89 10                	mov    %edx,(%eax)
  1027ed:	eb 0a                	jmp    1027f9 <move_stack_up+0xe7>
			} else {
				*k = *p;
  1027ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1027f2:	8b 10                	mov    (%eax),%edx
  1027f4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1027f7:	89 10                	mov    %edx,(%eax)
	unsigned int offset = KERNEL_STACK_HI - stack_ptr;

	for(i = stack_size / PAGE_SIZE; i; i--) {
		frame = frame_calloc();
		map(KERNEL_STACK_HI - PAGE_SIZE * i, (unsigned int)frame, P_PRESENT | P_READ_WRITE);
		for(p = (unsigned int *)(stack_ptr-PAGE_SIZE*i); (unsigned int)p < stack_ptr-PAGE_SIZE*(i-1); p++) {
  1027f9:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
  1027fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102800:	8b 15 e8 c0 10 00    	mov    0x10c0e8,%edx
  102806:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  102809:	81 c1 ff ff 0f 00    	add    $0xfffff,%ecx
  10280f:	c1 e1 0c             	shl    $0xc,%ecx
  102812:	29 ca                	sub    %ecx,%edx
  102814:	39 d0                	cmp    %edx,%eax
  102816:	72 94                	jb     1027ac <move_stack_up+0x9a>
	phys_t *frame;
	extern unsigned int stack_ptr, stack_size;
	unsigned int *p, *k, i;
	unsigned int offset = KERNEL_STACK_HI - stack_ptr;

	for(i = stack_size / PAGE_SIZE; i; i--) {
  102818:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
  10281c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  102820:	0f 85 48 ff ff ff    	jne    10276e <move_stack_up+0x5c>
			}
		}
	}

	unsigned int old_esp, old_ebp, new_esp, new_ebp;
	asm volatile("movl %%esp, %0" : "=r"(old_esp));
  102826:	89 e0                	mov    %esp,%eax
  102828:	89 45 e0             	mov    %eax,-0x20(%ebp)
	asm volatile("movl %%ebp, %0" : "=r"(old_ebp));
  10282b:	89 e8                	mov    %ebp,%eax
  10282d:	89 45 dc             	mov    %eax,-0x24(%ebp)
	new_esp = old_esp + offset;
  102830:	8b 55 e0             	mov    -0x20(%ebp),%edx
  102833:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102836:	01 d0                	add    %edx,%eax
  102838:	89 45 d8             	mov    %eax,-0x28(%ebp)
	new_ebp = old_ebp + offset;
  10283b:	8b 55 dc             	mov    -0x24(%ebp),%edx
  10283e:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102841:	01 d0                	add    %edx,%eax
  102843:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	asm volatile("movl %0, %%esp"::"r"(new_esp));
  102846:	8b 45 d8             	mov    -0x28(%ebp),%eax
  102849:	89 c4                	mov    %eax,%esp
	asm volatile("movl %0, %%ebp"::"r"(new_ebp));
  10284b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  10284e:	89 c5                	mov    %eax,%ebp
	sti();
  102850:	fb                   	sti    
}
  102851:	c9                   	leave  
  102852:	c3                   	ret    

00102853 <switch_page_directory>:

// inline me, so we don't modify esp, ebp //
inline void switch_page_directory (dir_t *dir) __attribute__((always_inline));
inline void switch_page_directory(dir_t *dir)
{
  102853:	55                   	push   %ebp
  102854:	89 e5                	mov    %esp,%ebp
  102856:	83 ec 10             	sub    $0x10,%esp
	asm volatile("mov %0, %%cr3":: "r"(dir));
  102859:	8b 45 08             	mov    0x8(%ebp),%eax
  10285c:	0f 22 d8             	mov    %eax,%cr3
	unsigned int cr0;
	asm volatile("mov %%cr0, %0": "=r"(cr0));
  10285f:	0f 20 c0             	mov    %cr0,%eax
  102862:	89 45 fc             	mov    %eax,-0x4(%ebp)
	cr0 |= 0x80000000;
  102865:	81 4d fc 00 00 00 80 	orl    $0x80000000,-0x4(%ebp)
	asm volatile("mov %0, %%cr0":: "r"(cr0));
  10286c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10286f:	0f 22 c0             	mov    %eax,%cr0
}
  102872:	c9                   	leave  
  102873:	c3                   	ret    

00102874 <mem_init>:

void mem_init(multiboot_header *mb)
{
  102874:	55                   	push   %ebp
  102875:	89 e5                	mov    %esp,%ebp
  102877:	83 ec 18             	sub    $0x18,%esp
	reserve_memory(mb);
  10287a:	83 ec 0c             	sub    $0xc,%esp
  10287d:	ff 75 08             	pushl  0x8(%ebp)
  102880:	e8 64 f5 ff ff       	call   101de9 <reserve_memory>
  102885:	83 c4 10             	add    $0x10,%esp
	total_pages = num_pages;
  102888:	a1 00 c0 10 00       	mov    0x10c000,%eax
  10288d:	a3 44 c0 10 00       	mov    %eax,0x10c044
	kprintf("Available memory: %d pages, %d MB\n", num_pages, num_pages * 4/1024);
  102892:	a1 00 c0 10 00       	mov    0x10c000,%eax
  102897:	c1 e0 02             	shl    $0x2,%eax
  10289a:	c1 e8 0a             	shr    $0xa,%eax
  10289d:	89 c2                	mov    %eax,%edx
  10289f:	a1 00 c0 10 00       	mov    0x10c000,%eax
  1028a4:	83 ec 04             	sub    $0x4,%esp
  1028a7:	52                   	push   %edx
  1028a8:	50                   	push   %eax
  1028a9:	68 70 6b 10 00       	push   $0x106b70
  1028ae:	e8 f5 da ff ff       	call   1003a8 <kprintf>
  1028b3:	83 c4 10             	add    $0x10,%esp
	kernel_dir = frame_calloc();
  1028b6:	e8 57 f3 ff ff       	call   101c12 <frame_calloc>
  1028bb:	a3 88 b0 10 00       	mov    %eax,0x10b088
	identity_map_kernel(kernel_dir, mb);
  1028c0:	a1 88 b0 10 00       	mov    0x10b088,%eax
  1028c5:	83 ec 08             	sub    $0x8,%esp
  1028c8:	ff 75 08             	pushl  0x8(%ebp)
  1028cb:	50                   	push   %eax
  1028cc:	e8 75 f6 ff ff       	call   101f46 <identity_map_kernel>
  1028d1:	83 c4 10             	add    $0x10,%esp
	recursively_map_page_directory(kernel_dir);
  1028d4:	a1 88 b0 10 00       	mov    0x10b088,%eax
  1028d9:	83 ec 0c             	sub    $0xc,%esp
  1028dc:	50                   	push   %eax
  1028dd:	e8 88 f5 ff ff       	call   101e6a <recursively_map_page_directory>
  1028e2:	83 c4 10             	add    $0x10,%esp

	switch_page_directory(kernel_dir);
  1028e5:	a1 88 b0 10 00       	mov    0x10b088,%eax
  1028ea:	89 45 f4             	mov    %eax,-0xc(%ebp)

// inline me, so we don't modify esp, ebp //
inline void switch_page_directory (dir_t *dir) __attribute__((always_inline));
inline void switch_page_directory(dir_t *dir)
{
	asm volatile("mov %0, %%cr3":: "r"(dir));
  1028ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1028f0:	0f 22 d8             	mov    %eax,%cr3
	unsigned int cr0;
	asm volatile("mov %%cr0, %0": "=r"(cr0));
  1028f3:	0f 20 c0             	mov    %cr0,%eax
  1028f6:	89 45 f0             	mov    %eax,-0x10(%ebp)
	cr0 |= 0x80000000;
  1028f9:	81 4d f0 00 00 00 80 	orl    $0x80000000,-0x10(%ebp)
	asm volatile("mov %0, %%cr0":: "r"(cr0));
  102900:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102903:	0f 22 c0             	mov    %eax,%cr0
	kernel_dir = frame_calloc();
	identity_map_kernel(kernel_dir, mb);
	recursively_map_page_directory(kernel_dir);

	switch_page_directory(kernel_dir);
	pg_on = true;
  102906:	c6 05 90 b0 10 00 01 	movb   $0x1,0x10b090
	move_stack_up();
  10290d:	e8 00 fe ff ff       	call   102712 <move_stack_up>

	setup_heap();
  102912:	e8 bc f9 ff ff       	call   1022d3 <setup_heap>
	heap_init(mb);
  102917:	83 ec 0c             	sub    $0xc,%esp
  10291a:	ff 75 08             	pushl  0x8(%ebp)
  10291d:	e8 79 0b 00 00       	call   10349b <heap_init>
  102922:	83 c4 10             	add    $0x10,%esp
	// dir_t *new_dir = clone_directory();
	// kprintf("switching 2\n");
	// switch_page_directory(new_dir);

	// dump_dir();
	kprintf("Curr dir at: %p\n", virt_to_phys(PDIR_ADDR));
  102925:	83 ec 0c             	sub    $0xc,%esp
  102928:	68 00 f0 ff ff       	push   $0xfffff000
  10292d:	e8 22 f8 ff ff       	call   102154 <virt_to_phys>
  102932:	83 c4 10             	add    $0x10,%esp
  102935:	83 ec 08             	sub    $0x8,%esp
  102938:	50                   	push   %eax
  102939:	68 93 6b 10 00       	push   $0x106b93
  10293e:	e8 65 da ff ff       	call   1003a8 <kprintf>
  102943:	83 c4 10             	add    $0x10,%esp
	// heap_dump();
}
  102946:	c9                   	leave  
  102947:	c3                   	ret    

00102948 <debug_dump_list>:
extern int getpid();
// block_meta_t *first_block = 0;
//unsigned int calls = 0;
//extern page_directory_t *kernel_dir;

void debug_dump_list(block_meta_t *p) {
  102948:	55                   	push   %ebp
  102949:	89 e5                	mov    %esp,%ebp
  10294b:	57                   	push   %edi
  10294c:	56                   	push   %esi
  10294d:	53                   	push   %ebx
  10294e:	83 ec 1c             	sub    $0x1c,%esp
//	block_meta_t *p;
//	p = first_block;
	// cli();
	static int dplitr = 0;
	while (p) {
  102951:	e9 0e 01 00 00       	jmp    102a64 <debug_dump_list+0x11c>
		KASSERT(p->magic_head == MAGIC_HEAD);
  102956:	8b 45 08             	mov    0x8(%ebp),%eax
  102959:	8b 00                	mov    (%eax),%eax
  10295b:	3d de c0 ad de       	cmp    $0xdeadc0de,%eax
  102960:	74 26                	je     102988 <debug_dump_list+0x40>
  102962:	83 ec 0c             	sub    $0xc,%esp
  102965:	6a 1d                	push   $0x1d
  102967:	68 dc 6b 10 00       	push   $0x106bdc
  10296c:	68 d6 6e 10 00       	push   $0x106ed6
  102971:	68 e4 6b 10 00       	push   $0x106be4
  102976:	68 00 6c 10 00       	push   $0x106c00
  10297b:	e8 28 da ff ff       	call   1003a8 <kprintf>
  102980:	83 c4 20             	add    $0x20,%esp
  102983:	e8 53 de ff ff       	call   1007db <halt>
		KASSERT(p->magic_end == MAGIC_END);
  102988:	8b 45 08             	mov    0x8(%ebp),%eax
  10298b:	8b 40 10             	mov    0x10(%eax),%eax
  10298e:	3d ba ba ad de       	cmp    $0xdeadbaba,%eax
  102993:	74 26                	je     1029bb <debug_dump_list+0x73>
  102995:	83 ec 0c             	sub    $0xc,%esp
  102998:	6a 1e                	push   $0x1e
  10299a:	68 dc 6b 10 00       	push   $0x106bdc
  10299f:	68 d6 6e 10 00       	push   $0x106ed6
  1029a4:	68 30 6c 10 00       	push   $0x106c30
  1029a9:	68 00 6c 10 00       	push   $0x106c00
  1029ae:	e8 f5 d9 ff ff       	call   1003a8 <kprintf>
  1029b3:	83 c4 20             	add    $0x20,%esp
  1029b6:	e8 20 de ff ff       	call   1007db <halt>
		kprintf("pid:%d, node: 0x%X, ptr: %p, size: %8d, %s, next: 0x%X\n", getpid(), p, p+1,
  1029bb:	8b 45 08             	mov    0x8(%ebp),%eax
  1029be:	8b 70 0c             	mov    0xc(%eax),%esi
		        p->size, p->free ? "free" : "used", p->next);
  1029c1:	8b 45 08             	mov    0x8(%ebp),%eax
  1029c4:	0f b6 40 08          	movzbl 0x8(%eax),%eax
	// cli();
	static int dplitr = 0;
	while (p) {
		KASSERT(p->magic_head == MAGIC_HEAD);
		KASSERT(p->magic_end == MAGIC_END);
		kprintf("pid:%d, node: 0x%X, ptr: %p, size: %8d, %s, next: 0x%X\n", getpid(), p, p+1,
  1029c8:	84 c0                	test   %al,%al
  1029ca:	74 09                	je     1029d5 <debug_dump_list+0x8d>
  1029cc:	c7 45 e4 4a 6c 10 00 	movl   $0x106c4a,-0x1c(%ebp)
  1029d3:	eb 07                	jmp    1029dc <debug_dump_list+0x94>
  1029d5:	c7 45 e4 4f 6c 10 00 	movl   $0x106c4f,-0x1c(%ebp)
  1029dc:	8b 45 08             	mov    0x8(%ebp),%eax
  1029df:	8b 58 04             	mov    0x4(%eax),%ebx
  1029e2:	8b 45 08             	mov    0x8(%ebp),%eax
  1029e5:	8d 78 14             	lea    0x14(%eax),%edi
  1029e8:	e8 71 14 00 00       	call   103e5e <getpid>
  1029ed:	83 ec 04             	sub    $0x4,%esp
  1029f0:	56                   	push   %esi
  1029f1:	ff 75 e4             	pushl  -0x1c(%ebp)
  1029f4:	53                   	push   %ebx
  1029f5:	57                   	push   %edi
  1029f6:	ff 75 08             	pushl  0x8(%ebp)
  1029f9:	50                   	push   %eax
  1029fa:	68 54 6c 10 00       	push   $0x106c54
  1029ff:	e8 a4 d9 ff ff       	call   1003a8 <kprintf>
  102a04:	83 c4 20             	add    $0x20,%esp
		        p->size, p->free ? "free" : "used", p->next);
		KASSERT(p != p->next);
  102a07:	8b 45 08             	mov    0x8(%ebp),%eax
  102a0a:	8b 40 0c             	mov    0xc(%eax),%eax
  102a0d:	3b 45 08             	cmp    0x8(%ebp),%eax
  102a10:	75 26                	jne    102a38 <debug_dump_list+0xf0>
  102a12:	83 ec 0c             	sub    $0xc,%esp
  102a15:	6a 21                	push   $0x21
  102a17:	68 dc 6b 10 00       	push   $0x106bdc
  102a1c:	68 d6 6e 10 00       	push   $0x106ed6
  102a21:	68 8c 6c 10 00       	push   $0x106c8c
  102a26:	68 00 6c 10 00       	push   $0x106c00
  102a2b:	e8 78 d9 ff ff       	call   1003a8 <kprintf>
  102a30:	83 c4 20             	add    $0x20,%esp
  102a33:	e8 a3 dd ff ff       	call   1007db <halt>
		p = p->next;
  102a38:	8b 45 08             	mov    0x8(%ebp),%eax
  102a3b:	8b 40 0c             	mov    0xc(%eax),%eax
  102a3e:	89 45 08             	mov    %eax,0x8(%ebp)
		if(dplitr++ > 50) {panic("Too many iterations\n");}
  102a41:	a1 ac b0 10 00       	mov    0x10b0ac,%eax
  102a46:	8d 50 01             	lea    0x1(%eax),%edx
  102a49:	89 15 ac b0 10 00    	mov    %edx,0x10b0ac
  102a4f:	83 f8 32             	cmp    $0x32,%eax
  102a52:	7e 10                	jle    102a64 <debug_dump_list+0x11c>
  102a54:	83 ec 0c             	sub    $0xc,%esp
  102a57:	68 99 6c 10 00       	push   $0x106c99
  102a5c:	e8 e3 d9 ff ff       	call   100444 <panic>
  102a61:	83 c4 10             	add    $0x10,%esp
void debug_dump_list(block_meta_t *p) {
//	block_meta_t *p;
//	p = first_block;
	// cli();
	static int dplitr = 0;
	while (p) {
  102a64:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  102a68:	0f 85 e8 fe ff ff    	jne    102956 <debug_dump_list+0xe>
		KASSERT(p != p->next);
		p = p->next;
		if(dplitr++ > 50) {panic("Too many iterations\n");}
	}
	//sti();
}
  102a6e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  102a71:	5b                   	pop    %ebx
  102a72:	5e                   	pop    %esi
  102a73:	5f                   	pop    %edi
  102a74:	5d                   	pop    %ebp
  102a75:	c3                   	ret    

00102a76 <heap_dump>:

void heap_dump()
{
  102a76:	55                   	push   %ebp
  102a77:	89 e5                	mov    %esp,%ebp
  102a79:	83 ec 08             	sub    $0x8,%esp
	kprintf("HEAP\tstart_addr: %p, end_addr: %p, max_addr: %p, \n", heap->start_addr, heap->end_addr, heap->max_addr);
  102a7c:	a1 44 63 10 00       	mov    0x106344,%eax
  102a81:	8b 48 08             	mov    0x8(%eax),%ecx
  102a84:	a1 44 63 10 00       	mov    0x106344,%eax
  102a89:	8b 50 04             	mov    0x4(%eax),%edx
  102a8c:	a1 44 63 10 00       	mov    0x106344,%eax
  102a91:	8b 00                	mov    (%eax),%eax
  102a93:	51                   	push   %ecx
  102a94:	52                   	push   %edx
  102a95:	50                   	push   %eax
  102a96:	68 b0 6c 10 00       	push   $0x106cb0
  102a9b:	e8 08 d9 ff ff       	call   1003a8 <kprintf>
  102aa0:	83 c4 10             	add    $0x10,%esp
}
  102aa3:	c9                   	leave  
  102aa4:	c3                   	ret    

00102aa5 <init_first_block>:

void init_first_block()
{
  102aa5:	55                   	push   %ebp
  102aa6:	89 e5                	mov    %esp,%ebp
  102aa8:	83 ec 08             	sub    $0x8,%esp
	KASSERT(HEAP_INITIAL_SIZE > sizeof(block_meta_t));
	kprintf("Setup initial heap, at: 0x%X, initial size: 0x%X\n", HEAP_START, HEAP_INITIAL_SIZE);
  102aab:	83 ec 04             	sub    $0x4,%esp
  102aae:	68 00 00 01 00       	push   $0x10000
  102ab3:	68 00 00 00 d0       	push   $0xd0000000
  102ab8:	68 e4 6c 10 00       	push   $0x106ce4
  102abd:	e8 e6 d8 ff ff       	call   1003a8 <kprintf>
  102ac2:	83 c4 10             	add    $0x10,%esp
	first_block = (block_meta_t *) HEAP_START;
  102ac5:	c7 05 00 c1 10 00 00 	movl   $0xd0000000,0x10c100
  102acc:	00 00 d0 
	first_block->free = true;
  102acf:	a1 00 c1 10 00       	mov    0x10c100,%eax
  102ad4:	c6 40 08 01          	movb   $0x1,0x8(%eax)
	first_block->size = HEAP_INITIAL_SIZE - sizeof(block_meta_t);
  102ad8:	a1 00 c1 10 00       	mov    0x10c100,%eax
  102add:	c7 40 04 ec ff 00 00 	movl   $0xffec,0x4(%eax)
	first_block->magic_head = MAGIC_HEAD;
  102ae4:	a1 00 c1 10 00       	mov    0x10c100,%eax
  102ae9:	c7 00 de c0 ad de    	movl   $0xdeadc0de,(%eax)
	first_block->magic_end = MAGIC_END;
  102aef:	a1 00 c1 10 00       	mov    0x10c100,%eax
  102af4:	c7 40 10 ba ba ad de 	movl   $0xdeadbaba,0x10(%eax)
	first_block->next = NULL;
  102afb:	a1 00 c1 10 00       	mov    0x10c100,%eax
  102b00:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
  102b07:	c9                   	leave  
  102b08:	c3                   	ret    

00102b09 <malloc>:

void *malloc(unsigned int nbytes) {
  102b09:	55                   	push   %ebp
  102b0a:	89 e5                	mov    %esp,%ebp
  102b0c:	83 ec 18             	sub    $0x18,%esp
	block_meta_t *p, *n;
	unsigned int next_size;
	char *c;
	if(nbytes % 4 != 0)
  102b0f:	8b 45 08             	mov    0x8(%ebp),%eax
  102b12:	83 e0 03             	and    $0x3,%eax
  102b15:	85 c0                	test   %eax,%eax
  102b17:	74 0f                	je     102b28 <malloc+0x1f>
		nbytes = (nbytes / 4 + 1) * 4; // align to 4 bytes
  102b19:	8b 45 08             	mov    0x8(%ebp),%eax
  102b1c:	c1 e8 02             	shr    $0x2,%eax
  102b1f:	83 c0 01             	add    $0x1,%eax
  102b22:	c1 e0 02             	shl    $0x2,%eax
  102b25:	89 45 08             	mov    %eax,0x8(%ebp)

	KASSERT(first_block != NULL);
  102b28:	a1 00 c1 10 00       	mov    0x10c100,%eax
  102b2d:	85 c0                	test   %eax,%eax
  102b2f:	75 26                	jne    102b57 <malloc+0x4e>
  102b31:	83 ec 0c             	sub    $0xc,%esp
  102b34:	6a 40                	push   $0x40
  102b36:	68 dc 6b 10 00       	push   $0x106bdc
  102b3b:	68 e6 6e 10 00       	push   $0x106ee6
  102b40:	68 16 6d 10 00       	push   $0x106d16
  102b45:	68 00 6c 10 00       	push   $0x106c00
  102b4a:	e8 59 d8 ff ff       	call   1003a8 <kprintf>
  102b4f:	83 c4 20             	add    $0x20,%esp
  102b52:	e8 84 dc ff ff       	call   1007db <halt>
	KASSERT(first_block->magic_head == MAGIC_HEAD);
  102b57:	a1 00 c1 10 00       	mov    0x10c100,%eax
  102b5c:	8b 00                	mov    (%eax),%eax
  102b5e:	3d de c0 ad de       	cmp    $0xdeadc0de,%eax
  102b63:	74 26                	je     102b8b <malloc+0x82>
  102b65:	83 ec 0c             	sub    $0xc,%esp
  102b68:	6a 41                	push   $0x41
  102b6a:	68 dc 6b 10 00       	push   $0x106bdc
  102b6f:	68 e6 6e 10 00       	push   $0x106ee6
  102b74:	68 2c 6d 10 00       	push   $0x106d2c
  102b79:	68 00 6c 10 00       	push   $0x106c00
  102b7e:	e8 25 d8 ff ff       	call   1003a8 <kprintf>
  102b83:	83 c4 20             	add    $0x20,%esp
  102b86:	e8 50 dc ff ff       	call   1007db <halt>
	KASSERT(first_block->magic_end == MAGIC_END);
  102b8b:	a1 00 c1 10 00       	mov    0x10c100,%eax
  102b90:	8b 40 10             	mov    0x10(%eax),%eax
  102b93:	3d ba ba ad de       	cmp    $0xdeadbaba,%eax
  102b98:	74 26                	je     102bc0 <malloc+0xb7>
  102b9a:	83 ec 0c             	sub    $0xc,%esp
  102b9d:	6a 42                	push   $0x42
  102b9f:	68 dc 6b 10 00       	push   $0x106bdc
  102ba4:	68 e6 6e 10 00       	push   $0x106ee6
  102ba9:	68 54 6d 10 00       	push   $0x106d54
  102bae:	68 00 6c 10 00       	push   $0x106c00
  102bb3:	e8 f0 d7 ff ff       	call   1003a8 <kprintf>
  102bb8:	83 c4 20             	add    $0x20,%esp
  102bbb:	e8 1b dc ff ff       	call   1007db <halt>
	p = first_block;
  102bc0:	a1 00 c1 10 00       	mov    0x10c100,%eax
  102bc5:	89 45 f4             	mov    %eax,-0xc(%ebp)

	while (p) {
  102bc8:	e9 2e 01 00 00       	jmp    102cfb <malloc+0x1f2>
			// kprintf(".");
		if (!p->free) {
  102bcd:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102bd0:	0f b6 40 08          	movzbl 0x8(%eax),%eax
  102bd4:	84 c0                	test   %al,%al
  102bd6:	75 0e                	jne    102be6 <malloc+0xdd>
			p = p->next;
  102bd8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102bdb:	8b 40 0c             	mov    0xc(%eax),%eax
  102bde:	89 45 f4             	mov    %eax,-0xc(%ebp)
			continue;
  102be1:	e9 15 01 00 00       	jmp    102cfb <malloc+0x1f2>
		}
		if ((p->size < nbytes + sizeof(block_meta_t)) && p->next == NULL) {
  102be6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102be9:	8b 40 04             	mov    0x4(%eax),%eax
  102bec:	8b 55 08             	mov    0x8(%ebp),%edx
  102bef:	83 c2 14             	add    $0x14,%edx
  102bf2:	39 d0                	cmp    %edx,%eax
  102bf4:	73 31                	jae    102c27 <malloc+0x11e>
  102bf6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102bf9:	8b 40 0c             	mov    0xc(%eax),%eax
  102bfc:	85 c0                	test   %eax,%eax
  102bfe:	75 27                	jne    102c27 <malloc+0x11e>
			// kprintf("+");
			sbrk(PAGE_SIZE);
  102c00:	83 ec 0c             	sub    $0xc,%esp
  102c03:	68 00 10 00 00       	push   $0x1000
  102c08:	e8 39 f7 ff ff       	call   102346 <sbrk>
  102c0d:	83 c4 10             	add    $0x10,%esp
			p->size += PAGE_SIZE;
  102c10:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102c13:	8b 40 04             	mov    0x4(%eax),%eax
  102c16:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
  102c1c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102c1f:	89 50 04             	mov    %edx,0x4(%eax)
			continue;
  102c22:	e9 d4 00 00 00       	jmp    102cfb <malloc+0x1f2>
		}
		else if(p->size >= nbytes) {
  102c27:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102c2a:	8b 40 04             	mov    0x4(%eax),%eax
  102c2d:	3b 45 08             	cmp    0x8(%ebp),%eax
  102c30:	0f 82 bc 00 00 00    	jb     102cf2 <malloc+0x1e9>
			// kprintf("SPLIT; p: 0x%X orig_size: %i, nbytes: %i, meta: %i\n",p+1, p->size, nbytes, sizeof(block_meta_t));
			c = (char *) p;
  102c36:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102c39:	89 45 f0             	mov    %eax,-0x10(%ebp)
			next_size = p->size - nbytes - sizeof(block_meta_t);
  102c3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102c3f:	8b 40 04             	mov    0x4(%eax),%eax
  102c42:	2b 45 08             	sub    0x8(%ebp),%eax
  102c45:	83 e8 14             	sub    $0x14,%eax
  102c48:	89 45 ec             	mov    %eax,-0x14(%ebp)
			n = p->next;
  102c4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102c4e:	8b 40 0c             	mov    0xc(%eax),%eax
  102c51:	89 45 e8             	mov    %eax,-0x18(%ebp)
			p->size = nbytes;
  102c54:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102c57:	8b 55 08             	mov    0x8(%ebp),%edx
  102c5a:	89 50 04             	mov    %edx,0x4(%eax)
			p->free = false;
  102c5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102c60:	c6 40 08 00          	movb   $0x0,0x8(%eax)
			p->next = (block_meta_t *) (c + sizeof(block_meta_t) + nbytes);
  102c64:	8b 45 08             	mov    0x8(%ebp),%eax
  102c67:	8d 50 14             	lea    0x14(%eax),%edx
  102c6a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102c6d:	01 c2                	add    %eax,%edx
  102c6f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102c72:	89 50 0c             	mov    %edx,0xc(%eax)
			KASSERT((unsigned int)p->next < heap->end_addr);
  102c75:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102c78:	8b 40 0c             	mov    0xc(%eax),%eax
  102c7b:	89 c2                	mov    %eax,%edx
  102c7d:	a1 44 63 10 00       	mov    0x106344,%eax
  102c82:	8b 40 04             	mov    0x4(%eax),%eax
  102c85:	39 c2                	cmp    %eax,%edx
  102c87:	72 26                	jb     102caf <malloc+0x1a6>
  102c89:	83 ec 0c             	sub    $0xc,%esp
  102c8c:	6a 59                	push   $0x59
  102c8e:	68 dc 6b 10 00       	push   $0x106bdc
  102c93:	68 e6 6e 10 00       	push   $0x106ee6
  102c98:	68 78 6d 10 00       	push   $0x106d78
  102c9d:	68 00 6c 10 00       	push   $0x106c00
  102ca2:	e8 01 d7 ff ff       	call   1003a8 <kprintf>
  102ca7:	83 c4 20             	add    $0x20,%esp
  102caa:	e8 2c db ff ff       	call   1007db <halt>
			// 	sbrk(PAGE_SIZE * 2);
			// 	kprintf(".");
			// 	KASSERT(p->next->next == NULL);
			// 	p->next->size += PAGE_SIZE * 2;
			// }
			p->next->free = true;
  102caf:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102cb2:	8b 40 0c             	mov    0xc(%eax),%eax
  102cb5:	c6 40 08 01          	movb   $0x1,0x8(%eax)
			p->next->size = next_size;
  102cb9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102cbc:	8b 40 0c             	mov    0xc(%eax),%eax
  102cbf:	8b 55 ec             	mov    -0x14(%ebp),%edx
  102cc2:	89 50 04             	mov    %edx,0x4(%eax)
			p->next->magic_head = MAGIC_HEAD;
  102cc5:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102cc8:	8b 40 0c             	mov    0xc(%eax),%eax
  102ccb:	c7 00 de c0 ad de    	movl   $0xdeadc0de,(%eax)
			p->next->magic_end = MAGIC_END;
  102cd1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102cd4:	8b 40 0c             	mov    0xc(%eax),%eax
  102cd7:	c7 40 10 ba ba ad de 	movl   $0xdeadbaba,0x10(%eax)
			p->next->next = n;
  102cde:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102ce1:	8b 40 0c             	mov    0xc(%eax),%eax
  102ce4:	8b 55 e8             	mov    -0x18(%ebp),%edx
  102ce7:	89 50 0c             	mov    %edx,0xc(%eax)
			return p + 1;
  102cea:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102ced:	83 c0 14             	add    $0x14,%eax
  102cf0:	eb 43                	jmp    102d35 <malloc+0x22c>
		}
		p = p->next;
  102cf2:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102cf5:	8b 40 0c             	mov    0xc(%eax),%eax
  102cf8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	KASSERT(first_block != NULL);
	KASSERT(first_block->magic_head == MAGIC_HEAD);
	KASSERT(first_block->magic_end == MAGIC_END);
	p = first_block;

	while (p) {
  102cfb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  102cff:	0f 85 c8 fe ff ff    	jne    102bcd <malloc+0xc4>
		}
		p = p->next;
	}
//	debug_dump_list();

	kprintf("%X\n", p);
  102d05:	83 ec 08             	sub    $0x8,%esp
  102d08:	ff 75 f4             	pushl  -0xc(%ebp)
  102d0b:	68 9f 6d 10 00       	push   $0x106d9f
  102d10:	e8 93 d6 ff ff       	call   1003a8 <kprintf>
  102d15:	83 c4 10             	add    $0x10,%esp
	kprintf("Out of memory: malloc %u\n", nbytes);
  102d18:	83 ec 08             	sub    $0x8,%esp
  102d1b:	ff 75 08             	pushl  0x8(%ebp)
  102d1e:	68 a3 6d 10 00       	push   $0x106da3
  102d23:	e8 80 d6 ff ff       	call   1003a8 <kprintf>
  102d28:	83 c4 10             	add    $0x10,%esp
	halt();
  102d2b:	e8 ab da ff ff       	call   1007db <halt>
	return NULL;
  102d30:	b8 00 00 00 00       	mov    $0x0,%eax
}
  102d35:	c9                   	leave  
  102d36:	c3                   	ret    

00102d37 <heap_contract>:

static void heap_contract()
{
  102d37:	55                   	push   %ebp
  102d38:	89 e5                	mov    %esp,%ebp
  102d3a:	83 ec 18             	sub    $0x18,%esp
	block_meta_t *p = first_block;
  102d3d:	a1 00 c1 10 00       	mov    0x10c100,%eax
  102d42:	89 45 f4             	mov    %eax,-0xc(%ebp)
	virt_t addr;
	virt_t new_end;

	while (p->next) {
  102d45:	eb 09                	jmp    102d50 <heap_contract+0x19>
		p = p->next;
  102d47:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102d4a:	8b 40 0c             	mov    0xc(%eax),%eax
  102d4d:	89 45 f4             	mov    %eax,-0xc(%ebp)
{
	block_meta_t *p = first_block;
	virt_t addr;
	virt_t new_end;

	while (p->next) {
  102d50:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102d53:	8b 40 0c             	mov    0xc(%eax),%eax
  102d56:	85 c0                	test   %eax,%eax
  102d58:	75 ed                	jne    102d47 <heap_contract+0x10>
		p = p->next;
	}
	if(p->size > HEAP_INITIAL_SIZE) {
  102d5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102d5d:	8b 40 04             	mov    0x4(%eax),%eax
  102d60:	3d 00 00 01 00       	cmp    $0x10000,%eax
  102d65:	0f 86 2c 01 00 00    	jbe    102e97 <heap_contract+0x160>
		KASSERT((unsigned int)(p+1) + p->size == heap->end_addr);
  102d6b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102d6e:	83 c0 14             	add    $0x14,%eax
  102d71:	89 c2                	mov    %eax,%edx
  102d73:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102d76:	8b 40 04             	mov    0x4(%eax),%eax
  102d79:	01 c2                	add    %eax,%edx
  102d7b:	a1 44 63 10 00       	mov    0x106344,%eax
  102d80:	8b 40 04             	mov    0x4(%eax),%eax
  102d83:	39 c2                	cmp    %eax,%edx
  102d85:	74 26                	je     102dad <heap_contract+0x76>
  102d87:	83 ec 0c             	sub    $0xc,%esp
  102d8a:	6a 7b                	push   $0x7b
  102d8c:	68 dc 6b 10 00       	push   $0x106bdc
  102d91:	68 ed 6e 10 00       	push   $0x106eed
  102d96:	68 c0 6d 10 00       	push   $0x106dc0
  102d9b:	68 00 6c 10 00       	push   $0x106c00
  102da0:	e8 03 d6 ff ff       	call   1003a8 <kprintf>
  102da5:	83 c4 20             	add    $0x20,%esp
  102da8:	e8 2e da ff ff       	call   1007db <halt>
		new_end = ((unsigned int)(p+1) & 0xFFFFF000) + HEAP_INITIAL_SIZE;
  102dad:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102db0:	83 c0 14             	add    $0x14,%eax
  102db3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  102db8:	05 00 00 01 00       	add    $0x10000,%eax
  102dbd:	89 45 ec             	mov    %eax,-0x14(%ebp)
		KASSERT(is_mapped(new_end));
  102dc0:	83 ec 0c             	sub    $0xc,%esp
  102dc3:	ff 75 ec             	pushl  -0x14(%ebp)
  102dc6:	e8 f3 f2 ff ff       	call   1020be <is_mapped>
  102dcb:	83 c4 10             	add    $0x10,%esp
  102dce:	84 c0                	test   %al,%al
  102dd0:	75 26                	jne    102df8 <heap_contract+0xc1>
  102dd2:	83 ec 0c             	sub    $0xc,%esp
  102dd5:	6a 7d                	push   $0x7d
  102dd7:	68 dc 6b 10 00       	push   $0x106bdc
  102ddc:	68 ed 6e 10 00       	push   $0x106eed
  102de1:	68 f0 6d 10 00       	push   $0x106df0
  102de6:	68 00 6c 10 00       	push   $0x106c00
  102deb:	e8 b8 d5 ff ff       	call   1003a8 <kprintf>
  102df0:	83 c4 20             	add    $0x20,%esp
  102df3:	e8 e3 d9 ff ff       	call   1007db <halt>
		p->size = new_end - (unsigned int)(p+1);
  102df8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102dfb:	83 c0 14             	add    $0x14,%eax
  102dfe:	89 c2                	mov    %eax,%edx
  102e00:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102e03:	29 d0                	sub    %edx,%eax
  102e05:	89 c2                	mov    %eax,%edx
  102e07:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102e0a:	89 50 04             	mov    %edx,0x4(%eax)
		for(addr = new_end; addr < heap->end_addr; addr+=PAGE_SIZE) {
  102e0d:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102e10:	89 45 f0             	mov    %eax,-0x10(%ebp)
  102e13:	eb 6a                	jmp    102e7f <heap_contract+0x148>
			KASSERT(is_mapped(addr));
  102e15:	83 ec 0c             	sub    $0xc,%esp
  102e18:	ff 75 f0             	pushl  -0x10(%ebp)
  102e1b:	e8 9e f2 ff ff       	call   1020be <is_mapped>
  102e20:	83 c4 10             	add    $0x10,%esp
  102e23:	84 c0                	test   %al,%al
  102e25:	75 29                	jne    102e50 <heap_contract+0x119>
  102e27:	83 ec 0c             	sub    $0xc,%esp
  102e2a:	68 80 00 00 00       	push   $0x80
  102e2f:	68 dc 6b 10 00       	push   $0x106bdc
  102e34:	68 ed 6e 10 00       	push   $0x106eed
  102e39:	68 03 6e 10 00       	push   $0x106e03
  102e3e:	68 00 6c 10 00       	push   $0x106c00
  102e43:	e8 60 d5 ff ff       	call   1003a8 <kprintf>
  102e48:	83 c4 20             	add    $0x20,%esp
  102e4b:	e8 8b d9 ff ff       	call   1007db <halt>
			frame_free(virt_to_phys(addr));
  102e50:	83 ec 0c             	sub    $0xc,%esp
  102e53:	ff 75 f0             	pushl  -0x10(%ebp)
  102e56:	e8 f9 f2 ff ff       	call   102154 <virt_to_phys>
  102e5b:	83 c4 10             	add    $0x10,%esp
  102e5e:	83 ec 0c             	sub    $0xc,%esp
  102e61:	50                   	push   %eax
  102e62:	e8 1b ee ff ff       	call   101c82 <frame_free>
  102e67:	83 c4 10             	add    $0x10,%esp
			unmap(addr);
  102e6a:	83 ec 0c             	sub    $0xc,%esp
  102e6d:	ff 75 f0             	pushl  -0x10(%ebp)
  102e70:	e8 87 f3 ff ff       	call   1021fc <unmap>
  102e75:	83 c4 10             	add    $0x10,%esp
	if(p->size > HEAP_INITIAL_SIZE) {
		KASSERT((unsigned int)(p+1) + p->size == heap->end_addr);
		new_end = ((unsigned int)(p+1) & 0xFFFFF000) + HEAP_INITIAL_SIZE;
		KASSERT(is_mapped(new_end));
		p->size = new_end - (unsigned int)(p+1);
		for(addr = new_end; addr < heap->end_addr; addr+=PAGE_SIZE) {
  102e78:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
  102e7f:	a1 44 63 10 00       	mov    0x106344,%eax
  102e84:	8b 40 04             	mov    0x4(%eax),%eax
  102e87:	3b 45 f0             	cmp    -0x10(%ebp),%eax
  102e8a:	77 89                	ja     102e15 <heap_contract+0xde>
			KASSERT(is_mapped(addr));
			frame_free(virt_to_phys(addr));
			unmap(addr);
		}
		heap->end_addr = new_end;
  102e8c:	a1 44 63 10 00       	mov    0x106344,%eax
  102e91:	8b 55 ec             	mov    -0x14(%ebp),%edx
  102e94:	89 50 04             	mov    %edx,0x4(%eax)
	}
}
  102e97:	c9                   	leave  
  102e98:	c3                   	ret    

00102e99 <free>:

void free(void *ptr) {
  102e99:	55                   	push   %ebp
  102e9a:	89 e5                	mov    %esp,%ebp
  102e9c:	56                   	push   %esi
  102e9d:	53                   	push   %ebx
  102e9e:	83 ec 10             	sub    $0x10,%esp
	block_meta_t *p, *prev = NULL;
  102ea1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	p = first_block;
  102ea8:	a1 00 c1 10 00       	mov    0x10c100,%eax
  102ead:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for (; ;) {
		if (p + 1 == ptr) {
  102eb0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102eb3:	83 c0 14             	add    $0x14,%eax
  102eb6:	3b 45 08             	cmp    0x8(%ebp),%eax
  102eb9:	0f 85 eb 00 00 00    	jne    102faa <free+0x111>
			KASSERT(p->magic_head == MAGIC_HEAD);
  102ebf:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102ec2:	8b 00                	mov    (%eax),%eax
  102ec4:	3d de c0 ad de       	cmp    $0xdeadc0de,%eax
  102ec9:	74 29                	je     102ef4 <free+0x5b>
  102ecb:	83 ec 0c             	sub    $0xc,%esp
  102ece:	68 8d 00 00 00       	push   $0x8d
  102ed3:	68 dc 6b 10 00       	push   $0x106bdc
  102ed8:	68 fb 6e 10 00       	push   $0x106efb
  102edd:	68 e4 6b 10 00       	push   $0x106be4
  102ee2:	68 00 6c 10 00       	push   $0x106c00
  102ee7:	e8 bc d4 ff ff       	call   1003a8 <kprintf>
  102eec:	83 c4 20             	add    $0x20,%esp
  102eef:	e8 e7 d8 ff ff       	call   1007db <halt>
			KASSERT(p->magic_end == MAGIC_END);
  102ef4:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102ef7:	8b 40 10             	mov    0x10(%eax),%eax
  102efa:	3d ba ba ad de       	cmp    $0xdeadbaba,%eax
  102eff:	74 29                	je     102f2a <free+0x91>
  102f01:	83 ec 0c             	sub    $0xc,%esp
  102f04:	68 8e 00 00 00       	push   $0x8e
  102f09:	68 dc 6b 10 00       	push   $0x106bdc
  102f0e:	68 fb 6e 10 00       	push   $0x106efb
  102f13:	68 30 6c 10 00       	push   $0x106c30
  102f18:	68 00 6c 10 00       	push   $0x106c00
  102f1d:	e8 86 d4 ff ff       	call   1003a8 <kprintf>
  102f22:	83 c4 20             	add    $0x20,%esp
  102f25:	e8 b1 d8 ff ff       	call   1007db <halt>
			p->free = true;
  102f2a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102f2d:	c6 40 08 01          	movb   $0x1,0x8(%eax)
			if (p->next && p->next->free) {
  102f31:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102f34:	8b 40 0c             	mov    0xc(%eax),%eax
  102f37:	85 c0                	test   %eax,%eax
  102f39:	74 37                	je     102f72 <free+0xd9>
  102f3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102f3e:	8b 40 0c             	mov    0xc(%eax),%eax
  102f41:	0f b6 40 08          	movzbl 0x8(%eax),%eax
  102f45:	84 c0                	test   %al,%al
  102f47:	74 29                	je     102f72 <free+0xd9>
				p->size += p->next->size + sizeof(block_meta_t);
  102f49:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102f4c:	8b 50 04             	mov    0x4(%eax),%edx
  102f4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102f52:	8b 40 0c             	mov    0xc(%eax),%eax
  102f55:	8b 40 04             	mov    0x4(%eax),%eax
  102f58:	01 d0                	add    %edx,%eax
  102f5a:	8d 50 14             	lea    0x14(%eax),%edx
  102f5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102f60:	89 50 04             	mov    %edx,0x4(%eax)
				p->next = p->next->next;
  102f63:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102f66:	8b 40 0c             	mov    0xc(%eax),%eax
  102f69:	8b 50 0c             	mov    0xc(%eax),%edx
  102f6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102f6f:	89 50 0c             	mov    %edx,0xc(%eax)
			}
			if (prev && prev->free) {
  102f72:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  102f76:	74 30                	je     102fa8 <free+0x10f>
  102f78:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102f7b:	0f b6 40 08          	movzbl 0x8(%eax),%eax
  102f7f:	84 c0                	test   %al,%al
  102f81:	74 25                	je     102fa8 <free+0x10f>
				prev->size += p->size + sizeof(block_meta_t);
  102f83:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102f86:	8b 50 04             	mov    0x4(%eax),%edx
  102f89:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102f8c:	8b 40 04             	mov    0x4(%eax),%eax
  102f8f:	01 d0                	add    %edx,%eax
  102f91:	8d 50 14             	lea    0x14(%eax),%edx
  102f94:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102f97:	89 50 04             	mov    %edx,0x4(%eax)
				prev->next = p->next;
  102f9a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102f9d:	8b 50 0c             	mov    0xc(%eax),%edx
  102fa0:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102fa3:	89 50 0c             	mov    %edx,0xc(%eax)
			}
			break;
  102fa6:	eb 6d                	jmp    103015 <free+0x17c>
  102fa8:	eb 6b                	jmp    103015 <free+0x17c>
		}
		if (!p->next) {
  102faa:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102fad:	8b 40 0c             	mov    0xc(%eax),%eax
  102fb0:	85 c0                	test   %eax,%eax
  102fb2:	75 4d                	jne    103001 <free+0x168>
			kprintf("Bad free pointer: %p, mem: %p, size: %d, mgh: %X, mge: %X, %s\n",
				ptr, p+1, p->size, p->magic_head, p->magic_end, p->free ? "free":"used");
  102fb4:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102fb7:	0f b6 40 08          	movzbl 0x8(%eax),%eax
				prev->next = p->next;
			}
			break;
		}
		if (!p->next) {
			kprintf("Bad free pointer: %p, mem: %p, size: %d, mgh: %X, mge: %X, %s\n",
  102fbb:	84 c0                	test   %al,%al
  102fbd:	74 07                	je     102fc6 <free+0x12d>
  102fbf:	be 4a 6c 10 00       	mov    $0x106c4a,%esi
  102fc4:	eb 05                	jmp    102fcb <free+0x132>
  102fc6:	be 4f 6c 10 00       	mov    $0x106c4f,%esi
  102fcb:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102fce:	8b 48 10             	mov    0x10(%eax),%ecx
  102fd1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102fd4:	8b 10                	mov    (%eax),%edx
  102fd6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102fd9:	8b 40 04             	mov    0x4(%eax),%eax
  102fdc:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  102fdf:	83 c3 14             	add    $0x14,%ebx
  102fe2:	83 ec 04             	sub    $0x4,%esp
  102fe5:	56                   	push   %esi
  102fe6:	51                   	push   %ecx
  102fe7:	52                   	push   %edx
  102fe8:	50                   	push   %eax
  102fe9:	53                   	push   %ebx
  102fea:	ff 75 08             	pushl  0x8(%ebp)
  102fed:	68 14 6e 10 00       	push   $0x106e14
  102ff2:	e8 b1 d3 ff ff       	call   1003a8 <kprintf>
  102ff7:	83 c4 20             	add    $0x20,%esp
				ptr, p+1, p->size, p->magic_head, p->magic_end, p->free ? "free":"used");
			halt();
  102ffa:	e8 dc d7 ff ff       	call   1007db <halt>
			break;
  102fff:	eb 14                	jmp    103015 <free+0x17c>
		}
		prev = p;
  103001:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103004:	89 45 f0             	mov    %eax,-0x10(%ebp)
		p = p->next;
  103007:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10300a:	8b 40 0c             	mov    0xc(%eax),%eax
  10300d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}
  103010:	e9 9b fe ff ff       	jmp    102eb0 <free+0x17>
	heap_contract();
  103015:	e8 1d fd ff ff       	call   102d37 <heap_contract>
}
  10301a:	8d 65 f8             	lea    -0x8(%ebp),%esp
  10301d:	5b                   	pop    %ebx
  10301e:	5e                   	pop    %esi
  10301f:	5d                   	pop    %ebp
  103020:	c3                   	ret    

00103021 <calloc>:


void *calloc(unsigned int nbytes) {
  103021:	55                   	push   %ebp
  103022:	89 e5                	mov    %esp,%ebp
  103024:	83 ec 18             	sub    $0x18,%esp
	void *p = malloc(nbytes);
  103027:	83 ec 0c             	sub    $0xc,%esp
  10302a:	ff 75 08             	pushl  0x8(%ebp)
  10302d:	e8 d7 fa ff ff       	call   102b09 <malloc>
  103032:	83 c4 10             	add    $0x10,%esp
  103035:	89 45 f4             	mov    %eax,-0xc(%ebp)
	memset(p, 0, nbytes);
  103038:	83 ec 04             	sub    $0x4,%esp
  10303b:	ff 75 08             	pushl  0x8(%ebp)
  10303e:	6a 00                	push   $0x0
  103040:	ff 75 f4             	pushl  -0xc(%ebp)
  103043:	e8 48 12 00 00       	call   104290 <memset>
  103048:	83 c4 10             	add    $0x10,%esp
	return p;
  10304b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
  10304e:	c9                   	leave  
  10304f:	c3                   	ret    

00103050 <malloc_page_aligned>:

// Allocate a nbytes of memory, multiple of PAGE_SIZE, PAGE_SIZE aligned
// to be tested more!!!
void *malloc_page_aligned(unsigned int nbytes)
{
  103050:	55                   	push   %ebp
  103051:	89 e5                	mov    %esp,%ebp
  103053:	83 ec 18             	sub    $0x18,%esp
	block_meta_t *p, *n;
	void *m;
	KASSERT(nbytes); // > 0
  103056:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  10305a:	75 29                	jne    103085 <malloc_page_aligned+0x35>
  10305c:	83 ec 0c             	sub    $0xc,%esp
  10305f:	68 b3 00 00 00       	push   $0xb3
  103064:	68 dc 6b 10 00       	push   $0x106bdc
  103069:	68 00 6f 10 00       	push   $0x106f00
  10306e:	68 53 6e 10 00       	push   $0x106e53
  103073:	68 00 6c 10 00       	push   $0x106c00
  103078:	e8 2b d3 ff ff       	call   1003a8 <kprintf>
  10307d:	83 c4 20             	add    $0x20,%esp
  103080:	e8 56 d7 ff ff       	call   1007db <halt>
	KASSERT(!(nbytes & 0xFFF)); // is PAGE_SIZE aligned?
  103085:	8b 45 08             	mov    0x8(%ebp),%eax
  103088:	25 ff 0f 00 00       	and    $0xfff,%eax
  10308d:	85 c0                	test   %eax,%eax
  10308f:	74 29                	je     1030ba <malloc_page_aligned+0x6a>
  103091:	83 ec 0c             	sub    $0xc,%esp
  103094:	68 b4 00 00 00       	push   $0xb4
  103099:	68 dc 6b 10 00       	push   $0x106bdc
  10309e:	68 00 6f 10 00       	push   $0x106f00
  1030a3:	68 5a 6e 10 00       	push   $0x106e5a
  1030a8:	68 00 6c 10 00       	push   $0x106c00
  1030ad:	e8 f6 d2 ff ff       	call   1003a8 <kprintf>
  1030b2:	83 c4 20             	add    $0x20,%esp
  1030b5:	e8 21 d7 ff ff       	call   1007db <halt>
	unsigned int p_size = nbytes + PAGE_SIZE + sizeof(block_meta_t);
  1030ba:	8b 45 08             	mov    0x8(%ebp),%eax
  1030bd:	05 14 10 00 00       	add    $0x1014,%eax
  1030c2:	89 45 f0             	mov    %eax,-0x10(%ebp)
	m = malloc(p_size);
  1030c5:	83 ec 0c             	sub    $0xc,%esp
  1030c8:	ff 75 f0             	pushl  -0x10(%ebp)
  1030cb:	e8 39 fa ff ff       	call   102b09 <malloc>
  1030d0:	83 c4 10             	add    $0x10,%esp
  1030d3:	89 45 ec             	mov    %eax,-0x14(%ebp)
	// kprintf("Alloc at: %p, p_size: %d\n", m, p_size);
	if(!((unsigned int)m & 0xFFF)) {
  1030d6:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1030d9:	25 ff 0f 00 00       	and    $0xfff,%eax
  1030de:	85 c0                	test   %eax,%eax
  1030e0:	75 08                	jne    1030ea <malloc_page_aligned+0x9a>
		//kprintf("ALIGNED?\n");
		return m;
  1030e2:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1030e5:	e9 2e 01 00 00       	jmp    103218 <malloc_page_aligned+0x1c8>
	}
	p = (block_meta_t *) m - 1;
  1030ea:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1030ed:	83 e8 14             	sub    $0x14,%eax
  1030f0:	89 45 e8             	mov    %eax,-0x18(%ebp)
	n = (block_meta_t *)(((unsigned int)m & 0xFFFFF000) + PAGE_SIZE)-1;
  1030f3:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1030f6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  1030fb:	05 ec 0f 00 00       	add    $0xfec,%eax
  103100:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if((unsigned int)n < (unsigned int)m) {
  103103:	8b 55 f4             	mov    -0xc(%ebp),%edx
  103106:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103109:	39 c2                	cmp    %eax,%edx
  10310b:	73 10                	jae    10311d <malloc_page_aligned+0xcd>
		n = (block_meta_t *)(((unsigned int)m & 0xFFFFF000) + PAGE_SIZE * 2)-1;
  10310d:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103110:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  103115:	05 ec 1f 00 00       	add    $0x1fec,%eax
  10311a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}
	if((unsigned int)n < (unsigned int)m) {
  10311d:	8b 55 f4             	mov    -0xc(%ebp),%edx
  103120:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103123:	39 c2                	cmp    %eax,%edx
  103125:	73 39                	jae    103160 <malloc_page_aligned+0x110>
		kprintf("p:%p, m:%p, n:%p, n+1:%p, m+psize:%p\n", p,m,n,n+1,(unsigned int)m+p_size);
  103127:	8b 55 ec             	mov    -0x14(%ebp),%edx
  10312a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10312d:	01 c2                	add    %eax,%edx
  10312f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103132:	83 c0 14             	add    $0x14,%eax
  103135:	83 ec 08             	sub    $0x8,%esp
  103138:	52                   	push   %edx
  103139:	50                   	push   %eax
  10313a:	ff 75 f4             	pushl  -0xc(%ebp)
  10313d:	ff 75 ec             	pushl  -0x14(%ebp)
  103140:	ff 75 e8             	pushl  -0x18(%ebp)
  103143:	68 6c 6e 10 00       	push   $0x106e6c
  103148:	e8 5b d2 ff ff       	call   1003a8 <kprintf>
  10314d:	83 c4 20             	add    $0x20,%esp
		panic("n < m\n");
  103150:	83 ec 0c             	sub    $0xc,%esp
  103153:	68 92 6e 10 00       	push   $0x106e92
  103158:	e8 e7 d2 ff ff       	call   100444 <panic>
  10315d:	83 c4 10             	add    $0x10,%esp
	}
	if(((unsigned int)(n+1)+PAGE_SIZE) > ((unsigned int)m+p_size)) {
  103160:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103163:	83 c0 14             	add    $0x14,%eax
  103166:	8d 88 00 10 00 00    	lea    0x1000(%eax),%ecx
  10316c:	8b 55 ec             	mov    -0x14(%ebp),%edx
  10316f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103172:	01 d0                	add    %edx,%eax
  103174:	39 c1                	cmp    %eax,%ecx
  103176:	76 39                	jbe    1031b1 <malloc_page_aligned+0x161>
		kprintf("p:%p, m:%p, n:%p, n+1:%p, m+psize:%p\n", p,m,n,n+1,(unsigned int)m+p_size);
  103178:	8b 55 ec             	mov    -0x14(%ebp),%edx
  10317b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10317e:	01 c2                	add    %eax,%edx
  103180:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103183:	83 c0 14             	add    $0x14,%eax
  103186:	83 ec 08             	sub    $0x8,%esp
  103189:	52                   	push   %edx
  10318a:	50                   	push   %eax
  10318b:	ff 75 f4             	pushl  -0xc(%ebp)
  10318e:	ff 75 ec             	pushl  -0x14(%ebp)
  103191:	ff 75 e8             	pushl  -0x18(%ebp)
  103194:	68 6c 6e 10 00       	push   $0x106e6c
  103199:	e8 0a d2 ff ff       	call   1003a8 <kprintf>
  10319e:	83 c4 20             	add    $0x20,%esp
		panic("((n+1)+PAGE_SIZE) > m + p_size)\n");
  1031a1:	83 ec 0c             	sub    $0xc,%esp
  1031a4:	68 9c 6e 10 00       	push   $0x106e9c
  1031a9:	e8 96 d2 ff ff       	call   100444 <panic>
  1031ae:	83 c4 10             	add    $0x10,%esp
	}

	n->magic_head = MAGIC_HEAD;
  1031b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1031b4:	c7 00 de c0 ad de    	movl   $0xdeadc0de,(%eax)
	n->magic_end = MAGIC_END;
  1031ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1031bd:	c7 40 10 ba ba ad de 	movl   $0xdeadbaba,0x10(%eax)
	n->free = false;
  1031c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1031c7:	c6 40 08 00          	movb   $0x0,0x8(%eax)
	n->next = p->next;
  1031cb:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1031ce:	8b 50 0c             	mov    0xc(%eax),%edx
  1031d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1031d4:	89 50 0c             	mov    %edx,0xc(%eax)
	n->size = (unsigned int)m+p_size - (unsigned int)(n+1);
  1031d7:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1031da:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1031dd:	01 c2                	add    %eax,%edx
  1031df:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1031e2:	83 c0 14             	add    $0x14,%eax
  1031e5:	29 c2                	sub    %eax,%edx
  1031e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1031ea:	89 50 04             	mov    %edx,0x4(%eax)
	p->size = (unsigned int)n-(unsigned int)m;
  1031ed:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1031f0:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1031f3:	29 c2                	sub    %eax,%edx
  1031f5:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1031f8:	89 50 04             	mov    %edx,0x4(%eax)
	p->next = n;
  1031fb:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1031fe:	8b 55 f4             	mov    -0xc(%ebp),%edx
  103201:	89 50 0c             	mov    %edx,0xc(%eax)
	free(m);
  103204:	83 ec 0c             	sub    $0xc,%esp
  103207:	ff 75 ec             	pushl  -0x14(%ebp)
  10320a:	e8 8a fc ff ff       	call   102e99 <free>
  10320f:	83 c4 10             	add    $0x10,%esp
	return n+1;
  103212:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103215:	83 c0 14             	add    $0x14,%eax
}
  103218:	c9                   	leave  
  103219:	c3                   	ret    

0010321a <test_mem_1>:

bool test_mem_1()
{
  10321a:	55                   	push   %ebp
  10321b:	89 e5                	mov    %esp,%ebp
  10321d:	83 ec 18             	sub    $0x18,%esp
	unsigned int i;
	char *p;
	free(malloc(1));
  103220:	83 ec 0c             	sub    $0xc,%esp
  103223:	6a 01                	push   $0x1
  103225:	e8 df f8 ff ff       	call   102b09 <malloc>
  10322a:	83 c4 10             	add    $0x10,%esp
  10322d:	83 ec 0c             	sub    $0xc,%esp
  103230:	50                   	push   %eax
  103231:	e8 63 fc ff ff       	call   102e99 <free>
  103236:	83 c4 10             	add    $0x10,%esp
	int *k;
	k = (int *)malloc(10000 * sizeof(int));
  103239:	83 ec 0c             	sub    $0xc,%esp
  10323c:	68 40 9c 00 00       	push   $0x9c40
  103241:	e8 c3 f8 ff ff       	call   102b09 <malloc>
  103246:	83 c4 10             	add    $0x10,%esp
  103249:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//kprintf("Alloc\n");
	for (i = 4000; i < 5000; i++) {
  10324c:	c7 45 f4 a0 0f 00 00 	movl   $0xfa0,-0xc(%ebp)
  103253:	eb 3c                	jmp    103291 <test_mem_1+0x77>
		p = malloc(i);
  103255:	83 ec 0c             	sub    $0xc,%esp
  103258:	ff 75 f4             	pushl  -0xc(%ebp)
  10325b:	e8 a9 f8 ff ff       	call   102b09 <malloc>
  103260:	83 c4 10             	add    $0x10,%esp
  103263:	89 45 ec             	mov    %eax,-0x14(%ebp)
		memset(p, 'A', i);
  103266:	83 ec 04             	sub    $0x4,%esp
  103269:	ff 75 f4             	pushl  -0xc(%ebp)
  10326c:	6a 41                	push   $0x41
  10326e:	ff 75 ec             	pushl  -0x14(%ebp)
  103271:	e8 1a 10 00 00       	call   104290 <memset>
  103276:	83 c4 10             	add    $0x10,%esp
		k[i] = (unsigned int )p;
  103279:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10327c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  103283:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103286:	01 c2                	add    %eax,%edx
  103288:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10328b:	89 02                	mov    %eax,(%edx)
	char *p;
	free(malloc(1));
	int *k;
	k = (int *)malloc(10000 * sizeof(int));
	//kprintf("Alloc\n");
	for (i = 4000; i < 5000; i++) {
  10328d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
  103291:	81 7d f4 87 13 00 00 	cmpl   $0x1387,-0xc(%ebp)
  103298:	76 bb                	jbe    103255 <test_mem_1+0x3b>
		p = malloc(i);
		memset(p, 'A', i);
		k[i] = (unsigned int )p;
	}
	//kprintf("Freeing\n");
	for (i = 4000; i < 5000; i++) {
  10329a:	c7 45 f4 a0 0f 00 00 	movl   $0xfa0,-0xc(%ebp)
  1032a1:	eb 21                	jmp    1032c4 <test_mem_1+0xaa>
		free((void *)k[i]);
  1032a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1032a6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  1032ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1032b0:	01 d0                	add    %edx,%eax
  1032b2:	8b 00                	mov    (%eax),%eax
  1032b4:	83 ec 0c             	sub    $0xc,%esp
  1032b7:	50                   	push   %eax
  1032b8:	e8 dc fb ff ff       	call   102e99 <free>
  1032bd:	83 c4 10             	add    $0x10,%esp
		p = malloc(i);
		memset(p, 'A', i);
		k[i] = (unsigned int )p;
	}
	//kprintf("Freeing\n");
	for (i = 4000; i < 5000; i++) {
  1032c0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
  1032c4:	81 7d f4 87 13 00 00 	cmpl   $0x1387,-0xc(%ebp)
  1032cb:	76 d6                	jbe    1032a3 <test_mem_1+0x89>
		free((void *)k[i]);
	}
	free(k);
  1032cd:	83 ec 0c             	sub    $0xc,%esp
  1032d0:	ff 75 f0             	pushl  -0x10(%ebp)
  1032d3:	e8 c1 fb ff ff       	call   102e99 <free>
  1032d8:	83 c4 10             	add    $0x10,%esp
	if(first_block->next == NULL && first_block->size == heap->end_addr-heap->start_addr - sizeof(block_meta_t)) {
  1032db:	a1 00 c1 10 00       	mov    0x10c100,%eax
  1032e0:	8b 40 0c             	mov    0xc(%eax),%eax
  1032e3:	85 c0                	test   %eax,%eax
  1032e5:	75 29                	jne    103310 <test_mem_1+0xf6>
  1032e7:	a1 00 c1 10 00       	mov    0x10c100,%eax
  1032ec:	8b 50 04             	mov    0x4(%eax),%edx
  1032ef:	a1 44 63 10 00       	mov    0x106344,%eax
  1032f4:	8b 48 04             	mov    0x4(%eax),%ecx
  1032f7:	a1 44 63 10 00       	mov    0x106344,%eax
  1032fc:	8b 00                	mov    (%eax),%eax
  1032fe:	29 c1                	sub    %eax,%ecx
  103300:	89 c8                	mov    %ecx,%eax
  103302:	83 e8 14             	sub    $0x14,%eax
  103305:	39 c2                	cmp    %eax,%edx
  103307:	75 07                	jne    103310 <test_mem_1+0xf6>
		return true;
  103309:	b8 01 00 00 00       	mov    $0x1,%eax
  10330e:	eb 05                	jmp    103315 <test_mem_1+0xfb>
	}
	return false;
  103310:	b8 00 00 00 00       	mov    $0x0,%eax
}
  103315:	c9                   	leave  
  103316:	c3                   	ret    

00103317 <test_mem_2>:


bool test_mem_2()
{
  103317:	55                   	push   %ebp
  103318:	89 e5                	mov    %esp,%ebp
  10331a:	83 ec 18             	sub    $0x18,%esp
	void *i, *j, *p, *k;
	i = malloc(4000);
  10331d:	83 ec 0c             	sub    $0xc,%esp
  103320:	68 a0 0f 00 00       	push   $0xfa0
  103325:	e8 df f7 ff ff       	call   102b09 <malloc>
  10332a:	83 c4 10             	add    $0x10,%esp
  10332d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	p = malloc_page_aligned(2*PAGE_SIZE);
  103330:	83 ec 0c             	sub    $0xc,%esp
  103333:	68 00 20 00 00       	push   $0x2000
  103338:	e8 13 fd ff ff       	call   103050 <malloc_page_aligned>
  10333d:	83 c4 10             	add    $0x10,%esp
  103340:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memset(p, 'A', 2*PAGE_SIZE);
  103343:	83 ec 04             	sub    $0x4,%esp
  103346:	68 00 20 00 00       	push   $0x2000
  10334b:	6a 41                	push   $0x41
  10334d:	ff 75 f0             	pushl  -0x10(%ebp)
  103350:	e8 3b 0f 00 00       	call   104290 <memset>
  103355:	83 c4 10             	add    $0x10,%esp
	k = malloc_page_aligned(PAGE_SIZE);
  103358:	83 ec 0c             	sub    $0xc,%esp
  10335b:	68 00 10 00 00       	push   $0x1000
  103360:	e8 eb fc ff ff       	call   103050 <malloc_page_aligned>
  103365:	83 c4 10             	add    $0x10,%esp
  103368:	89 45 ec             	mov    %eax,-0x14(%ebp)
	memset(k, 'B', PAGE_SIZE);
  10336b:	83 ec 04             	sub    $0x4,%esp
  10336e:	68 00 10 00 00       	push   $0x1000
  103373:	6a 42                	push   $0x42
  103375:	ff 75 ec             	pushl  -0x14(%ebp)
  103378:	e8 13 0f 00 00       	call   104290 <memset>
  10337d:	83 c4 10             	add    $0x10,%esp
	// debug_dump_list(first_block);
	free(p);
  103380:	83 ec 0c             	sub    $0xc,%esp
  103383:	ff 75 f0             	pushl  -0x10(%ebp)
  103386:	e8 0e fb ff ff       	call   102e99 <free>
  10338b:	83 c4 10             	add    $0x10,%esp
	free(k);
  10338e:	83 ec 0c             	sub    $0xc,%esp
  103391:	ff 75 ec             	pushl  -0x14(%ebp)
  103394:	e8 00 fb ff ff       	call   102e99 <free>
  103399:	83 c4 10             	add    $0x10,%esp
	j = malloc(10);
  10339c:	83 ec 0c             	sub    $0xc,%esp
  10339f:	6a 0a                	push   $0xa
  1033a1:	e8 63 f7 ff ff       	call   102b09 <malloc>
  1033a6:	83 c4 10             	add    $0x10,%esp
  1033a9:	89 45 e8             	mov    %eax,-0x18(%ebp)
	free(i);
  1033ac:	83 ec 0c             	sub    $0xc,%esp
  1033af:	ff 75 f4             	pushl  -0xc(%ebp)
  1033b2:	e8 e2 fa ff ff       	call   102e99 <free>
  1033b7:	83 c4 10             	add    $0x10,%esp
	free(j);
  1033ba:	83 ec 0c             	sub    $0xc,%esp
  1033bd:	ff 75 e8             	pushl  -0x18(%ebp)
  1033c0:	e8 d4 fa ff ff       	call   102e99 <free>
  1033c5:	83 c4 10             	add    $0x10,%esp
	if(first_block->next == NULL && first_block->size == heap->end_addr-heap->start_addr - sizeof(block_meta_t)) {
  1033c8:	a1 00 c1 10 00       	mov    0x10c100,%eax
  1033cd:	8b 40 0c             	mov    0xc(%eax),%eax
  1033d0:	85 c0                	test   %eax,%eax
  1033d2:	75 29                	jne    1033fd <test_mem_2+0xe6>
  1033d4:	a1 00 c1 10 00       	mov    0x10c100,%eax
  1033d9:	8b 50 04             	mov    0x4(%eax),%edx
  1033dc:	a1 44 63 10 00       	mov    0x106344,%eax
  1033e1:	8b 48 04             	mov    0x4(%eax),%ecx
  1033e4:	a1 44 63 10 00       	mov    0x106344,%eax
  1033e9:	8b 00                	mov    (%eax),%eax
  1033eb:	29 c1                	sub    %eax,%ecx
  1033ed:	89 c8                	mov    %ecx,%eax
  1033ef:	83 e8 14             	sub    $0x14,%eax
  1033f2:	39 c2                	cmp    %eax,%edx
  1033f4:	75 07                	jne    1033fd <test_mem_2+0xe6>
		return true;
  1033f6:	b8 01 00 00 00       	mov    $0x1,%eax
  1033fb:	eb 05                	jmp    103402 <test_mem_2+0xeb>
	}
	return false;
  1033fd:	b8 00 00 00 00       	mov    $0x0,%eax
}
  103402:	c9                   	leave  
  103403:	c3                   	ret    

00103404 <test_mem_3>:
bool test_mem_3() {
  103404:	55                   	push   %ebp
  103405:	89 e5                	mov    %esp,%ebp
  103407:	53                   	push   %ebx
  103408:	83 ec 14             	sub    $0x14,%esp
	unsigned int *p = malloc_page_aligned(PAGE_SIZE*3);
  10340b:	83 ec 0c             	sub    $0xc,%esp
  10340e:	68 00 30 00 00       	push   $0x3000
  103413:	e8 38 fc ff ff       	call   103050 <malloc_page_aligned>
  103418:	83 c4 10             	add    $0x10,%esp
  10341b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	virt_t *table;
	int dir_idx = ((unsigned int)p / PAGE_SIZE) / 1024;
  10341e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103421:	c1 e8 16             	shr    $0x16,%eax
  103424:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int tbl_idx = ((unsigned int)p / PAGE_SIZE) % 1024;
  103427:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10342a:	c1 e8 0c             	shr    $0xc,%eax
  10342d:	25 ff 03 00 00       	and    $0x3ff,%eax
  103432:	89 45 ec             	mov    %eax,-0x14(%ebp)
	table = (virt_t *) (PTABLES_ADDR + dir_idx * PAGE_SIZE);
  103435:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103438:	c1 e0 0c             	shl    $0xc,%eax
  10343b:	2d 00 00 40 00       	sub    $0x400000,%eax
  103440:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if((table[tbl_idx] & 0xFFFFF000) == (unsigned int)virt_to_phys((virt_t)p)) {
  103443:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103446:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  10344d:	8b 45 e8             	mov    -0x18(%ebp),%eax
  103450:	01 d0                	add    %edx,%eax
  103452:	8b 00                	mov    (%eax),%eax
  103454:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  103459:	89 c3                	mov    %eax,%ebx
  10345b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10345e:	83 ec 0c             	sub    $0xc,%esp
  103461:	50                   	push   %eax
  103462:	e8 ed ec ff ff       	call   102154 <virt_to_phys>
  103467:	83 c4 10             	add    $0x10,%esp
  10346a:	39 c3                	cmp    %eax,%ebx
  10346c:	75 15                	jne    103483 <test_mem_3+0x7f>
		free(p);
  10346e:	83 ec 0c             	sub    $0xc,%esp
  103471:	ff 75 f4             	pushl  -0xc(%ebp)
  103474:	e8 20 fa ff ff       	call   102e99 <free>
  103479:	83 c4 10             	add    $0x10,%esp
		// kprintf("same: %p, %p\n", table[tbl_idx] & 0xFFFFF000, virt_to_phys(p));
		return true;
  10347c:	b8 01 00 00 00       	mov    $0x1,%eax
  103481:	eb 13                	jmp    103496 <test_mem_3+0x92>
	}
	free(p);
  103483:	83 ec 0c             	sub    $0xc,%esp
  103486:	ff 75 f4             	pushl  -0xc(%ebp)
  103489:	e8 0b fa ff ff       	call   102e99 <free>
  10348e:	83 c4 10             	add    $0x10,%esp
	return false;
  103491:	b8 00 00 00 00       	mov    $0x0,%eax
}
  103496:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  103499:	c9                   	leave  
  10349a:	c3                   	ret    

0010349b <heap_init>:

void heap_init() {
  10349b:	55                   	push   %ebp
  10349c:	89 e5                	mov    %esp,%ebp
  10349e:	83 ec 08             	sub    $0x8,%esp

	//kprintf("In heap \n");
	KASSERT((HEAP_INITIAL_SIZE / PAGE_SIZE) > 0);
	if (!heap) {
  1034a1:	a1 44 63 10 00       	mov    0x106344,%eax
  1034a6:	85 c0                	test   %eax,%eax
  1034a8:	75 10                	jne    1034ba <heap_init+0x1f>
		panic("Heap is not initialized\n");
  1034aa:	83 ec 0c             	sub    $0xc,%esp
  1034ad:	68 bd 6e 10 00       	push   $0x106ebd
  1034b2:	e8 8d cf ff ff       	call   100444 <panic>
  1034b7:	83 c4 10             	add    $0x10,%esp
	}
	init_first_block();
  1034ba:	e8 e6 f5 ff ff       	call   102aa5 <init_first_block>
	// kprintf("test_mem_2 %s\n", test_mem_2() ? "passed":"FAILED");
	// kprintf("test_mem_3 %s\n", test_mem_3() ? "passed":"FAILED");
	// heap_dump();
	// heap_contract();
	// heap_dump();
	return;
  1034bf:	90                   	nop
}
  1034c0:	c9                   	leave  
  1034c1:	c3                   	ret    

001034c2 <read_fs>:
#include "console.h"
#include "kheap.h"
#include "vfs.h"


unsigned int read_fs(fs_node_t *node, unsigned int offset, unsigned int size, char *buffer) {
  1034c2:	55                   	push   %ebp
  1034c3:	89 e5                	mov    %esp,%ebp
  1034c5:	83 ec 08             	sub    $0x8,%esp
	return node->read != 0 ? node->read(node, offset, size, buffer) : 0;
  1034c8:	8b 45 08             	mov    0x8(%ebp),%eax
  1034cb:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
  1034d1:	85 c0                	test   %eax,%eax
  1034d3:	74 1c                	je     1034f1 <read_fs+0x2f>
  1034d5:	8b 45 08             	mov    0x8(%ebp),%eax
  1034d8:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
  1034de:	ff 75 14             	pushl  0x14(%ebp)
  1034e1:	ff 75 10             	pushl  0x10(%ebp)
  1034e4:	ff 75 0c             	pushl  0xc(%ebp)
  1034e7:	ff 75 08             	pushl  0x8(%ebp)
  1034ea:	ff d0                	call   *%eax
  1034ec:	83 c4 10             	add    $0x10,%esp
  1034ef:	eb 05                	jmp    1034f6 <read_fs+0x34>
  1034f1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  1034f6:	c9                   	leave  
  1034f7:	c3                   	ret    

001034f8 <write_fs>:

unsigned int write_fs(fs_node_t *node, unsigned int offset, unsigned int size, char *buffer) {
  1034f8:	55                   	push   %ebp
  1034f9:	89 e5                	mov    %esp,%ebp
  1034fb:	83 ec 08             	sub    $0x8,%esp
	return node->write != 0 ? node->write(node, offset, size, buffer) : 0;
  1034fe:	8b 45 08             	mov    0x8(%ebp),%eax
  103501:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
  103507:	85 c0                	test   %eax,%eax
  103509:	74 1c                	je     103527 <write_fs+0x2f>
  10350b:	8b 45 08             	mov    0x8(%ebp),%eax
  10350e:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
  103514:	ff 75 14             	pushl  0x14(%ebp)
  103517:	ff 75 10             	pushl  0x10(%ebp)
  10351a:	ff 75 0c             	pushl  0xc(%ebp)
  10351d:	ff 75 08             	pushl  0x8(%ebp)
  103520:	ff d0                	call   *%eax
  103522:	83 c4 10             	add    $0x10,%esp
  103525:	eb 05                	jmp    10352c <write_fs+0x34>
  103527:	b8 00 00 00 00       	mov    $0x0,%eax
}
  10352c:	c9                   	leave  
  10352d:	c3                   	ret    

0010352e <open_fs>:

void open_fs(fs_node_t *node, unsigned int flags) {
  10352e:	55                   	push   %ebp
  10352f:	89 e5                	mov    %esp,%ebp
  103531:	83 ec 08             	sub    $0x8,%esp
	if (node->open != NULL) {
  103534:	8b 45 08             	mov    0x8(%ebp),%eax
  103537:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
  10353d:	85 c0                	test   %eax,%eax
  10353f:	74 18                	je     103559 <open_fs+0x2b>
		return node->open(node, flags);
  103541:	8b 45 08             	mov    0x8(%ebp),%eax
  103544:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
  10354a:	83 ec 08             	sub    $0x8,%esp
  10354d:	ff 75 0c             	pushl  0xc(%ebp)
  103550:	ff 75 08             	pushl  0x8(%ebp)
  103553:	ff d0                	call   *%eax
  103555:	83 c4 10             	add    $0x10,%esp
  103558:	90                   	nop
	}
}
  103559:	c9                   	leave  
  10355a:	c3                   	ret    

0010355b <close_fs>:

void close_fs(fs_node_t *node) {
  10355b:	55                   	push   %ebp
  10355c:	89 e5                	mov    %esp,%ebp
  10355e:	83 ec 08             	sub    $0x8,%esp
	if (node->close != NULL) {
  103561:	8b 45 08             	mov    0x8(%ebp),%eax
  103564:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
  10356a:	85 c0                	test   %eax,%eax
  10356c:	74 15                	je     103583 <close_fs+0x28>
		return node->close(node);
  10356e:	8b 45 08             	mov    0x8(%ebp),%eax
  103571:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
  103577:	83 ec 0c             	sub    $0xc,%esp
  10357a:	ff 75 08             	pushl  0x8(%ebp)
  10357d:	ff d0                	call   *%eax
  10357f:	83 c4 10             	add    $0x10,%esp
  103582:	90                   	nop
	}
}
  103583:	c9                   	leave  
  103584:	c3                   	ret    

00103585 <readdir_fs>:

struct dirent *readdir_fs(fs_node_t *node, unsigned int index) {
  103585:	55                   	push   %ebp
  103586:	89 e5                	mov    %esp,%ebp
  103588:	83 ec 08             	sub    $0x8,%esp
	if ((node->flags & FS_DIRECTORY) && node->readdir != 0) {
  10358b:	8b 45 08             	mov    0x8(%ebp),%eax
  10358e:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
  103594:	83 e0 02             	and    $0x2,%eax
  103597:	85 c0                	test   %eax,%eax
  103599:	74 26                	je     1035c1 <readdir_fs+0x3c>
  10359b:	8b 45 08             	mov    0x8(%ebp),%eax
  10359e:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
  1035a4:	85 c0                	test   %eax,%eax
  1035a6:	74 19                	je     1035c1 <readdir_fs+0x3c>
		return node->readdir(node, index);
  1035a8:	8b 45 08             	mov    0x8(%ebp),%eax
  1035ab:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
  1035b1:	83 ec 08             	sub    $0x8,%esp
  1035b4:	ff 75 0c             	pushl  0xc(%ebp)
  1035b7:	ff 75 08             	pushl  0x8(%ebp)
  1035ba:	ff d0                	call   *%eax
  1035bc:	83 c4 10             	add    $0x10,%esp
  1035bf:	eb 05                	jmp    1035c6 <readdir_fs+0x41>
	} else {
		return false;
  1035c1:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
  1035c6:	c9                   	leave  
  1035c7:	c3                   	ret    

001035c8 <finddir_fs>:

fs_node_t *finddir_fs(fs_node_t *node, char *name) {
  1035c8:	55                   	push   %ebp
  1035c9:	89 e5                	mov    %esp,%ebp
  1035cb:	83 ec 08             	sub    $0x8,%esp
	// Is the node a directory, and does it have a callback?
	if ((node->flags & FS_DIRECTORY) && node->finddir != 0)
  1035ce:	8b 45 08             	mov    0x8(%ebp),%eax
  1035d1:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
  1035d7:	83 e0 02             	and    $0x2,%eax
  1035da:	85 c0                	test   %eax,%eax
  1035dc:	74 26                	je     103604 <finddir_fs+0x3c>
  1035de:	8b 45 08             	mov    0x8(%ebp),%eax
  1035e1:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
  1035e7:	85 c0                	test   %eax,%eax
  1035e9:	74 19                	je     103604 <finddir_fs+0x3c>
		return node->finddir(node, name);
  1035eb:	8b 45 08             	mov    0x8(%ebp),%eax
  1035ee:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
  1035f4:	83 ec 08             	sub    $0x8,%esp
  1035f7:	ff 75 0c             	pushl  0xc(%ebp)
  1035fa:	ff 75 08             	pushl  0x8(%ebp)
  1035fd:	ff d0                	call   *%eax
  1035ff:	83 c4 10             	add    $0x10,%esp
  103602:	eb 05                	jmp    103609 <finddir_fs+0x41>
	else
		return false;
  103604:	b8 00 00 00 00       	mov    $0x0,%eax
}
  103609:	c9                   	leave  
  10360a:	c3                   	ret    

0010360b <initrd_read>:
unsigned int nroot_nodes;			// Number of file nodes.

struct dirent dirent;


unsigned int initrd_read(struct fs_node *node, unsigned int offset, unsigned int size, char *buffer) {
  10360b:	55                   	push   %ebp
  10360c:	89 e5                	mov    %esp,%ebp
  10360e:	57                   	push   %edi
  10360f:	56                   	push   %esi
  103610:	53                   	push   %ebx
  103611:	83 ec 5c             	sub    $0x5c,%esp
	initrd_file_header_t header = file_headers[node->inode];
  103614:	8b 15 84 cf 10 00    	mov    0x10cf84,%edx
  10361a:	8b 45 08             	mov    0x8(%ebp),%eax
  10361d:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
  103623:	6b c0 4c             	imul   $0x4c,%eax,%eax
  103626:	01 c2                	add    %eax,%edx
  103628:	8d 45 9c             	lea    -0x64(%ebp),%eax
  10362b:	89 d3                	mov    %edx,%ebx
  10362d:	ba 13 00 00 00       	mov    $0x13,%edx
  103632:	89 c7                	mov    %eax,%edi
  103634:	89 de                	mov    %ebx,%esi
  103636:	89 d1                	mov    %edx,%ecx
  103638:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	if (offset > header.length) {
  10363a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10363d:	3b 45 0c             	cmp    0xc(%ebp),%eax
  103640:	73 07                	jae    103649 <initrd_read+0x3e>
		return 0;
  103642:	b8 00 00 00 00       	mov    $0x0,%eax
  103647:	eb 35                	jmp    10367e <initrd_read+0x73>
	}
	if (offset + size > header.length) {
  103649:	8b 55 0c             	mov    0xc(%ebp),%edx
  10364c:	8b 45 10             	mov    0x10(%ebp),%eax
  10364f:	01 c2                	add    %eax,%edx
  103651:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  103654:	39 c2                	cmp    %eax,%edx
  103656:	76 09                	jbe    103661 <initrd_read+0x56>
		size = header.length - offset;
  103658:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10365b:	2b 45 0c             	sub    0xc(%ebp),%eax
  10365e:	89 45 10             	mov    %eax,0x10(%ebp)
	}
	memcpy(buffer, (char *) header.offset + offset, size);
  103661:	8b 55 e0             	mov    -0x20(%ebp),%edx
  103664:	8b 45 0c             	mov    0xc(%ebp),%eax
  103667:	01 d0                	add    %edx,%eax
  103669:	83 ec 04             	sub    $0x4,%esp
  10366c:	ff 75 10             	pushl  0x10(%ebp)
  10366f:	50                   	push   %eax
  103670:	ff 75 14             	pushl  0x14(%ebp)
  103673:	e8 48 0b 00 00       	call   1041c0 <memcpy>
  103678:	83 c4 10             	add    $0x10,%esp
	return size;
  10367b:	8b 45 10             	mov    0x10(%ebp),%eax
}
  10367e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  103681:	5b                   	pop    %ebx
  103682:	5e                   	pop    %esi
  103683:	5f                   	pop    %edi
  103684:	5d                   	pop    %ebp
  103685:	c3                   	ret    

00103686 <initrd_readdir>:

//void initrd_open(struct fs_node *node, unsigned int flags);

//void initrd_close(struct fs_node *node);

struct dirent *initrd_readdir(struct fs_node *node, unsigned int index) {
  103686:	55                   	push   %ebp
  103687:	89 e5                	mov    %esp,%ebp
  103689:	83 ec 08             	sub    $0x8,%esp
	if (node == initrd_root && index == 0) {
  10368c:	a1 88 cf 10 00       	mov    0x10cf88,%eax
  103691:	39 45 08             	cmp    %eax,0x8(%ebp)
  103694:	75 36                	jne    1036cc <initrd_readdir+0x46>
  103696:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  10369a:	75 30                	jne    1036cc <initrd_readdir+0x46>
		strcpy(dirent.name, "dev");
  10369c:	83 ec 08             	sub    $0x8,%esp
  10369f:	68 14 6f 10 00       	push   $0x106f14
  1036a4:	68 00 cf 10 00       	push   $0x10cf00
  1036a9:	e8 42 0b 00 00       	call   1041f0 <strcpy>
  1036ae:	83 c4 10             	add    $0x10,%esp
		dirent.name[3] = 0;
  1036b1:	c6 05 03 cf 10 00 00 	movb   $0x0,0x10cf03
		dirent.inode = 0;
  1036b8:	c7 05 80 cf 10 00 00 	movl   $0x0,0x10cf80
  1036bf:	00 00 00 
		return &dirent;
  1036c2:	b8 00 cf 10 00       	mov    $0x10cf00,%eax
  1036c7:	e9 8c 00 00 00       	jmp    103758 <initrd_readdir+0xd2>
	}
	if(index-1 >=nroot_nodes) {
  1036cc:	8b 45 0c             	mov    0xc(%ebp),%eax
  1036cf:	8d 50 ff             	lea    -0x1(%eax),%edx
  1036d2:	a1 c0 ce 10 00       	mov    0x10cec0,%eax
  1036d7:	39 c2                	cmp    %eax,%edx
  1036d9:	72 07                	jb     1036e2 <initrd_readdir+0x5c>
		return 0;
  1036db:	b8 00 00 00 00       	mov    $0x0,%eax
  1036e0:	eb 76                	jmp    103758 <initrd_readdir+0xd2>
	}
	strcpy(dirent.name, root_nodes[index-1].name);
  1036e2:	a1 8c cf 10 00       	mov    0x10cf8c,%eax
  1036e7:	8b 55 0c             	mov    0xc(%ebp),%edx
  1036ea:	69 d2 b8 00 00 00    	imul   $0xb8,%edx,%edx
  1036f0:	81 ea b8 00 00 00    	sub    $0xb8,%edx
  1036f6:	01 d0                	add    %edx,%eax
  1036f8:	83 ec 08             	sub    $0x8,%esp
  1036fb:	50                   	push   %eax
  1036fc:	68 00 cf 10 00       	push   $0x10cf00
  103701:	e8 ea 0a 00 00       	call   1041f0 <strcpy>
  103706:	83 c4 10             	add    $0x10,%esp
	dirent.name[strlen(root_nodes[index-1].name)] = 0;
  103709:	a1 8c cf 10 00       	mov    0x10cf8c,%eax
  10370e:	8b 55 0c             	mov    0xc(%ebp),%edx
  103711:	69 d2 b8 00 00 00    	imul   $0xb8,%edx,%edx
  103717:	81 ea b8 00 00 00    	sub    $0xb8,%edx
  10371d:	01 d0                	add    %edx,%eax
  10371f:	83 ec 0c             	sub    $0xc,%esp
  103722:	50                   	push   %eax
  103723:	e8 f8 0a 00 00       	call   104220 <strlen>
  103728:	83 c4 10             	add    $0x10,%esp
  10372b:	c6 80 00 cf 10 00 00 	movb   $0x0,0x10cf00(%eax)
	dirent.inode = root_nodes[index-1].inode;
  103732:	a1 8c cf 10 00       	mov    0x10cf8c,%eax
  103737:	8b 55 0c             	mov    0xc(%ebp),%edx
  10373a:	69 d2 b8 00 00 00    	imul   $0xb8,%edx,%edx
  103740:	81 ea b8 00 00 00    	sub    $0xb8,%edx
  103746:	01 d0                	add    %edx,%eax
  103748:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
  10374e:	a3 80 cf 10 00       	mov    %eax,0x10cf80
	return &dirent;
  103753:	b8 00 cf 10 00       	mov    $0x10cf00,%eax
}
  103758:	c9                   	leave  
  103759:	c3                   	ret    

0010375a <initrd_finddir>:

struct fs_node *initrd_finddir(struct fs_node *node, char *name) {
  10375a:	55                   	push   %ebp
  10375b:	89 e5                	mov    %esp,%ebp
  10375d:	83 ec 18             	sub    $0x18,%esp
	if(node == initrd_root && !strcmp(name, "dev")) {
  103760:	a1 88 cf 10 00       	mov    0x10cf88,%eax
  103765:	39 45 08             	cmp    %eax,0x8(%ebp)
  103768:	75 1e                	jne    103788 <initrd_finddir+0x2e>
  10376a:	83 ec 08             	sub    $0x8,%esp
  10376d:	68 14 6f 10 00       	push   $0x106f14
  103772:	ff 75 0c             	pushl  0xc(%ebp)
  103775:	e8 c6 0a 00 00       	call   104240 <strcmp>
  10377a:	83 c4 10             	add    $0x10,%esp
  10377d:	85 c0                	test   %eax,%eax
  10377f:	75 07                	jne    103788 <initrd_finddir+0x2e>
		return initrd_dev;
  103781:	a1 c4 ce 10 00       	mov    0x10cec4,%eax
  103786:	eb 53                	jmp    1037db <initrd_finddir+0x81>
	}
	unsigned int i;
	for (i = 0; i < nroot_nodes; i++) {
  103788:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  10378f:	eb 3b                	jmp    1037cc <initrd_finddir+0x72>
		if(!strcmp(name, root_nodes[i].name)) {
  103791:	8b 15 8c cf 10 00    	mov    0x10cf8c,%edx
  103797:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10379a:	69 c0 b8 00 00 00    	imul   $0xb8,%eax,%eax
  1037a0:	01 d0                	add    %edx,%eax
  1037a2:	83 ec 08             	sub    $0x8,%esp
  1037a5:	50                   	push   %eax
  1037a6:	ff 75 0c             	pushl  0xc(%ebp)
  1037a9:	e8 92 0a 00 00       	call   104240 <strcmp>
  1037ae:	83 c4 10             	add    $0x10,%esp
  1037b1:	85 c0                	test   %eax,%eax
  1037b3:	75 13                	jne    1037c8 <initrd_finddir+0x6e>
			return &root_nodes[i];
  1037b5:	8b 15 8c cf 10 00    	mov    0x10cf8c,%edx
  1037bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1037be:	69 c0 b8 00 00 00    	imul   $0xb8,%eax,%eax
  1037c4:	01 d0                	add    %edx,%eax
  1037c6:	eb 13                	jmp    1037db <initrd_finddir+0x81>
struct fs_node *initrd_finddir(struct fs_node *node, char *name) {
	if(node == initrd_root && !strcmp(name, "dev")) {
		return initrd_dev;
	}
	unsigned int i;
	for (i = 0; i < nroot_nodes; i++) {
  1037c8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
  1037cc:	a1 c0 ce 10 00       	mov    0x10cec0,%eax
  1037d1:	39 45 f4             	cmp    %eax,-0xc(%ebp)
  1037d4:	72 bb                	jb     103791 <initrd_finddir+0x37>
		if(!strcmp(name, root_nodes[i].name)) {
			return &root_nodes[i];
		}
	}
	return 0;
  1037d6:	b8 00 00 00 00       	mov    $0x0,%eax
}
  1037db:	c9                   	leave  
  1037dc:	c3                   	ret    

001037dd <initrd_init>:


fs_node_t *initrd_init(unsigned int location) {
  1037dd:	55                   	push   %ebp
  1037de:	89 e5                	mov    %esp,%ebp
  1037e0:	56                   	push   %esi
  1037e1:	53                   	push   %ebx
  1037e2:	83 ec 10             	sub    $0x10,%esp
	static bool initrd_inited = false;
	if(initrd_inited) {
  1037e5:	0f b6 05 b0 b0 10 00 	movzbl 0x10b0b0,%eax
  1037ec:	84 c0                	test   %al,%al
  1037ee:	74 0a                	je     1037fa <initrd_init+0x1d>
		return initrd_root;
  1037f0:	a1 88 cf 10 00       	mov    0x10cf88,%eax
  1037f5:	e9 51 04 00 00       	jmp    103c4b <initrd_init+0x46e>
	}

	kprintf("Initrd init\n");
  1037fa:	83 ec 0c             	sub    $0xc,%esp
  1037fd:	68 18 6f 10 00       	push   $0x106f18
  103802:	e8 a1 cb ff ff       	call   1003a8 <kprintf>
  103807:	83 c4 10             	add    $0x10,%esp
	// initialise the root node
	initrd_root = (fs_node_t *) malloc(sizeof(fs_node_t));
  10380a:	83 ec 0c             	sub    $0xc,%esp
  10380d:	68 b8 00 00 00       	push   $0xb8
  103812:	e8 f2 f2 ff ff       	call   102b09 <malloc>
  103817:	83 c4 10             	add    $0x10,%esp
  10381a:	a3 88 cf 10 00       	mov    %eax,0x10cf88
	strcpy(initrd_root->name, "initrd");
  10381f:	a1 88 cf 10 00       	mov    0x10cf88,%eax
  103824:	83 ec 08             	sub    $0x8,%esp
  103827:	68 25 6f 10 00       	push   $0x106f25
  10382c:	50                   	push   %eax
  10382d:	e8 be 09 00 00       	call   1041f0 <strcpy>
  103832:	83 c4 10             	add    $0x10,%esp
	initrd_root->mask = initrd_root->uid = initrd_root->gid = initrd_root->length = initrd_root->inode = 0;
  103835:	8b 35 88 cf 10 00    	mov    0x10cf88,%esi
  10383b:	a1 88 cf 10 00       	mov    0x10cf88,%eax
  103840:	8b 15 88 cf 10 00    	mov    0x10cf88,%edx
  103846:	8b 0d 88 cf 10 00    	mov    0x10cf88,%ecx
  10384c:	8b 1d 88 cf 10 00    	mov    0x10cf88,%ebx
  103852:	c7 83 90 00 00 00 00 	movl   $0x0,0x90(%ebx)
  103859:	00 00 00 
  10385c:	8b 9b 90 00 00 00    	mov    0x90(%ebx),%ebx
  103862:	89 99 94 00 00 00    	mov    %ebx,0x94(%ecx)
  103868:	8b 89 94 00 00 00    	mov    0x94(%ecx),%ecx
  10386e:	89 8a 88 00 00 00    	mov    %ecx,0x88(%edx)
  103874:	8b 92 88 00 00 00    	mov    0x88(%edx),%edx
  10387a:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
  103880:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
  103886:	89 86 80 00 00 00    	mov    %eax,0x80(%esi)
	initrd_root->flags = FS_DIRECTORY;
  10388c:	a1 88 cf 10 00       	mov    0x10cf88,%eax
  103891:	c7 80 8c 00 00 00 02 	movl   $0x2,0x8c(%eax)
  103898:	00 00 00 
	initrd_root->read = 0;
  10389b:	a1 88 cf 10 00       	mov    0x10cf88,%eax
  1038a0:	c7 80 9c 00 00 00 00 	movl   $0x0,0x9c(%eax)
  1038a7:	00 00 00 
	initrd_root->write = 0;
  1038aa:	a1 88 cf 10 00       	mov    0x10cf88,%eax
  1038af:	c7 80 a0 00 00 00 00 	movl   $0x0,0xa0(%eax)
  1038b6:	00 00 00 
	initrd_root->open = 0;
  1038b9:	a1 88 cf 10 00       	mov    0x10cf88,%eax
  1038be:	c7 80 a4 00 00 00 00 	movl   $0x0,0xa4(%eax)
  1038c5:	00 00 00 
	initrd_root->close = 0;
  1038c8:	a1 88 cf 10 00       	mov    0x10cf88,%eax
  1038cd:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
  1038d4:	00 00 00 
	initrd_root->readdir = &initrd_readdir;
  1038d7:	a1 88 cf 10 00       	mov    0x10cf88,%eax
  1038dc:	c7 80 ac 00 00 00 86 	movl   $0x103686,0xac(%eax)
  1038e3:	36 10 00 
	initrd_root->finddir = &initrd_finddir;
  1038e6:	a1 88 cf 10 00       	mov    0x10cf88,%eax
  1038eb:	c7 80 b0 00 00 00 5a 	movl   $0x10375a,0xb0(%eax)
  1038f2:	37 10 00 
	initrd_root->ptr = 0;
  1038f5:	a1 88 cf 10 00       	mov    0x10cf88,%eax
  1038fa:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
  103901:	00 00 00 
	initrd_root->impl = 0;
  103904:	a1 88 cf 10 00       	mov    0x10cf88,%eax
  103909:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
  103910:	00 00 00 

	// initialise /dev node //
	initrd_dev = (fs_node_t *) malloc(sizeof(fs_node_t));
  103913:	83 ec 0c             	sub    $0xc,%esp
  103916:	68 b8 00 00 00       	push   $0xb8
  10391b:	e8 e9 f1 ff ff       	call   102b09 <malloc>
  103920:	83 c4 10             	add    $0x10,%esp
  103923:	a3 c4 ce 10 00       	mov    %eax,0x10cec4
	strcpy(initrd_dev->name, "dev");
  103928:	a1 c4 ce 10 00       	mov    0x10cec4,%eax
  10392d:	83 ec 08             	sub    $0x8,%esp
  103930:	68 14 6f 10 00       	push   $0x106f14
  103935:	50                   	push   %eax
  103936:	e8 b5 08 00 00       	call   1041f0 <strcpy>
  10393b:	83 c4 10             	add    $0x10,%esp
	initrd_dev->mask = initrd_dev->uid = initrd_dev->gid = initrd_dev->length = initrd_dev->inode = 0;
  10393e:	8b 35 c4 ce 10 00    	mov    0x10cec4,%esi
  103944:	a1 c4 ce 10 00       	mov    0x10cec4,%eax
  103949:	8b 15 c4 ce 10 00    	mov    0x10cec4,%edx
  10394f:	8b 0d c4 ce 10 00    	mov    0x10cec4,%ecx
  103955:	8b 1d c4 ce 10 00    	mov    0x10cec4,%ebx
  10395b:	c7 83 90 00 00 00 00 	movl   $0x0,0x90(%ebx)
  103962:	00 00 00 
  103965:	8b 9b 90 00 00 00    	mov    0x90(%ebx),%ebx
  10396b:	89 99 94 00 00 00    	mov    %ebx,0x94(%ecx)
  103971:	8b 89 94 00 00 00    	mov    0x94(%ecx),%ecx
  103977:	89 8a 88 00 00 00    	mov    %ecx,0x88(%edx)
  10397d:	8b 92 88 00 00 00    	mov    0x88(%edx),%edx
  103983:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
  103989:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
  10398f:	89 86 80 00 00 00    	mov    %eax,0x80(%esi)
	initrd_dev->flags = FS_DIRECTORY;
  103995:	a1 c4 ce 10 00       	mov    0x10cec4,%eax
  10399a:	c7 80 8c 00 00 00 02 	movl   $0x2,0x8c(%eax)
  1039a1:	00 00 00 
	initrd_dev->read = 0;
  1039a4:	a1 c4 ce 10 00       	mov    0x10cec4,%eax
  1039a9:	c7 80 9c 00 00 00 00 	movl   $0x0,0x9c(%eax)
  1039b0:	00 00 00 
	initrd_dev->write = 0;
  1039b3:	a1 c4 ce 10 00       	mov    0x10cec4,%eax
  1039b8:	c7 80 a0 00 00 00 00 	movl   $0x0,0xa0(%eax)
  1039bf:	00 00 00 
	initrd_dev->open = 0;
  1039c2:	a1 c4 ce 10 00       	mov    0x10cec4,%eax
  1039c7:	c7 80 a4 00 00 00 00 	movl   $0x0,0xa4(%eax)
  1039ce:	00 00 00 
	initrd_dev->close = 0;
  1039d1:	a1 c4 ce 10 00       	mov    0x10cec4,%eax
  1039d6:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
  1039dd:	00 00 00 
	initrd_dev->readdir = &initrd_readdir;
  1039e0:	a1 c4 ce 10 00       	mov    0x10cec4,%eax
  1039e5:	c7 80 ac 00 00 00 86 	movl   $0x103686,0xac(%eax)
  1039ec:	36 10 00 
	initrd_dev->finddir = &initrd_finddir;
  1039ef:	a1 c4 ce 10 00       	mov    0x10cec4,%eax
  1039f4:	c7 80 b0 00 00 00 5a 	movl   $0x10375a,0xb0(%eax)
  1039fb:	37 10 00 
	initrd_dev->ptr = 0;
  1039fe:	a1 c4 ce 10 00       	mov    0x10cec4,%eax
  103a03:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
  103a0a:	00 00 00 
	initrd_dev->impl = 0;
  103a0d:	a1 c4 ce 10 00       	mov    0x10cec4,%eax
  103a12:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
  103a19:	00 00 00 

	initrd_header = (initrd_header_t *) location;
  103a1c:	8b 45 08             	mov    0x8(%ebp),%eax
  103a1f:	a3 90 cf 10 00       	mov    %eax,0x10cf90
	file_headers = (initrd_file_header_t *) (location + sizeof(initrd_header_t));
  103a24:	8b 45 08             	mov    0x8(%ebp),%eax
  103a27:	83 c0 04             	add    $0x4,%eax
  103a2a:	a3 84 cf 10 00       	mov    %eax,0x10cf84
	// kprintf("fs_node_t: %d, numfiles: %d\n", sizeof(fs_node_t), initrd_header->nfiles);
	// return NULL;

	root_nodes = (fs_node_t *) malloc(sizeof(fs_node_t) * initrd_header->nfiles);
  103a2f:	a1 90 cf 10 00       	mov    0x10cf90,%eax
  103a34:	8b 00                	mov    (%eax),%eax
  103a36:	69 c0 b8 00 00 00    	imul   $0xb8,%eax,%eax
  103a3c:	83 ec 0c             	sub    $0xc,%esp
  103a3f:	50                   	push   %eax
  103a40:	e8 c4 f0 ff ff       	call   102b09 <malloc>
  103a45:	83 c4 10             	add    $0x10,%esp
  103a48:	a3 8c cf 10 00       	mov    %eax,0x10cf8c
	nroot_nodes = initrd_header->nfiles;
  103a4d:	a1 90 cf 10 00       	mov    0x10cf90,%eax
  103a52:	8b 00                	mov    (%eax),%eax
  103a54:	a3 c0 ce 10 00       	mov    %eax,0x10cec0

	//for every file
	unsigned int i;
	for (i = 0; i < initrd_header->nfiles; i++) {
  103a59:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  103a60:	e9 ca 01 00 00       	jmp    103c2f <initrd_init+0x452>
		file_headers[i].offset += location;
  103a65:	8b 15 84 cf 10 00    	mov    0x10cf84,%edx
  103a6b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103a6e:	6b c0 4c             	imul   $0x4c,%eax,%eax
  103a71:	01 d0                	add    %edx,%eax
  103a73:	8b 0d 84 cf 10 00    	mov    0x10cf84,%ecx
  103a79:	8b 55 f4             	mov    -0xc(%ebp),%edx
  103a7c:	6b d2 4c             	imul   $0x4c,%edx,%edx
  103a7f:	01 ca                	add    %ecx,%edx
  103a81:	8b 4a 44             	mov    0x44(%edx),%ecx
  103a84:	8b 55 08             	mov    0x8(%ebp),%edx
  103a87:	01 ca                	add    %ecx,%edx
  103a89:	89 50 44             	mov    %edx,0x44(%eax)
		// kprintf("^%i, %p, %p\n", i, file_headers[i].offset, location);
		strcpy(root_nodes[i].name, file_headers[i].name);
  103a8c:	8b 15 84 cf 10 00    	mov    0x10cf84,%edx
  103a92:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103a95:	6b c0 4c             	imul   $0x4c,%eax,%eax
  103a98:	01 d0                	add    %edx,%eax
  103a9a:	83 c0 04             	add    $0x4,%eax
  103a9d:	8b 0d 8c cf 10 00    	mov    0x10cf8c,%ecx
  103aa3:	8b 55 f4             	mov    -0xc(%ebp),%edx
  103aa6:	69 d2 b8 00 00 00    	imul   $0xb8,%edx,%edx
  103aac:	01 ca                	add    %ecx,%edx
  103aae:	83 ec 08             	sub    $0x8,%esp
  103ab1:	50                   	push   %eax
  103ab2:	52                   	push   %edx
  103ab3:	e8 38 07 00 00       	call   1041f0 <strcpy>
  103ab8:	83 c4 10             	add    $0x10,%esp
		root_nodes[i].mask = root_nodes[i].uid = root_nodes[i].gid = 0;
  103abb:	8b 15 8c cf 10 00    	mov    0x10cf8c,%edx
  103ac1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103ac4:	69 c0 b8 00 00 00    	imul   $0xb8,%eax,%eax
  103aca:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  103acd:	8b 15 8c cf 10 00    	mov    0x10cf8c,%edx
  103ad3:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103ad6:	69 c0 b8 00 00 00    	imul   $0xb8,%eax,%eax
  103adc:	01 d0                	add    %edx,%eax
  103ade:	8b 1d 8c cf 10 00    	mov    0x10cf8c,%ebx
  103ae4:	8b 55 f4             	mov    -0xc(%ebp),%edx
  103ae7:	69 d2 b8 00 00 00    	imul   $0xb8,%edx,%edx
  103aed:	01 da                	add    %ebx,%edx
  103aef:	c7 82 88 00 00 00 00 	movl   $0x0,0x88(%edx)
  103af6:	00 00 00 
  103af9:	8b 92 88 00 00 00    	mov    0x88(%edx),%edx
  103aff:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
  103b05:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
  103b0b:	89 81 80 00 00 00    	mov    %eax,0x80(%ecx)
		root_nodes[i].length = file_headers[i].length;
  103b11:	8b 15 8c cf 10 00    	mov    0x10cf8c,%edx
  103b17:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103b1a:	69 c0 b8 00 00 00    	imul   $0xb8,%eax,%eax
  103b20:	01 c2                	add    %eax,%edx
  103b22:	8b 0d 84 cf 10 00    	mov    0x10cf84,%ecx
  103b28:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103b2b:	6b c0 4c             	imul   $0x4c,%eax,%eax
  103b2e:	01 c8                	add    %ecx,%eax
  103b30:	8b 40 48             	mov    0x48(%eax),%eax
  103b33:	89 82 94 00 00 00    	mov    %eax,0x94(%edx)
		root_nodes[i].inode = i;
  103b39:	8b 15 8c cf 10 00    	mov    0x10cf8c,%edx
  103b3f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103b42:	69 c0 b8 00 00 00    	imul   $0xb8,%eax,%eax
  103b48:	01 c2                	add    %eax,%edx
  103b4a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103b4d:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
		root_nodes[i].flags = FS_FILE;
  103b53:	8b 15 8c cf 10 00    	mov    0x10cf8c,%edx
  103b59:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103b5c:	69 c0 b8 00 00 00    	imul   $0xb8,%eax,%eax
  103b62:	01 d0                	add    %edx,%eax
  103b64:	c7 80 8c 00 00 00 01 	movl   $0x1,0x8c(%eax)
  103b6b:	00 00 00 
		root_nodes[i].read = &initrd_read;
  103b6e:	8b 15 8c cf 10 00    	mov    0x10cf8c,%edx
  103b74:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103b77:	69 c0 b8 00 00 00    	imul   $0xb8,%eax,%eax
  103b7d:	01 d0                	add    %edx,%eax
  103b7f:	c7 80 9c 00 00 00 0b 	movl   $0x10360b,0x9c(%eax)
  103b86:	36 10 00 
		root_nodes[i].write = 0;
  103b89:	8b 15 8c cf 10 00    	mov    0x10cf8c,%edx
  103b8f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103b92:	69 c0 b8 00 00 00    	imul   $0xb8,%eax,%eax
  103b98:	01 d0                	add    %edx,%eax
  103b9a:	c7 80 a0 00 00 00 00 	movl   $0x0,0xa0(%eax)
  103ba1:	00 00 00 
		root_nodes[i].readdir = 0;
  103ba4:	8b 15 8c cf 10 00    	mov    0x10cf8c,%edx
  103baa:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103bad:	69 c0 b8 00 00 00    	imul   $0xb8,%eax,%eax
  103bb3:	01 d0                	add    %edx,%eax
  103bb5:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%eax)
  103bbc:	00 00 00 
		root_nodes[i].finddir = 0;
  103bbf:	8b 15 8c cf 10 00    	mov    0x10cf8c,%edx
  103bc5:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103bc8:	69 c0 b8 00 00 00    	imul   $0xb8,%eax,%eax
  103bce:	01 d0                	add    %edx,%eax
  103bd0:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
  103bd7:	00 00 00 
		root_nodes[i].open = 0;
  103bda:	8b 15 8c cf 10 00    	mov    0x10cf8c,%edx
  103be0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103be3:	69 c0 b8 00 00 00    	imul   $0xb8,%eax,%eax
  103be9:	01 d0                	add    %edx,%eax
  103beb:	c7 80 a4 00 00 00 00 	movl   $0x0,0xa4(%eax)
  103bf2:	00 00 00 
		root_nodes[i].close = 0;
  103bf5:	8b 15 8c cf 10 00    	mov    0x10cf8c,%edx
  103bfb:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103bfe:	69 c0 b8 00 00 00    	imul   $0xb8,%eax,%eax
  103c04:	01 d0                	add    %edx,%eax
  103c06:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
  103c0d:	00 00 00 
		root_nodes[i].impl = 0;
  103c10:	8b 15 8c cf 10 00    	mov    0x10cf8c,%edx
  103c16:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103c19:	69 c0 b8 00 00 00    	imul   $0xb8,%eax,%eax
  103c1f:	01 d0                	add    %edx,%eax
  103c21:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
  103c28:	00 00 00 
	root_nodes = (fs_node_t *) malloc(sizeof(fs_node_t) * initrd_header->nfiles);
	nroot_nodes = initrd_header->nfiles;

	//for every file
	unsigned int i;
	for (i = 0; i < initrd_header->nfiles; i++) {
  103c2b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
  103c2f:	a1 90 cf 10 00       	mov    0x10cf90,%eax
  103c34:	8b 00                	mov    (%eax),%eax
  103c36:	3b 45 f4             	cmp    -0xc(%ebp),%eax
  103c39:	0f 87 26 fe ff ff    	ja     103a65 <initrd_init+0x288>
		root_nodes[i].open = 0;
		root_nodes[i].close = 0;
		root_nodes[i].impl = 0;
	}

	initrd_inited = true;
  103c3f:	c6 05 b0 b0 10 00 01 	movb   $0x1,0x10b0b0
	return initrd_root;
  103c46:	a1 88 cf 10 00       	mov    0x10cf88,%eax
}
  103c4b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  103c4e:	5b                   	pop    %ebx
  103c4f:	5e                   	pop    %esi
  103c50:	5d                   	pop    %ebp
  103c51:	c3                   	ret    

00103c52 <print_int>:
#include "assert.h"
#include "vfs.h"


void print_int(unsigned int x)
{
  103c52:	55                   	push   %ebp
  103c53:	89 e5                	mov    %esp,%ebp
  103c55:	83 ec 08             	sub    $0x8,%esp
	kprintf("0x%x\n", x);
  103c58:	83 ec 08             	sub    $0x8,%esp
  103c5b:	ff 75 08             	pushl  0x8(%ebp)
  103c5e:	68 2c 6f 10 00       	push   $0x106f2c
  103c63:	e8 40 c7 ff ff       	call   1003a8 <kprintf>
  103c68:	83 c4 10             	add    $0x10,%esp
}
  103c6b:	c9                   	leave  
  103c6c:	c3                   	ret    

00103c6d <task_new>:

task_t *task_new()
{
  103c6d:	55                   	push   %ebp
  103c6e:	89 e5                	mov    %esp,%ebp
  103c70:	83 ec 18             	sub    $0x18,%esp
	task_t *t = (task_t *) calloc(sizeof(task_t));
  103c73:	83 ec 0c             	sub    $0xc,%esp
  103c76:	6a 24                	push   $0x24
  103c78:	e8 a4 f3 ff ff       	call   103021 <calloc>
  103c7d:	83 c4 10             	add    $0x10,%esp
  103c80:	89 45 f4             	mov    %eax,-0xc(%ebp)
	t->pid = next_pid++;
  103c83:	a1 04 c1 10 00       	mov    0x10c104,%eax
  103c88:	8d 50 01             	lea    0x1(%eax),%edx
  103c8b:	89 15 04 c1 10 00    	mov    %edx,0x10c104
  103c91:	8b 55 f4             	mov    -0xc(%ebp),%edx
  103c94:	89 02                	mov    %eax,(%edx)
	t->tss_kernel_stack = (unsigned int *)KERNEL_STACK_HI;//malloc_page_aligned(PAGE_SIZE);
  103c96:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103c99:	c7 40 1c 00 80 11 ff 	movl   $0xff118000,0x1c(%eax)
	return t;
  103ca0:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
  103ca3:	c9                   	leave  
  103ca4:	c3                   	ret    

00103ca5 <task_init>:

void task_init()
{
  103ca5:	55                   	push   %ebp
  103ca6:	89 e5                	mov    %esp,%ebp
  103ca8:	53                   	push   %ebx
  103ca9:	83 ec 04             	sub    $0x4,%esp
	cli();
  103cac:	fa                   	cli    
	next_pid = 1;
  103cad:	c7 05 04 c1 10 00 01 	movl   $0x1,0x10c104
  103cb4:	00 00 00 
	write_tss(5, 0x10, KERNEL_STACK_HI);
  103cb7:	83 ec 04             	sub    $0x4,%esp
  103cba:	68 00 80 11 ff       	push   $0xff118000
  103cbf:	6a 10                	push   $0x10
  103cc1:	6a 05                	push   $0x5
  103cc3:	e8 6c cf ff ff       	call   100c34 <write_tss>
  103cc8:	83 c4 10             	add    $0x10,%esp
	gdt_flush();
  103ccb:	e8 0d cb ff ff       	call   1007dd <gdt_flush>
	tss_flush();
  103cd0:	e8 d5 04 00 00       	call   1041aa <tss_flush>

	current_task = task_new();
  103cd5:	e8 93 ff ff ff       	call   103c6d <task_new>
  103cda:	a3 f8 c0 10 00       	mov    %eax,0x10c0f8
	set_tss_kernel_stack(current_task->tss_kernel_stack);
  103cdf:	a1 f8 c0 10 00       	mov    0x10c0f8,%eax
  103ce4:	8b 40 1c             	mov    0x1c(%eax),%eax
  103ce7:	83 ec 0c             	sub    $0xc,%esp
  103cea:	50                   	push   %eax
  103ceb:	e8 d5 cf ff ff       	call   100cc5 <set_tss_kernel_stack>
  103cf0:	83 c4 10             	add    $0x10,%esp
	current_task->page_directory = (dir_t *) virt_to_phys(PDIR_ADDR);
  103cf3:	8b 1d f8 c0 10 00    	mov    0x10c0f8,%ebx
  103cf9:	83 ec 0c             	sub    $0xc,%esp
  103cfc:	68 00 f0 ff ff       	push   $0xfffff000
  103d01:	e8 4e e4 ff ff       	call   102154 <virt_to_phys>
  103d06:	83 c4 10             	add    $0x10,%esp
  103d09:	89 43 14             	mov    %eax,0x14(%ebx)
	task_queue = current_task;
  103d0c:	a1 f8 c0 10 00       	mov    0x10c0f8,%eax
  103d11:	a3 ec c0 10 00       	mov    %eax,0x10c0ec
	sti();
  103d16:	fb                   	sti    
}
  103d17:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  103d1a:	c9                   	leave  
  103d1b:	c3                   	ret    

00103d1c <print_current_task>:

void print_current_task()
{
  103d1c:	55                   	push   %ebp
  103d1d:	89 e5                	mov    %esp,%ebp
  103d1f:	56                   	push   %esi
  103d20:	53                   	push   %ebx
	kprintf("[current_task] pid: %d, eip: %08x, esp:%08x, ebp: %08x, pd: %08x\n",
			current_task->pid, current_task->eip, current_task->esp, current_task->ebp, current_task->page_directory);
  103d21:	a1 f8 c0 10 00       	mov    0x10c0f8,%eax
	sti();
}

void print_current_task()
{
	kprintf("[current_task] pid: %d, eip: %08x, esp:%08x, ebp: %08x, pd: %08x\n",
  103d26:	8b 70 14             	mov    0x14(%eax),%esi
			current_task->pid, current_task->eip, current_task->esp, current_task->ebp, current_task->page_directory);
  103d29:	a1 f8 c0 10 00       	mov    0x10c0f8,%eax
	sti();
}

void print_current_task()
{
	kprintf("[current_task] pid: %d, eip: %08x, esp:%08x, ebp: %08x, pd: %08x\n",
  103d2e:	8b 58 0c             	mov    0xc(%eax),%ebx
			current_task->pid, current_task->eip, current_task->esp, current_task->ebp, current_task->page_directory);
  103d31:	a1 f8 c0 10 00       	mov    0x10c0f8,%eax
	sti();
}

void print_current_task()
{
	kprintf("[current_task] pid: %d, eip: %08x, esp:%08x, ebp: %08x, pd: %08x\n",
  103d36:	8b 48 08             	mov    0x8(%eax),%ecx
			current_task->pid, current_task->eip, current_task->esp, current_task->ebp, current_task->page_directory);
  103d39:	a1 f8 c0 10 00       	mov    0x10c0f8,%eax
	sti();
}

void print_current_task()
{
	kprintf("[current_task] pid: %d, eip: %08x, esp:%08x, ebp: %08x, pd: %08x\n",
  103d3e:	8b 50 10             	mov    0x10(%eax),%edx
			current_task->pid, current_task->eip, current_task->esp, current_task->ebp, current_task->page_directory);
  103d41:	a1 f8 c0 10 00       	mov    0x10c0f8,%eax
	sti();
}

void print_current_task()
{
	kprintf("[current_task] pid: %d, eip: %08x, esp:%08x, ebp: %08x, pd: %08x\n",
  103d46:	8b 00                	mov    (%eax),%eax
  103d48:	83 ec 08             	sub    $0x8,%esp
  103d4b:	56                   	push   %esi
  103d4c:	53                   	push   %ebx
  103d4d:	51                   	push   %ecx
  103d4e:	52                   	push   %edx
  103d4f:	50                   	push   %eax
  103d50:	68 34 6f 10 00       	push   $0x106f34
  103d55:	e8 4e c6 ff ff       	call   1003a8 <kprintf>
  103d5a:	83 c4 20             	add    $0x20,%esp
			current_task->pid, current_task->eip, current_task->esp, current_task->ebp, current_task->page_directory);
}
  103d5d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  103d60:	5b                   	pop    %ebx
  103d61:	5e                   	pop    %esi
  103d62:	5d                   	pop    %ebp
  103d63:	c3                   	ret    

00103d64 <ps>:

void ps()
{
  103d64:	55                   	push   %ebp
  103d65:	89 e5                	mov    %esp,%ebp
  103d67:	53                   	push   %ebx
  103d68:	83 ec 14             	sub    $0x14,%esp
	task_t *t = task_queue;
  103d6b:	a1 ec c0 10 00       	mov    0x10c0ec,%eax
  103d70:	89 45 f4             	mov    %eax,-0xc(%ebp)
	while(t) {
  103d73:	eb 34                	jmp    103da9 <ps+0x45>
		// no eip, esp - assumes we are already in kernel mode //
		kprintf("pid: %d, ppid: %d, ring: %d, pd: %08x\n", t->pid, t->ppid, t->ring, t->page_directory);
  103d75:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103d78:	8b 58 14             	mov    0x14(%eax),%ebx
  103d7b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103d7e:	8b 48 20             	mov    0x20(%eax),%ecx
  103d81:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103d84:	8b 50 04             	mov    0x4(%eax),%edx
  103d87:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103d8a:	8b 00                	mov    (%eax),%eax
  103d8c:	83 ec 0c             	sub    $0xc,%esp
  103d8f:	53                   	push   %ebx
  103d90:	51                   	push   %ecx
  103d91:	52                   	push   %edx
  103d92:	50                   	push   %eax
  103d93:	68 78 6f 10 00       	push   $0x106f78
  103d98:	e8 0b c6 ff ff       	call   1003a8 <kprintf>
  103d9d:	83 c4 20             	add    $0x20,%esp
		t = t->next;
  103da0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103da3:	8b 40 18             	mov    0x18(%eax),%eax
  103da6:	89 45 f4             	mov    %eax,-0xc(%ebp)
}

void ps()
{
	task_t *t = task_queue;
	while(t) {
  103da9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  103dad:	75 c6                	jne    103d75 <ps+0x11>
		// no eip, esp - assumes we are already in kernel mode //
		kprintf("pid: %d, ppid: %d, ring: %d, pd: %08x\n", t->pid, t->ppid, t->ring, t->page_directory);
		t = t->next;
	}
}
  103daf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  103db2:	c9                   	leave  
  103db3:	c3                   	ret    

00103db4 <get_last_task>:
// gets the last task in task_queue
task_t *get_last_task()
{
  103db4:	55                   	push   %ebp
  103db5:	89 e5                	mov    %esp,%ebp
  103db7:	83 ec 10             	sub    $0x10,%esp
	task_t *t = task_queue;
  103dba:	a1 ec c0 10 00       	mov    0x10c0ec,%eax
  103dbf:	89 45 fc             	mov    %eax,-0x4(%ebp)
	while(t->next) {
  103dc2:	eb 09                	jmp    103dcd <get_last_task+0x19>
		t = t->next;
  103dc4:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103dc7:	8b 40 18             	mov    0x18(%eax),%eax
  103dca:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
// gets the last task in task_queue
task_t *get_last_task()
{
	task_t *t = task_queue;
	while(t->next) {
  103dcd:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103dd0:	8b 40 18             	mov    0x18(%eax),%eax
  103dd3:	85 c0                	test   %eax,%eax
  103dd5:	75 ed                	jne    103dc4 <get_last_task+0x10>
		t = t->next;
	}
	return t;
  103dd7:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  103dda:	c9                   	leave  
  103ddb:	c3                   	ret    

00103ddc <get_next_task>:

// gets the next task to be scheduled
task_t *get_next_task()
{
  103ddc:	55                   	push   %ebp
  103ddd:	89 e5                	mov    %esp,%ebp
	current_task = current_task->next;
  103ddf:	a1 f8 c0 10 00       	mov    0x10c0f8,%eax
  103de4:	8b 40 18             	mov    0x18(%eax),%eax
  103de7:	a3 f8 c0 10 00       	mov    %eax,0x10c0f8
	if(!current_task) {
  103dec:	a1 f8 c0 10 00       	mov    0x10c0f8,%eax
  103df1:	85 c0                	test   %eax,%eax
  103df3:	75 0a                	jne    103dff <get_next_task+0x23>
		current_task = task_queue;
  103df5:	a1 ec c0 10 00       	mov    0x10c0ec,%eax
  103dfa:	a3 f8 c0 10 00       	mov    %eax,0x10c0f8
	}
	return current_task;
  103dff:	a1 f8 c0 10 00       	mov    0x10c0f8,%eax
}
  103e04:	5d                   	pop    %ebp
  103e05:	c3                   	ret    

00103e06 <task_switch_inner>:

// called from task_switch in sched.asm
task_t *task_switch_inner()
{
  103e06:	55                   	push   %ebp
  103e07:	89 e5                	mov    %esp,%ebp
  103e09:	83 ec 10             	sub    $0x10,%esp
	task_t *n = get_next_task();
  103e0c:	e8 cb ff ff ff       	call   103ddc <get_next_task>
  103e11:	89 45 fc             	mov    %eax,-0x4(%ebp)
	//set_tss_kernel_stack(n->tss_kernel_stack);
	return n;
  103e14:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  103e17:	c9                   	leave  
  103e18:	c3                   	ret    

00103e19 <get_current_task>:

// returns current running  task
task_t *get_current_task()
{
  103e19:	55                   	push   %ebp
  103e1a:	89 e5                	mov    %esp,%ebp
	return current_task;
  103e1c:	a1 f8 c0 10 00       	mov    0x10c0f8,%eax
}
  103e21:	5d                   	pop    %ebp
  103e22:	c3                   	ret    

00103e23 <fork_inner>:

task_t *fork_inner()
{
  103e23:	55                   	push   %ebp
  103e24:	89 e5                	mov    %esp,%ebp
  103e26:	83 ec 18             	sub    $0x18,%esp
	task_t *t = task_new();
  103e29:	e8 3f fe ff ff       	call   103c6d <task_new>
  103e2e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	t->ppid = current_task->pid;
  103e31:	a1 f8 c0 10 00       	mov    0x10c0f8,%eax
  103e36:	8b 10                	mov    (%eax),%edx
  103e38:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103e3b:	89 50 04             	mov    %edx,0x4(%eax)
	t->ring = current_task->ring;
  103e3e:	a1 f8 c0 10 00       	mov    0x10c0f8,%eax
  103e43:	8b 50 20             	mov    0x20(%eax),%edx
  103e46:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103e49:	89 50 20             	mov    %edx,0x20(%eax)
	t->page_directory = clone_directory();
  103e4c:	e8 d6 e6 ff ff       	call   102527 <clone_directory>
  103e51:	89 c2                	mov    %eax,%edx
  103e53:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103e56:	89 50 14             	mov    %edx,0x14(%eax)

	return t;
  103e59:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
  103e5c:	c9                   	leave  
  103e5d:	c3                   	ret    

00103e5e <getpid>:

int getpid()
{
  103e5e:	55                   	push   %ebp
  103e5f:	89 e5                	mov    %esp,%ebp
	return current_task ? current_task->pid : -1;
  103e61:	a1 f8 c0 10 00       	mov    0x10c0f8,%eax
  103e66:	85 c0                	test   %eax,%eax
  103e68:	74 09                	je     103e73 <getpid+0x15>
  103e6a:	a1 f8 c0 10 00       	mov    0x10c0f8,%eax
  103e6f:	8b 00                	mov    (%eax),%eax
  103e71:	eb 05                	jmp    103e78 <getpid+0x1a>
  103e73:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  103e78:	5d                   	pop    %ebp
  103e79:	c3                   	ret    

00103e7a <getring>:
int getring()
{
  103e7a:	55                   	push   %ebp
  103e7b:	89 e5                	mov    %esp,%ebp
	return current_task ? current_task->ring : -1;
  103e7d:	a1 f8 c0 10 00       	mov    0x10c0f8,%eax
  103e82:	85 c0                	test   %eax,%eax
  103e84:	74 0a                	je     103e90 <getring+0x16>
  103e86:	a1 f8 c0 10 00       	mov    0x10c0f8,%eax
  103e8b:	8b 40 20             	mov    0x20(%eax),%eax
  103e8e:	eb 05                	jmp    103e95 <getring+0x1b>
  103e90:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  103e95:	5d                   	pop    %ebp
  103e96:	c3                   	ret    

00103e97 <task_exit>:

void task_exit(int status)
{
  103e97:	55                   	push   %ebp
  103e98:	89 e5                	mov    %esp,%ebp
  103e9a:	83 ec 08             	sub    $0x8,%esp
	// TODO - kill task and clean memory
	kprintf("pid %d exited with status: %d\n", current_task->pid, status);
  103e9d:	a1 f8 c0 10 00       	mov    0x10c0f8,%eax
  103ea2:	8b 00                	mov    (%eax),%eax
  103ea4:	83 ec 04             	sub    $0x4,%esp
  103ea7:	ff 75 08             	pushl  0x8(%ebp)
  103eaa:	50                   	push   %eax
  103eab:	68 a0 6f 10 00       	push   $0x106fa0
  103eb0:	e8 f3 c4 ff ff       	call   1003a8 <kprintf>
  103eb5:	83 c4 10             	add    $0x10,%esp
	sti();
  103eb8:	fb                   	sti    
	while(1) {
		nop(); // nop for now //
  103eb9:	90                   	nop
	}
  103eba:	eb fd                	jmp    103eb9 <task_exit+0x22>

00103ebc <task_idle>:
}

void task_idle()
{
  103ebc:	55                   	push   %ebp
  103ebd:	89 e5                	mov    %esp,%ebp
	while(1) {
		nop();
  103ebf:	90                   	nop
	}
  103ec0:	eb fd                	jmp    103ebf <task_idle+0x3>

00103ec2 <switch_to_user_mode>:
}

void switch_to_user_mode(uint32_t code_addr, uint32_t stack_hi_addr)
{
  103ec2:	55                   	push   %ebp
  103ec3:	89 e5                	mov    %esp,%ebp
  103ec5:	83 ec 08             	sub    $0x8,%esp
	current_task->ring = 3;
  103ec8:	a1 f8 c0 10 00       	mov    0x10c0f8,%eax
  103ecd:	c7 40 20 03 00 00 00 	movl   $0x3,0x20(%eax)
	switch_to_user_mode_asm(code_addr, stack_hi_addr);
  103ed4:	83 ec 08             	sub    $0x8,%esp
  103ed7:	ff 75 0c             	pushl  0xc(%ebp)
  103eda:	ff 75 08             	pushl  0x8(%ebp)
  103edd:	e8 9e 02 00 00       	call   104180 <switch_to_user_mode_asm>
  103ee2:	83 c4 10             	add    $0x10,%esp
}
  103ee5:	c9                   	leave  
  103ee6:	c3                   	ret    

00103ee7 <exec_init>:
//
//	Loading "init" from initrd.img "filesystem"
//		into memory @0x10000000 and jump to it in ring 3
//
void exec_init()
{
  103ee7:	55                   	push   %ebp
  103ee8:	89 e5                	mov    %esp,%ebp
  103eea:	83 ec 28             	sub    $0x28,%esp
	extern fs_node_t *fs_root;
	if(!fs_root) {
  103eed:	a1 08 c1 10 00       	mov    0x10c108,%eax
  103ef2:	85 c0                	test   %eax,%eax
  103ef4:	75 10                	jne    103f06 <exec_init+0x1f>
		panic("File system not inited");
  103ef6:	83 ec 0c             	sub    $0xc,%esp
  103ef9:	68 bf 6f 10 00       	push   $0x106fbf
  103efe:	e8 41 c5 ff ff       	call   100444 <panic>
  103f03:	83 c4 10             	add    $0x10,%esp
	}
	fs_node_t *fs_node = finddir_fs(fs_root, "init");
  103f06:	a1 08 c1 10 00       	mov    0x10c108,%eax
  103f0b:	83 ec 08             	sub    $0x8,%esp
  103f0e:	68 d6 6f 10 00       	push   $0x106fd6
  103f13:	50                   	push   %eax
  103f14:	e8 af f6 ff ff       	call   1035c8 <finddir_fs>
  103f19:	83 c4 10             	add    $0x10,%esp
  103f1c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(!fs_node) {
  103f1f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  103f23:	75 12                	jne    103f37 <exec_init+0x50>
		panic("Cannot find init\n");
  103f25:	83 ec 0c             	sub    $0xc,%esp
  103f28:	68 db 6f 10 00       	push   $0x106fdb
  103f2d:	e8 12 c5 ff ff       	call   100444 <panic>
  103f32:	83 c4 10             	add    $0x10,%esp
  103f35:	eb 20                	jmp    103f57 <exec_init+0x70>
	} else {
		kprintf("Loading /%s at address %p, length:%d\n", fs_node->name,
  103f37:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103f3a:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
  103f40:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103f43:	52                   	push   %edx
  103f44:	68 00 00 00 10       	push   $0x10000000
  103f49:	50                   	push   %eax
  103f4a:	68 f0 6f 10 00       	push   $0x106ff0
  103f4f:	e8 54 c4 ff ff       	call   1003a8 <kprintf>
  103f54:	83 c4 10             	add    $0x10,%esp
				USER_CODE_START_ADDR, fs_node->length);
	}
	unsigned int num_pages = (fs_node->length / PAGE_SIZE) + 1;
  103f57:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103f5a:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
  103f60:	c1 e8 0c             	shr    $0xc,%eax
  103f63:	83 c0 01             	add    $0x1,%eax
  103f66:	89 45 e8             	mov    %eax,-0x18(%ebp)
	unsigned int i;
	for(i = 0; i < num_pages; i++) {
  103f69:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  103f70:	eb 25                	jmp    103f97 <exec_init+0xb0>
		map(USER_CODE_START_ADDR + (PAGE_SIZE*i), (unsigned int)frame_alloc(),
  103f72:	e8 f1 db ff ff       	call   101b68 <frame_alloc>
  103f77:	89 c2                	mov    %eax,%edx
  103f79:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103f7c:	05 00 00 01 00       	add    $0x10000,%eax
  103f81:	c1 e0 0c             	shl    $0xc,%eax
  103f84:	83 ec 04             	sub    $0x4,%esp
  103f87:	6a 07                	push   $0x7
  103f89:	52                   	push   %edx
  103f8a:	50                   	push   %eax
  103f8b:	e8 86 e2 ff ff       	call   102216 <map>
  103f90:	83 c4 10             	add    $0x10,%esp
		kprintf("Loading /%s at address %p, length:%d\n", fs_node->name,
				USER_CODE_START_ADDR, fs_node->length);
	}
	unsigned int num_pages = (fs_node->length / PAGE_SIZE) + 1;
	unsigned int i;
	for(i = 0; i < num_pages; i++) {
  103f93:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
  103f97:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103f9a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
  103f9d:	72 d3                	jb     103f72 <exec_init+0x8b>
		map(USER_CODE_START_ADDR + (PAGE_SIZE*i), (unsigned int)frame_alloc(),
				P_PRESENT | P_READ_WRITE | P_USER);
	}
	// reserve 2 page stack //
	for(i = 2; i > 0; i--) {
  103f9f:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
  103fa6:	eb 2c                	jmp    103fd4 <exec_init+0xed>
		map(USER_STACK_HI-(i * PAGE_SIZE), (unsigned int) frame_calloc(),
  103fa8:	e8 65 dc ff ff       	call   101c12 <frame_calloc>
  103fad:	89 c1                	mov    %eax,%ecx
  103faf:	8b 55 f4             	mov    -0xc(%ebp),%edx
  103fb2:	b8 00 00 00 00       	mov    $0x0,%eax
  103fb7:	29 d0                	sub    %edx,%eax
  103fb9:	c1 e0 0c             	shl    $0xc,%eax
  103fbc:	05 00 f0 ff 0f       	add    $0xffff000,%eax
  103fc1:	83 ec 04             	sub    $0x4,%esp
  103fc4:	6a 07                	push   $0x7
  103fc6:	51                   	push   %ecx
  103fc7:	50                   	push   %eax
  103fc8:	e8 49 e2 ff ff       	call   102216 <map>
  103fcd:	83 c4 10             	add    $0x10,%esp
	for(i = 0; i < num_pages; i++) {
		map(USER_CODE_START_ADDR + (PAGE_SIZE*i), (unsigned int)frame_alloc(),
				P_PRESENT | P_READ_WRITE | P_USER);
	}
	// reserve 2 page stack //
	for(i = 2; i > 0; i--) {
  103fd0:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
  103fd4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
  103fd8:	75 ce                	jne    103fa8 <exec_init+0xc1>
		map(USER_STACK_HI-(i * PAGE_SIZE), (unsigned int) frame_calloc(),
			P_PRESENT | P_READ_WRITE | P_USER);
	}

	unsigned int offset = 0, size = 0;
  103fda:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  103fe1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	char *buff = (char *)USER_CODE_START_ADDR;
  103fe8:	c7 45 e0 00 00 00 10 	movl   $0x10000000,-0x20(%ebp)
	do {
		size = read_fs(fs_node, offset, fs_node->length, buff);
  103fef:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103ff2:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
  103ff8:	ff 75 e0             	pushl  -0x20(%ebp)
  103ffb:	50                   	push   %eax
  103ffc:	ff 75 f0             	pushl  -0x10(%ebp)
  103fff:	ff 75 ec             	pushl  -0x14(%ebp)
  104002:	e8 bb f4 ff ff       	call   1034c2 <read_fs>
  104007:	83 c4 10             	add    $0x10,%esp
  10400a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		offset += size;
  10400d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  104010:	01 45 f0             	add    %eax,-0x10(%ebp)
	} while(size > 0);
  104013:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  104017:	75 d6                	jne    103fef <exec_init+0x108>
	// kprintf("Loaded: %d bytes\n", offset);
	switch_to_user_mode(USER_CODE_START_ADDR, USER_STACK_HI);
  104019:	83 ec 08             	sub    $0x8,%esp
  10401c:	68 00 f0 ff 0f       	push   $0xffff000
  104021:	68 00 00 00 10       	push   $0x10000000
  104026:	e8 97 fe ff ff       	call   103ec2 <switch_to_user_mode>
  10402b:	83 c4 10             	add    $0x10,%esp
}
  10402e:	c9                   	leave  
  10402f:	c3                   	ret    

00104030 <fork>:
EXTERN fork_inner, get_last_task
[GLOBAL fork]

fork:
	cli								; do not interrupt me
  104030:	fa                   	cli    
	call fork_inner
  104031:	e8 ed fd ff ff       	call   103e23 <fork_inner>

	mov [eax + 8], esp				; save child esp
  104036:	89 60 08             	mov    %esp,0x8(%eax)
	mov [eax + 12], ebp				; save child ebp
  104039:	89 68 0c             	mov    %ebp,0xc(%eax)
	mov [eax + 16], dword .child	; next jump to fork.child
  10403c:	c7 40 10 51 40 10 00 	movl   $0x104051,0x10(%eax)

	push eax						; save child task_t
  104043:	50                   	push   %eax
	call get_last_task				; get last task in task_queue
  104044:	e8 6b fd ff ff       	call   103db4 <get_last_task>
	pop ebx							; get back the child
  104049:	5b                   	pop    %ebx
	mov [eax + 24], ebx				; link this new child to task_queue
  10404a:	89 58 18             	mov    %ebx,0x18(%eax)

0010404d <fork.parent>:

.parent:
	mov eax, [ebx]					; move the pid of child into eax
  10404d:	8b 03                	mov    (%ebx),%eax
	jmp .bye						; jump back with child pid
  10404f:	eb 02                	jmp    104053 <fork.bye>

00104051 <fork.child>:

.child:
	xor eax, eax					; here first jumps the child when it's first scheduled by task_switch
  104051:	31 c0                	xor    %eax,%eax

00104053 <fork.bye>:
									; return 0 to it
.bye:
	sti
  104053:	fb                   	sti    
	ret
  104054:	c3                   	ret    

00104055 <task_switch>:

EXTERN get_current_task, get_next_task, print_int, ps, print_current_task, task_switch_inner
[GLOBAL task_switch]
task_switch:

	call get_current_task			; if current_task not inited, just return
  104055:	e8 bf fd ff ff       	call   103e19 <get_current_task>
	cmp eax, 0
  10405a:	83 f8 00             	cmp    $0x0,%eax
	je .bye
  10405d:	74 22                	je     104081 <task_switch.bye>
									; current_task was initialised by task_init
									; saving it's interrupted state
	mov [eax + 8], esp				; save current_task esp
  10405f:	89 60 08             	mov    %esp,0x8(%eax)
	mov [eax + 12], ebp				; save current_task ebp
  104062:	89 68 0c             	mov    %ebp,0xc(%eax)
	mov [eax + 16], dword .bye		; next time, jump to .bye
  104065:	c7 40 10 81 40 10 00 	movl   $0x104081,0x10(%eax)

	;call get_next_task				; get next task in queue
	call task_switch_inner			; call inner so we have mode control in C
  10406c:	e8 95 fd ff ff       	call   103e06 <task_switch_inner>

	mov esp, [eax + 8]				; move it's saved esp to esp
  104071:	8b 60 08             	mov    0x8(%eax),%esp
	mov ebp, [eax + 12]				; ebp
  104074:	8b 68 0c             	mov    0xc(%eax),%ebp
	mov ebx, [eax + 20]				; it's cloned directory
  104077:	8b 58 14             	mov    0x14(%eax),%ebx
	mov cr3, ebx					; change page directory
  10407a:	0f 22 db             	mov    %ebx,%cr3
	sti
  10407d:	fb                   	sti    
	jmp [eax + 16]					; jump tp it's saved eip -> probably task_switch.bye or fork.child
  10407e:	ff 60 10             	jmp    *0x10(%eax)

00104081 <task_switch.bye>:

.bye:
	ret
  104081:	c3                   	ret    

00104082 <get_flags>:


GLOBAL get_flags
get_flags:
	pushfd
  104082:	9c                   	pushf  
	pop eax
  104083:	58                   	pop    %eax
	ret
  104084:	c3                   	ret    

00104085 <console_write2>:
#include "syscall.h"
#include "task.h"
#include "x86.h"


void console_write2(char *buf){
  104085:	55                   	push   %ebp
  104086:	89 e5                	mov    %esp,%ebp
  104088:	83 ec 08             	sub    $0x8,%esp
	kprintf("Console Write 2: ");
  10408b:	83 ec 0c             	sub    $0xc,%esp
  10408e:	68 16 70 10 00       	push   $0x107016
  104093:	e8 10 c3 ff ff       	call   1003a8 <kprintf>
  104098:	83 c4 10             	add    $0x10,%esp
	console_write(buf);
  10409b:	83 ec 0c             	sub    $0xc,%esp
  10409e:	ff 75 08             	pushl  0x8(%ebp)
  1040a1:	e8 66 c2 ff ff       	call   10030c <console_write>
  1040a6:	83 c4 10             	add    $0x10,%esp
}
  1040a9:	c9                   	leave  
  1040aa:	c3                   	ret    

001040ab <sum>:

unsigned int sum(unsigned int a, unsigned int b) {
  1040ab:	55                   	push   %ebp
  1040ac:	89 e5                	mov    %esp,%ebp
	return a + b;
  1040ae:	8b 55 08             	mov    0x8(%ebp),%edx
  1040b1:	8b 45 0c             	mov    0xc(%ebp),%eax
  1040b4:	01 d0                	add    %edx,%eax
}
  1040b6:	5d                   	pop    %ebp
  1040b7:	c3                   	ret    

001040b8 <syscall_handler>:
	&getpid,
};
static unsigned int num_syscalls;

unsigned int syscall_handler(struct iregs *r)
{
  1040b8:	55                   	push   %ebp
  1040b9:	89 e5                	mov    %esp,%ebp
  1040bb:	57                   	push   %edi
  1040bc:	56                   	push   %esi
  1040bd:	53                   	push   %ebx
  1040be:	83 ec 1c             	sub    $0x1c,%esp
	// cli();
	if(r->eax >= num_syscalls) {
  1040c1:	8b 45 08             	mov    0x8(%ebp),%eax
  1040c4:	8b 50 2c             	mov    0x2c(%eax),%edx
  1040c7:	a1 b4 b0 10 00       	mov    0x10b0b4,%eax
  1040cc:	39 c2                	cmp    %eax,%edx
  1040ce:	72 1e                	jb     1040ee <syscall_handler+0x36>
		kprintf("No such syscall: %p\n", r->eax);
  1040d0:	8b 45 08             	mov    0x8(%ebp),%eax
  1040d3:	8b 40 2c             	mov    0x2c(%eax),%eax
  1040d6:	83 ec 08             	sub    $0x8,%esp
  1040d9:	50                   	push   %eax
  1040da:	68 28 70 10 00       	push   $0x107028
  1040df:	e8 c4 c2 ff ff       	call   1003a8 <kprintf>
  1040e4:	83 c4 10             	add    $0x10,%esp
		return 0;
  1040e7:	b8 00 00 00 00       	mov    $0x0,%eax
  1040ec:	eb 4c                	jmp    10413a <syscall_handler+0x82>
	} else {
		// kprintf("kernel: syscall: %d, %p\n", r->eax, r->ebx);
	}
	// kprintf("eax: %p, ebx: %p\n", r->eax, r->ebx);
	void *func = syscalls[r->eax];
  1040ee:	8b 45 08             	mov    0x8(%ebp),%eax
  1040f1:	8b 40 2c             	mov    0x2c(%eax),%eax
  1040f4:	8b 04 85 60 63 10 00 	mov    0x106360(,%eax,4),%eax
  1040fb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		pop %%ebx; \
		pop %%ebx; \
		pop %%ebx; \
		"
	: "=r"(ret)
	:  "r"(r->edi), "r"(r->esi), "r"(r->edx), "r"(r->ecx), "r"(r->ebx), "r"(func));
  1040fe:	8b 45 08             	mov    0x8(%ebp),%eax
  104101:	8b 40 10             	mov    0x10(%eax),%eax
  104104:	8b 55 08             	mov    0x8(%ebp),%edx
  104107:	8b 52 14             	mov    0x14(%edx),%edx
  10410a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10410d:	8b 49 24             	mov    0x24(%ecx),%ecx
  104110:	8b 5d 08             	mov    0x8(%ebp),%ebx
  104113:	8b 5b 28             	mov    0x28(%ebx),%ebx
  104116:	8b 75 08             	mov    0x8(%ebp),%esi
  104119:	8b 76 20             	mov    0x20(%esi),%esi
		// kprintf("kernel: syscall: %d, %p\n", r->eax, r->ebx);
	}
	// kprintf("eax: %p, ebx: %p\n", r->eax, r->ebx);
	void *func = syscalls[r->eax];
	int ret;
	asm volatile(" \
  10411c:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  10411f:	50                   	push   %eax
  104120:	52                   	push   %edx
  104121:	51                   	push   %ecx
  104122:	53                   	push   %ebx
  104123:	56                   	push   %esi
  104124:	ff d7                	call   *%edi
  104126:	5b                   	pop    %ebx
  104127:	5b                   	pop    %ebx
  104128:	5b                   	pop    %ebx
  104129:	5b                   	pop    %ebx
  10412a:	5b                   	pop    %ebx
  10412b:	89 45 e0             	mov    %eax,-0x20(%ebp)
		pop %%ebx; \
		"
	: "=r"(ret)
	:  "r"(r->edi), "r"(r->esi), "r"(r->edx), "r"(r->ecx), "r"(r->ebx), "r"(func));
//	call_sys(func, r->ebx, r->ecx, r->edx, r->esi, r->edi);
	r->eax = ret;
  10412e:	8b 55 e0             	mov    -0x20(%ebp),%edx
  104131:	8b 45 08             	mov    0x8(%ebp),%eax
  104134:	89 50 2c             	mov    %edx,0x2c(%eax)
	// kprintf("syscall ok\n");
	return ret;
  104137:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
  10413a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  10413d:	5b                   	pop    %ebx
  10413e:	5e                   	pop    %esi
  10413f:	5f                   	pop    %edi
  104140:	5d                   	pop    %ebp
  104141:	c3                   	ret    

00104142 <syscall_init>:

unsigned int syscall_handler(struct iregs *r);
void syscall_init()
{
  104142:	55                   	push   %ebp
  104143:	89 e5                	mov    %esp,%ebp
  104145:	83 ec 08             	sub    $0x8,%esp
	kprintf("Syscall Init\n");
  104148:	83 ec 0c             	sub    $0xc,%esp
  10414b:	68 3d 70 10 00       	push   $0x10703d
  104150:	e8 53 c2 ff ff       	call   1003a8 <kprintf>
  104155:	83 c4 10             	add    $0x10,%esp
	isr_install_handler(0x80, &syscall_handler);
  104158:	83 ec 08             	sub    $0x8,%esp
  10415b:	68 b8 40 10 00       	push   $0x1040b8
  104160:	68 80 00 00 00       	push   $0x80
  104165:	e8 58 d0 ff ff       	call   1011c2 <isr_install_handler>
  10416a:	83 c4 10             	add    $0x10,%esp
	num_syscalls = sizeof(syscalls) / sizeof(void *);
  10416d:	c7 05 b4 b0 10 00 08 	movl   $0x8,0x10b0b4
  104174:	00 00 00 
}
  104177:	c9                   	leave  
  104178:	c3                   	ret    
  104179:	66 90                	xchg   %ax,%ax
  10417b:	66 90                	xchg   %ax,%ax
  10417d:	66 90                	xchg   %ax,%ax
  10417f:	90                   	nop

00104180 <switch_to_user_mode_asm>:
extern test_user_mode, print_int
global switch_to_user_mode_asm
switch_to_user_mode_asm:
        cli
  104180:	fa                   	cli    
        mov ax, 0x23
  104181:	66 b8 23 00          	mov    $0x23,%ax
        mov ds, ax
  104185:	8e d8                	mov    %eax,%ds
        mov es, ax
  104187:	8e c0                	mov    %eax,%es
        mov fs, ax
  104189:	8e e0                	mov    %eax,%fs
        mov gs, ax
  10418b:	8e e8                	mov    %eax,%gs
        push 0x23					; ring 3 ss
  10418d:	6a 23                	push   $0x23
        push 0xFFFF000				; ring 3 esp
  10418f:	68 00 f0 ff 0f       	push   $0xffff000
        pushf						; save flags
  104194:	9c                   	pushf  
        or dword [esp], 0x200		; enable interrupts after return
  104195:	81 0c 24 00 02 00 00 	orl    $0x200,(%esp)
        push 0x1b                   ; user mode code segment
  10419c:	6a 1b                	push   $0x1b
        ;push .sjmp					; eip where to return
        push 0x10000000
  10419e:	68 00 00 00 10       	push   $0x10000000
        iret
  1041a3:	cf                   	iret   

001041a4 <switch_to_user_mode_asm.sjmp>:
.sjmp
        jmp 0x10000000                  ; hardcoded user mode program
  1041a4:	e9 57 be ef 0f       	jmp    10000000 <bssEnd+0xfef3000>
        ; call test_user_mode
        ret
  1041a9:	c3                   	ret    

001041aa <tss_flush>:

GLOBAL tss_flush
tss_flush:
   mov ax, 0x2B      ; Load the index of our TSS structure - The index is
  1041aa:	66 b8 2b 00          	mov    $0x2b,%ax
                     ; 0x28, as it is the 5th selector and each is 8 bytes
                     ; long, but we set the bottom two bits (making 0x2B)
                     ; so that it has an RPL of 3, not zero.
   ltr ax            ; Load 0x2B into the task state register.
  1041ae:	0f 00 d8             	ltr    %ax
   ret
  1041b1:	c3                   	ret    
  1041b2:	66 90                	xchg   %ax,%ax
  1041b4:	66 90                	xchg   %ax,%ax
  1041b6:	66 90                	xchg   %ax,%ax
  1041b8:	66 90                	xchg   %ax,%ax
  1041ba:	66 90                	xchg   %ax,%ax
  1041bc:	66 90                	xchg   %ax,%ax
  1041be:	66 90                	xchg   %ax,%ax

001041c0 <memcpy>:
#include <string.h>
void *memcpy(void *dest, void *src, size_t n) {
  1041c0:	56                   	push   %esi
  1041c1:	53                   	push   %ebx
	size_t i;
	char *d = (char *) dest;
	const char *s = (const char *) src;

	for(i=0; i < n; i++) {
  1041c2:	31 d2                	xor    %edx,%edx
#include <string.h>
void *memcpy(void *dest, void *src, size_t n) {
  1041c4:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  1041c8:	8b 44 24 0c          	mov    0xc(%esp),%eax
  1041cc:	8b 74 24 10          	mov    0x10(%esp),%esi
	size_t i;
	char *d = (char *) dest;
	const char *s = (const char *) src;

	for(i=0; i < n; i++) {
  1041d0:	85 db                	test   %ebx,%ebx
  1041d2:	74 12                	je     1041e6 <memcpy+0x26>
  1041d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		d[i] = s[i];
  1041d8:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
  1041dc:	88 0c 10             	mov    %cl,(%eax,%edx,1)
void *memcpy(void *dest, void *src, size_t n) {
	size_t i;
	char *d = (char *) dest;
	const char *s = (const char *) src;

	for(i=0; i < n; i++) {
  1041df:	83 c2 01             	add    $0x1,%edx
  1041e2:	39 da                	cmp    %ebx,%edx
  1041e4:	75 f2                	jne    1041d8 <memcpy+0x18>
		d[i] = s[i];
	}
	return dest;
}
  1041e6:	5b                   	pop    %ebx
  1041e7:	5e                   	pop    %esi
  1041e8:	c3                   	ret    
  1041e9:	66 90                	xchg   %ax,%ax
  1041eb:	66 90                	xchg   %ax,%ax
  1041ed:	66 90                	xchg   %ax,%ax
  1041ef:	90                   	nop

001041f0 <strcpy>:
#include <string.h>

char *strcpy(char *dest, char *src) {
  1041f0:	53                   	push   %ebx
  1041f1:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
	unsigned int i;
	for(i=0; src[i] != 0; i++) {
  1041f5:	31 d2                	xor    %edx,%edx
#include <string.h>

char *strcpy(char *dest, char *src) {
  1041f7:	8b 44 24 08          	mov    0x8(%esp),%eax
	unsigned int i;
	for(i=0; src[i] != 0; i++) {
  1041fb:	0f b6 0b             	movzbl (%ebx),%ecx
  1041fe:	84 c9                	test   %cl,%cl
  104200:	74 14                	je     104216 <strcpy+0x26>
  104202:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		dest[i] = src[i];
  104208:	88 0c 10             	mov    %cl,(%eax,%edx,1)
#include <string.h>

char *strcpy(char *dest, char *src) {
	unsigned int i;
	for(i=0; src[i] != 0; i++) {
  10420b:	83 c2 01             	add    $0x1,%edx
  10420e:	0f b6 0c 13          	movzbl (%ebx,%edx,1),%ecx
  104212:	84 c9                	test   %cl,%cl
  104214:	75 f2                	jne    104208 <strcpy+0x18>
		dest[i] = src[i];
	}
	dest[i] = 0;
  104216:	c6 04 10 00          	movb   $0x0,(%eax,%edx,1)
	return dest;
  10421a:	5b                   	pop    %ebx
  10421b:	c3                   	ret    
  10421c:	66 90                	xchg   %ax,%ax
  10421e:	66 90                	xchg   %ax,%ax

00104220 <strlen>:
#include <string.h>

size_t strlen(const char *s) {
  104220:	8b 54 24 04          	mov    0x4(%esp),%edx
	size_t i;
	i = 0;
	while (*s++ != '\0') {
  104224:	31 c0                	xor    %eax,%eax
  104226:	80 3a 00             	cmpb   $0x0,(%edx)
  104229:	74 10                	je     10423b <strlen+0x1b>
  10422b:	90                   	nop
  10422c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		i++;
  104230:	83 c0 01             	add    $0x1,%eax
#include <string.h>

size_t strlen(const char *s) {
	size_t i;
	i = 0;
	while (*s++ != '\0') {
  104233:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
  104237:	75 f7                	jne    104230 <strlen+0x10>
  104239:	f3 c3                	repz ret 
		i++;
	}
	return i;
  10423b:	f3 c3                	repz ret 
  10423d:	66 90                	xchg   %ax,%ax
  10423f:	90                   	nop

00104240 <strcmp>:
int strcmp(char s[], char t[]) {
  104240:	56                   	push   %esi
  104241:	53                   	push   %ebx
  104242:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
  104246:	8b 74 24 10          	mov    0x10(%esp),%esi
	int i;
	for (i = 0; s[i] == t[i]; i++)
  10424a:	0f b6 13             	movzbl (%ebx),%edx
  10424d:	0f be 0e             	movsbl (%esi),%ecx
  104250:	38 ca                	cmp    %cl,%dl
  104252:	75 1f                	jne    104273 <strcmp+0x33>
		if (s[i] == '\0')
			return 0;
  104254:	31 c0                	xor    %eax,%eax
int strcmp(char s[], char t[]) {
	int i;
	for (i = 0; s[i] == t[i]; i++)
		if (s[i] == '\0')
  104256:	84 d2                	test   %dl,%dl
  104258:	75 0a                	jne    104264 <strcmp+0x24>
  10425a:	eb 1c                	jmp    104278 <strcmp+0x38>
  10425c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  104260:	84 d2                	test   %dl,%dl
  104262:	74 1c                	je     104280 <strcmp+0x40>
int strcmp(char s[], char t[]) {
	int i;
	for (i = 0; s[i] == t[i]; i++)
  104264:	83 c0 01             	add    $0x1,%eax
  104267:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
  10426b:	0f be 0c 06          	movsbl (%esi,%eax,1),%ecx
  10426f:	38 ca                	cmp    %cl,%dl
  104271:	74 ed                	je     104260 <strcmp+0x20>
		if (s[i] == '\0')
			return 0;

	return s[i] - t[i];
  104273:	0f be c2             	movsbl %dl,%eax
  104276:	29 c8                	sub    %ecx,%eax
  104278:	5b                   	pop    %ebx
  104279:	5e                   	pop    %esi
  10427a:	c3                   	ret    
  10427b:	90                   	nop
  10427c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
int strcmp(char s[], char t[]) {
	int i;
	for (i = 0; s[i] == t[i]; i++)
		if (s[i] == '\0')
			return 0;
  104280:	31 c0                	xor    %eax,%eax

	return s[i] - t[i];
  104282:	5b                   	pop    %ebx
  104283:	5e                   	pop    %esi
  104284:	c3                   	ret    
  104285:	66 90                	xchg   %ax,%ax
  104287:	66 90                	xchg   %ax,%ax
  104289:	66 90                	xchg   %ax,%ax
  10428b:	66 90                	xchg   %ax,%ax
  10428d:	66 90                	xchg   %ax,%ax
  10428f:	90                   	nop

00104290 <memset>:
#include <string.h>

void *memset(void *s, int c, size_t n) {
  104290:	56                   	push   %esi
  104291:	53                   	push   %ebx
  104292:	8b 74 24 14          	mov    0x14(%esp),%esi
  104296:	8b 44 24 0c          	mov    0xc(%esp),%eax
  10429a:	0f b6 5c 24 10       	movzbl 0x10(%esp),%ebx
	unsigned char *p = s;
	while(n > 0){
  10429f:	85 f6                	test   %esi,%esi
  1042a1:	8d 0c 30             	lea    (%eax,%esi,1),%ecx
  1042a4:	89 c2                	mov    %eax,%edx
  1042a6:	74 12                	je     1042ba <memset+0x2a>
  1042a8:	90                   	nop
  1042a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		*p++ = c;
  1042b0:	83 c2 01             	add    $0x1,%edx
  1042b3:	88 5a ff             	mov    %bl,-0x1(%edx)
#include <string.h>

void *memset(void *s, int c, size_t n) {
	unsigned char *p = s;
	while(n > 0){
  1042b6:	39 ca                	cmp    %ecx,%edx
  1042b8:	75 f6                	jne    1042b0 <memset+0x20>
		*p++ = c;
		n--;
	}
	return s;
  1042ba:	5b                   	pop    %ebx
  1042bb:	5e                   	pop    %esi
  1042bc:	c3                   	ret    
  1042bd:	66 90                	xchg   %ax,%ax
  1042bf:	90                   	nop

001042c0 <number>:
__asm__("divl %4":"=a" (n),"=d" (__res):"0" (n),"1" (0),"r" (base)); \
__res; })

static char * number(char * str, int num, int base, int size, int precision
	,int type)
{
  1042c0:	55                   	push   %ebp
  1042c1:	57                   	push   %edi
	char c,sign,tmp[36];
	const char *digits="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  1042c2:	bf 24 61 10 00       	mov    $0x106124,%edi
__asm__("divl %4":"=a" (n),"=d" (__res):"0" (n),"1" (0),"r" (base)); \
__res; })

static char * number(char * str, int num, int base, int size, int precision
	,int type)
{
  1042c7:	56                   	push   %esi
  1042c8:	53                   	push   %ebx
  1042c9:	89 c3                	mov    %eax,%ebx
  1042cb:	89 d0                	mov    %edx,%eax
  1042cd:	83 ec 3c             	sub    $0x3c,%esp
	char c,sign,tmp[36];
	const char *digits="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	int i;

	if (type&SMALL) digits="0123456789abcdefghijklmnopqrstuvwxyz";
  1042d0:	f6 44 24 58 40       	testb  $0x40,0x58(%esp)
  1042d5:	74 05                	je     1042dc <number+0x1c>
  1042d7:	bf 4c 61 10 00       	mov    $0x10614c,%edi
	if (type&LEFT) type &= ~ZEROPAD;
  1042dc:	f6 44 24 58 10       	testb  $0x10,0x58(%esp)
  1042e1:	74 05                	je     1042e8 <number+0x28>
  1042e3:	83 64 24 58 fe       	andl   $0xfffffffe,0x58(%esp)
	if (base<2 || base>36)
  1042e8:	8d 51 fe             	lea    -0x2(%ecx),%edx
  1042eb:	83 fa 22             	cmp    $0x22,%edx
  1042ee:	0f 87 fd 01 00 00    	ja     1044f1 <number+0x231>
		return 0;
	c = (type & ZEROPAD) ? '0' : ' ' ;
  1042f4:	8b 54 24 58          	mov    0x58(%esp),%edx
  1042f8:	83 e2 01             	and    $0x1,%edx
  1042fb:	83 fa 01             	cmp    $0x1,%edx
  1042fe:	19 f6                	sbb    %esi,%esi
  104300:	89 f2                	mov    %esi,%edx
  104302:	83 e2 f0             	and    $0xfffffff0,%edx
  104305:	83 c2 30             	add    $0x30,%edx
	if (type&SIGN && num<0) {
  104308:	f6 44 24 58 02       	testb  $0x2,0x58(%esp)

	if (type&SMALL) digits="0123456789abcdefghijklmnopqrstuvwxyz";
	if (type&LEFT) type &= ~ZEROPAD;
	if (base<2 || base>36)
		return 0;
	c = (type & ZEROPAD) ? '0' : ' ' ;
  10430d:	88 54 24 0b          	mov    %dl,0xb(%esp)
	if (type&SIGN && num<0) {
  104311:	74 0d                	je     104320 <number+0x60>
  104313:	89 c2                	mov    %eax,%edx
  104315:	c1 ea 1f             	shr    $0x1f,%edx
  104318:	84 d2                	test   %dl,%dl
  10431a:	0f 85 a6 01 00 00    	jne    1044c6 <number+0x206>
		sign='-';
		num = -num;
	} else
		sign=(type&PLUS) ? '+' : ((type&SPACE) ? ' ' : 0);
  104320:	f6 44 24 58 04       	testb  $0x4,0x58(%esp)
  104325:	0f 84 5d 01 00 00    	je     104488 <number+0x1c8>
  10432b:	c6 44 24 0a 2b       	movb   $0x2b,0xa(%esp)
	if (sign) size--;
  104330:	83 6c 24 50 01       	subl   $0x1,0x50(%esp)
	if (type&SPECIAL){
  104335:	8b 74 24 58          	mov    0x58(%esp),%esi
  104339:	83 e6 20             	and    $0x20,%esi
  10433c:	89 74 24 04          	mov    %esi,0x4(%esp)
  104340:	74 15                	je     104357 <number+0x97>
		if (base==16) size -= 2;
  104342:	83 f9 10             	cmp    $0x10,%ecx
  104345:	0f 84 9c 01 00 00    	je     1044e7 <number+0x227>
		else if (base==8) size--;
  10434b:	31 d2                	xor    %edx,%edx
  10434d:	83 f9 08             	cmp    $0x8,%ecx
  104350:	0f 94 c2             	sete   %dl
  104353:	29 54 24 50          	sub    %edx,0x50(%esp)
	}
	i=0;
	if (num==0)
  104357:	85 c0                	test   %eax,%eax
  104359:	0f 85 41 01 00 00    	jne    1044a0 <number+0x1e0>
		tmp[i++]='0';
  10435f:	c6 44 24 18 30       	movb   $0x30,0x18(%esp)
  104364:	be 01 00 00 00       	mov    $0x1,%esi
  104369:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  104370:	3b 74 24 54          	cmp    0x54(%esp),%esi
  104374:	89 f5                	mov    %esi,%ebp
  104376:	7d 04                	jge    10437c <number+0xbc>
  104378:	8b 6c 24 54          	mov    0x54(%esp),%ebp
	else while (num!=0)
		tmp[i++]=digits[do_div(num,base)];
	if (i>precision) precision=i;
	size -= precision;
  10437c:	8b 44 24 50          	mov    0x50(%esp),%eax
  104380:	29 e8                	sub    %ebp,%eax
	if (!(type&(ZEROPAD+LEFT)))
  104382:	f6 44 24 58 11       	testb  $0x11,0x58(%esp)
  104387:	75 27                	jne    1043b0 <number+0xf0>
		while(size-->0)
  104389:	85 c0                	test   %eax,%eax
  10438b:	8d 50 ff             	lea    -0x1(%eax),%edx
  10438e:	0f 8e 87 01 00 00    	jle    10451b <number+0x25b>
  104394:	01 d8                	add    %ebx,%eax
  104396:	8d 76 00             	lea    0x0(%esi),%esi
  104399:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
			*str++ = ' ';
  1043a0:	83 c3 01             	add    $0x1,%ebx
  1043a3:	c6 43 ff 20          	movb   $0x20,-0x1(%ebx)
	else while (num!=0)
		tmp[i++]=digits[do_div(num,base)];
	if (i>precision) precision=i;
	size -= precision;
	if (!(type&(ZEROPAD+LEFT)))
		while(size-->0)
  1043a7:	39 c3                	cmp    %eax,%ebx
  1043a9:	75 f5                	jne    1043a0 <number+0xe0>
  1043ab:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
			*str++ = ' ';
	if (sign)
  1043b0:	80 7c 24 0a 00       	cmpb   $0x0,0xa(%esp)
  1043b5:	74 0b                	je     1043c2 <number+0x102>
		*str++ = sign;
  1043b7:	0f b6 54 24 0a       	movzbl 0xa(%esp),%edx
  1043bc:	83 c3 01             	add    $0x1,%ebx
  1043bf:	88 53 ff             	mov    %dl,-0x1(%ebx)
	if (type&SPECIAL) {
  1043c2:	8b 54 24 04          	mov    0x4(%esp),%edx
  1043c6:	85 d2                	test   %edx,%edx
  1043c8:	74 12                	je     1043dc <number+0x11c>
		if (base==8)
  1043ca:	83 f9 08             	cmp    $0x8,%ecx
  1043cd:	0f 84 09 01 00 00    	je     1044dc <number+0x21c>
			*str++ = '0';
		else if (base==16) {
  1043d3:	83 f9 10             	cmp    $0x10,%ecx
  1043d6:	0f 84 1f 01 00 00    	je     1044fb <number+0x23b>
			*str++ = '0';
			*str++ = digits[33];
		}
	}
	if (!(type&LEFT))
  1043dc:	f6 44 24 58 10       	testb  $0x10,0x58(%esp)
  1043e1:	75 24                	jne    104407 <number+0x147>
		while(size-->0)
  1043e3:	85 c0                	test   %eax,%eax
  1043e5:	8d 50 ff             	lea    -0x1(%eax),%edx
  1043e8:	0f 8e 34 01 00 00    	jle    104522 <number+0x262>
  1043ee:	0f b6 54 24 0b       	movzbl 0xb(%esp),%edx
  1043f3:	01 d8                	add    %ebx,%eax
  1043f5:	8d 76 00             	lea    0x0(%esi),%esi
			*str++ = c;
  1043f8:	83 c3 01             	add    $0x1,%ebx
  1043fb:	88 53 ff             	mov    %dl,-0x1(%ebx)
			*str++ = '0';
			*str++ = digits[33];
		}
	}
	if (!(type&LEFT))
		while(size-->0)
  1043fe:	39 c3                	cmp    %eax,%ebx
  104400:	75 f6                	jne    1043f8 <number+0x138>
  104402:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
			*str++ = c;
	while(i<precision--)
  104407:	39 f5                	cmp    %esi,%ebp
  104409:	0f 8e 05 01 00 00    	jle    104514 <number+0x254>
  10440f:	29 f5                	sub    %esi,%ebp
  104411:	01 dd                	add    %ebx,%ebp
  104413:	90                   	nop
  104414:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		*str++ = '0';
  104418:	83 c3 01             	add    $0x1,%ebx
  10441b:	c6 43 ff 30          	movb   $0x30,-0x1(%ebx)
		}
	}
	if (!(type&LEFT))
		while(size-->0)
			*str++ = c;
	while(i<precision--)
  10441f:	39 eb                	cmp    %ebp,%ebx
  104421:	75 f5                	jne    104418 <number+0x158>
  104423:	8b 3c 24             	mov    (%esp),%edi
  104426:	8d 4c 24 18          	lea    0x18(%esp),%ecx
  10442a:	be 01 00 00 00       	mov    $0x1,%esi
  10442f:	89 eb                	mov    %ebp,%ebx
  104431:	29 ce                	sub    %ecx,%esi
  104433:	8d 14 39             	lea    (%ecx,%edi,1),%edx
  104436:	8d 76 00             	lea    0x0(%esi),%esi
  104439:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
		*str++ = '0';
	while(i-->0)
		*str++ = tmp[i];
  104440:	0f b6 0a             	movzbl (%edx),%ecx
  104443:	83 c3 01             	add    $0x1,%ebx
  104446:	83 ea 01             	sub    $0x1,%edx
  104449:	88 4b ff             	mov    %cl,-0x1(%ebx)
  10444c:	8d 0c 16             	lea    (%esi,%edx,1),%ecx
	if (!(type&LEFT))
		while(size-->0)
			*str++ = c;
	while(i<precision--)
		*str++ = '0';
	while(i-->0)
  10444f:	85 c9                	test   %ecx,%ecx
  104451:	7f ed                	jg     104440 <number+0x180>
  104453:	8b 3c 24             	mov    (%esp),%edi
  104456:	89 fa                	mov    %edi,%edx
  104458:	c1 fa 1f             	sar    $0x1f,%edx
  10445b:	f7 d2                	not    %edx
  10445d:	21 fa                	and    %edi,%edx
		*str++ = tmp[i];
	while(size-->0)
  10445f:	85 c0                	test   %eax,%eax
  104461:	8d 54 15 01          	lea    0x1(%ebp,%edx,1),%edx
  104465:	0f 8e a2 00 00 00    	jle    10450d <number+0x24d>
  10446b:	01 d0                	add    %edx,%eax
  10446d:	8d 76 00             	lea    0x0(%esi),%esi
		*str++ = ' ';
  104470:	83 c2 01             	add    $0x1,%edx
  104473:	c6 42 ff 20          	movb   $0x20,-0x1(%edx)
			*str++ = c;
	while(i<precision--)
		*str++ = '0';
	while(i-->0)
		*str++ = tmp[i];
	while(size-->0)
  104477:	39 c2                	cmp    %eax,%edx
  104479:	75 f5                	jne    104470 <number+0x1b0>
		*str++ = ' ';
	return str;
}
  10447b:	83 c4 3c             	add    $0x3c,%esp
  10447e:	5b                   	pop    %ebx
  10447f:	5e                   	pop    %esi
  104480:	5f                   	pop    %edi
  104481:	5d                   	pop    %ebp
  104482:	c3                   	ret    
  104483:	90                   	nop
  104484:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	c = (type & ZEROPAD) ? '0' : ' ' ;
	if (type&SIGN && num<0) {
		sign='-';
		num = -num;
	} else
		sign=(type&PLUS) ? '+' : ((type&SPACE) ? ' ' : 0);
  104488:	f6 44 24 58 08       	testb  $0x8,0x58(%esp)
  10448d:	74 43                	je     1044d2 <number+0x212>
  10448f:	c6 44 24 0a 20       	movb   $0x20,0xa(%esp)
  104494:	e9 97 fe ff ff       	jmp    104330 <number+0x70>
  104499:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	if (type&SPECIAL){
		if (base==16) size -= 2;
		else if (base==8) size--;
	}
	i=0;
	if (num==0)
  1044a0:	31 f6                	xor    %esi,%esi
		tmp[i++]='0';
	else while (num!=0)
		tmp[i++]=digits[do_div(num,base)];
  1044a2:	31 ed                	xor    %ebp,%ebp
  1044a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  1044a8:	89 ea                	mov    %ebp,%edx
  1044aa:	83 c6 01             	add    $0x1,%esi
  1044ad:	f7 f1                	div    %ecx
  1044af:	0f b6 14 17          	movzbl (%edi,%edx,1),%edx
		else if (base==8) size--;
	}
	i=0;
	if (num==0)
		tmp[i++]='0';
	else while (num!=0)
  1044b3:	85 c0                	test   %eax,%eax
		tmp[i++]=digits[do_div(num,base)];
  1044b5:	88 54 34 17          	mov    %dl,0x17(%esp,%esi,1)
		else if (base==8) size--;
	}
	i=0;
	if (num==0)
		tmp[i++]='0';
	else while (num!=0)
  1044b9:	75 ed                	jne    1044a8 <number+0x1e8>
  1044bb:	8d 46 ff             	lea    -0x1(%esi),%eax
  1044be:	89 04 24             	mov    %eax,(%esp)
  1044c1:	e9 aa fe ff ff       	jmp    104370 <number+0xb0>
	if (base<2 || base>36)
		return 0;
	c = (type & ZEROPAD) ? '0' : ' ' ;
	if (type&SIGN && num<0) {
		sign='-';
		num = -num;
  1044c6:	f7 d8                	neg    %eax
	if (type&LEFT) type &= ~ZEROPAD;
	if (base<2 || base>36)
		return 0;
	c = (type & ZEROPAD) ? '0' : ' ' ;
	if (type&SIGN && num<0) {
		sign='-';
  1044c8:	c6 44 24 0a 2d       	movb   $0x2d,0xa(%esp)
		num = -num;
  1044cd:	e9 5e fe ff ff       	jmp    104330 <number+0x70>
	} else
		sign=(type&PLUS) ? '+' : ((type&SPACE) ? ' ' : 0);
  1044d2:	c6 44 24 0a 00       	movb   $0x0,0xa(%esp)
  1044d7:	e9 59 fe ff ff       	jmp    104335 <number+0x75>
			*str++ = ' ';
	if (sign)
		*str++ = sign;
	if (type&SPECIAL) {
		if (base==8)
			*str++ = '0';
  1044dc:	c6 03 30             	movb   $0x30,(%ebx)
  1044df:	83 c3 01             	add    $0x1,%ebx
  1044e2:	e9 f5 fe ff ff       	jmp    1043dc <number+0x11c>
		num = -num;
	} else
		sign=(type&PLUS) ? '+' : ((type&SPACE) ? ' ' : 0);
	if (sign) size--;
	if (type&SPECIAL){
		if (base==16) size -= 2;
  1044e7:	83 6c 24 50 02       	subl   $0x2,0x50(%esp)
  1044ec:	e9 66 fe ff ff       	jmp    104357 <number+0x97>
	while(i-->0)
		*str++ = tmp[i];
	while(size-->0)
		*str++ = ' ';
	return str;
}
  1044f1:	83 c4 3c             	add    $0x3c,%esp
	int i;

	if (type&SMALL) digits="0123456789abcdefghijklmnopqrstuvwxyz";
	if (type&LEFT) type &= ~ZEROPAD;
	if (base<2 || base>36)
		return 0;
  1044f4:	31 c0                	xor    %eax,%eax
	while(i-->0)
		*str++ = tmp[i];
	while(size-->0)
		*str++ = ' ';
	return str;
}
  1044f6:	5b                   	pop    %ebx
  1044f7:	5e                   	pop    %esi
  1044f8:	5f                   	pop    %edi
  1044f9:	5d                   	pop    %ebp
  1044fa:	c3                   	ret    
	if (type&SPECIAL) {
		if (base==8)
			*str++ = '0';
		else if (base==16) {
			*str++ = '0';
			*str++ = digits[33];
  1044fb:	0f b6 57 21          	movzbl 0x21(%edi),%edx
		*str++ = sign;
	if (type&SPECIAL) {
		if (base==8)
			*str++ = '0';
		else if (base==16) {
			*str++ = '0';
  1044ff:	c6 03 30             	movb   $0x30,(%ebx)
			*str++ = digits[33];
  104502:	83 c3 02             	add    $0x2,%ebx
  104505:	88 53 ff             	mov    %dl,-0x1(%ebx)
  104508:	e9 cf fe ff ff       	jmp    1043dc <number+0x11c>
			*str++ = c;
	while(i<precision--)
		*str++ = '0';
	while(i-->0)
		*str++ = tmp[i];
	while(size-->0)
  10450d:	89 d0                	mov    %edx,%eax
		*str++ = ' ';
	return str;
  10450f:	e9 67 ff ff ff       	jmp    10447b <number+0x1bb>
		}
	}
	if (!(type&LEFT))
		while(size-->0)
			*str++ = c;
	while(i<precision--)
  104514:	89 dd                	mov    %ebx,%ebp
  104516:	e9 08 ff ff ff       	jmp    104423 <number+0x163>
	else while (num!=0)
		tmp[i++]=digits[do_div(num,base)];
	if (i>precision) precision=i;
	size -= precision;
	if (!(type&(ZEROPAD+LEFT)))
		while(size-->0)
  10451b:	89 d0                	mov    %edx,%eax
  10451d:	e9 8e fe ff ff       	jmp    1043b0 <number+0xf0>
			*str++ = '0';
			*str++ = digits[33];
		}
	}
	if (!(type&LEFT))
		while(size-->0)
  104522:	89 d0                	mov    %edx,%eax
  104524:	e9 de fe ff ff       	jmp    104407 <number+0x147>
  104529:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00104530 <vsprintf>:
		*str++ = ' ';
	return str;
}

int vsprintf(char *buf, const char *fmt, va_list args)
{
  104530:	55                   	push   %ebp
  104531:	57                   	push   %edi
  104532:	56                   	push   %esi
  104533:	53                   	push   %ebx
  104534:	83 ec 1c             	sub    $0x1c,%esp
  104537:	8b 7c 24 34          	mov    0x34(%esp),%edi
  10453b:	8b 6c 24 30          	mov    0x30(%esp),%ebp
	int field_width;	/* width of output field */
	int precision;		/* min. # of digits for integers; max
				   number of chars for from string */
	int qualifier;		/* 'h', 'l', or 'L' for integer fields */

	for (str=buf ; *fmt ; ++fmt) {
  10453f:	0f b6 17             	movzbl (%edi),%edx
  104542:	84 d2                	test   %dl,%dl
  104544:	0f 84 7a 04 00 00    	je     1049c4 <vsprintf+0x494>
  10454a:	89 6c 24 04          	mov    %ebp,0x4(%esp)
  10454e:	eb 15                	jmp    104565 <vsprintf+0x35>

		default:
			if (*fmt != '%')
				*str++ = '%';
			if (*fmt)
				*str++ = *fmt;
  104550:	88 55 00             	mov    %dl,0x0(%ebp)
  104553:	0f b6 57 01          	movzbl 0x1(%edi),%edx
  104557:	83 c5 01             	add    $0x1,%ebp
	int field_width;	/* width of output field */
	int precision;		/* min. # of digits for integers; max
				   number of chars for from string */
	int qualifier;		/* 'h', 'l', or 'L' for integer fields */

	for (str=buf ; *fmt ; ++fmt) {
  10455a:	83 c7 01             	add    $0x1,%edi
  10455d:	84 d2                	test   %dl,%dl
  10455f:	0f 84 33 01 00 00    	je     104698 <vsprintf+0x168>
		if (*fmt != '%') {
  104565:	80 fa 25             	cmp    $0x25,%dl
  104568:	75 e6                	jne    104550 <vsprintf+0x20>
  10456a:	31 f6                	xor    %esi,%esi
  10456c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		}
			
		/* process flags */
		flags = 0;
		repeat:
			++fmt;		/* this also skips first '%' */
  104570:	83 c7 01             	add    $0x1,%edi
			switch (*fmt) {
  104573:	0f be 0f             	movsbl (%edi),%ecx
  104576:	8d 41 e0             	lea    -0x20(%ecx),%eax
  104579:	3c 10                	cmp    $0x10,%al
  10457b:	77 23                	ja     1045a0 <vsprintf+0x70>
  10457d:	0f b6 c0             	movzbl %al,%eax
  104580:	ff 24 85 4c 70 10 00 	jmp    *0x10704c(,%eax,4)
  104587:	89 f6                	mov    %esi,%esi
  104589:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
		}
			
		/* process flags */
		flags = 0;
		repeat:
			++fmt;		/* this also skips first '%' */
  104590:	83 c7 01             	add    $0x1,%edi
			switch (*fmt) {
  104593:	0f be 0f             	movsbl (%edi),%ecx
				case '-': flags |= LEFT; goto repeat;
				case '+': flags |= PLUS; goto repeat;
				case ' ': flags |= SPACE; goto repeat;
				case '#': flags |= SPECIAL; goto repeat;
				case '0': flags |= ZEROPAD; goto repeat;
  104596:	83 ce 01             	or     $0x1,%esi
			
		/* process flags */
		flags = 0;
		repeat:
			++fmt;		/* this also skips first '%' */
			switch (*fmt) {
  104599:	8d 41 e0             	lea    -0x20(%ecx),%eax
  10459c:	3c 10                	cmp    $0x10,%al
  10459e:	76 dd                	jbe    10457d <vsprintf+0x4d>
				case '0': flags |= ZEROPAD; goto repeat;
				}
		
		/* get field width */
		field_width = -1;
		if (is_digit(*fmt))
  1045a0:	8d 41 d0             	lea    -0x30(%ecx),%eax
  1045a3:	3c 09                	cmp    $0x9,%al
  1045a5:	0f 87 a5 01 00 00    	ja     104750 <vsprintf+0x220>
  1045ab:	31 db                	xor    %ebx,%ebx
  1045ad:	8d 76 00             	lea    0x0(%esi),%esi
static int skip_atoi(const char **s)
{
	int i=0;

	while (is_digit(**s))
		i = i*10 + *((*s)++) - '0';
  1045b0:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
  1045b3:	83 c7 01             	add    $0x1,%edi
  1045b6:	8d 5c 41 d0          	lea    -0x30(%ecx,%eax,2),%ebx

static int skip_atoi(const char **s)
{
	int i=0;

	while (is_digit(**s))
  1045ba:	0f be 0f             	movsbl (%edi),%ecx
  1045bd:	8d 41 d0             	lea    -0x30(%ecx),%eax
  1045c0:	3c 09                	cmp    $0x9,%al
  1045c2:	76 ec                	jbe    1045b0 <vsprintf+0x80>
  1045c4:	89 c8                	mov    %ecx,%eax
			}
		}

		/* get the precision */
		precision = -1;
		if (*fmt == '.') {
  1045c6:	80 f9 2e             	cmp    $0x2e,%cl
				flags |= LEFT;
			}
		}

		/* get the precision */
		precision = -1;
  1045c9:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
		if (*fmt == '.') {
  1045d0:	0f 84 ba 01 00 00    	je     104790 <vsprintf+0x260>
				precision = 0;
		}

		/* get the conversion qualifier */
		qualifier = -1;
		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L') {
  1045d6:	89 c1                	mov    %eax,%ecx
  1045d8:	83 e1 df             	and    $0xffffffdf,%ecx
  1045db:	80 f9 4c             	cmp    $0x4c,%cl
  1045de:	0f 84 34 01 00 00    	je     104718 <vsprintf+0x1e8>
  1045e4:	3c 68                	cmp    $0x68,%al
  1045e6:	0f 84 2c 01 00 00    	je     104718 <vsprintf+0x1e8>
			qualifier = *fmt;
			++fmt;
		}

		switch (*fmt) {
  1045ec:	8d 48 a8             	lea    -0x58(%eax),%ecx
  1045ef:	80 f9 20             	cmp    $0x20,%cl
  1045f2:	0f 87 33 01 00 00    	ja     10472b <vsprintf+0x1fb>
  1045f8:	0f b6 c9             	movzbl %cl,%ecx
  1045fb:	ff 24 8d 90 70 10 00 	jmp    *0x107090(,%ecx,4)
  104602:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		/* process flags */
		flags = 0;
		repeat:
			++fmt;		/* this also skips first '%' */
			switch (*fmt) {
				case '-': flags |= LEFT; goto repeat;
  104608:	83 ce 10             	or     $0x10,%esi
  10460b:	e9 60 ff ff ff       	jmp    104570 <vsprintf+0x40>
				case '+': flags |= PLUS; goto repeat;
  104610:	83 ce 04             	or     $0x4,%esi
  104613:	e9 58 ff ff ff       	jmp    104570 <vsprintf+0x40>
  104618:	90                   	nop
  104619:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
				case ' ': flags |= SPACE; goto repeat;
				case '#': flags |= SPECIAL; goto repeat;
  104620:	83 ce 20             	or     $0x20,%esi
  104623:	e9 48 ff ff ff       	jmp    104570 <vsprintf+0x40>
  104628:	90                   	nop
  104629:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		repeat:
			++fmt;		/* this also skips first '%' */
			switch (*fmt) {
				case '-': flags |= LEFT; goto repeat;
				case '+': flags |= PLUS; goto repeat;
				case ' ': flags |= SPACE; goto repeat;
  104630:	83 ce 08             	or     $0x8,%esi
  104633:	e9 38 ff ff ff       	jmp    104570 <vsprintf+0x40>
  104638:	90                   	nop
  104639:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			str = number(str, va_arg(args, unsigned long), 8,
				field_width, precision, flags);
			break;

		case 'p':
			if (field_width == -1) {
  104640:	83 fb ff             	cmp    $0xffffffff,%ebx
  104643:	75 0b                	jne    104650 <vsprintf+0x120>
				field_width = 8;
				flags |= ZEROPAD;
  104645:	83 ce 01             	or     $0x1,%esi
				field_width, precision, flags);
			break;

		case 'p':
			if (field_width == -1) {
				field_width = 8;
  104648:	bb 08 00 00 00       	mov    $0x8,%ebx
  10464d:	8d 76 00             	lea    0x0(%esi),%esi
				flags |= ZEROPAD;
			}
			str = number(str,
				(unsigned long) va_arg(args, void *), 16,
  104650:	8b 44 24 38          	mov    0x38(%esp),%eax
		case 'p':
			if (field_width == -1) {
				field_width = 8;
				flags |= ZEROPAD;
			}
			str = number(str,
  104654:	83 ec 04             	sub    $0x4,%esp
  104657:	b9 10 00 00 00       	mov    $0x10,%ecx
				(unsigned long) va_arg(args, void *), 16,
  10465c:	83 c0 04             	add    $0x4,%eax
  10465f:	89 44 24 0c          	mov    %eax,0xc(%esp)
		case 'p':
			if (field_width == -1) {
				field_width = 8;
				flags |= ZEROPAD;
			}
			str = number(str,
  104663:	56                   	push   %esi
  104664:	ff 74 24 08          	pushl  0x8(%esp)
  104668:	53                   	push   %ebx
  104669:	8b 74 24 48          	mov    0x48(%esp),%esi
  10466d:	8b 16                	mov    (%esi),%edx
  10466f:	89 e8                	mov    %ebp,%eax
	int field_width;	/* width of output field */
	int precision;		/* min. # of digits for integers; max
				   number of chars for from string */
	int qualifier;		/* 'h', 'l', or 'L' for integer fields */

	for (str=buf ; *fmt ; ++fmt) {
  104671:	83 c7 01             	add    $0x1,%edi
		case 'p':
			if (field_width == -1) {
				field_width = 8;
				flags |= ZEROPAD;
			}
			str = number(str,
  104674:	e8 47 fc ff ff       	call   1042c0 <number>
  104679:	0f b6 17             	movzbl (%edi),%edx
				(unsigned long) va_arg(args, void *), 16,
				field_width, precision, flags);
			break;
  10467c:	83 c4 10             	add    $0x10,%esp
		case 'p':
			if (field_width == -1) {
				field_width = 8;
				flags |= ZEROPAD;
			}
			str = number(str,
  10467f:	89 c5                	mov    %eax,%ebp
				(unsigned long) va_arg(args, void *), 16,
  104681:	8b 44 24 08          	mov    0x8(%esp),%eax
	int field_width;	/* width of output field */
	int precision;		/* min. # of digits for integers; max
				   number of chars for from string */
	int qualifier;		/* 'h', 'l', or 'L' for integer fields */

	for (str=buf ; *fmt ; ++fmt) {
  104685:	84 d2                	test   %dl,%dl
			if (field_width == -1) {
				field_width = 8;
				flags |= ZEROPAD;
			}
			str = number(str,
				(unsigned long) va_arg(args, void *), 16,
  104687:	89 44 24 38          	mov    %eax,0x38(%esp)
	int field_width;	/* width of output field */
	int precision;		/* min. # of digits for integers; max
				   number of chars for from string */
	int qualifier;		/* 'h', 'l', or 'L' for integer fields */

	for (str=buf ; *fmt ; ++fmt) {
  10468b:	0f 85 d4 fe ff ff    	jne    104565 <vsprintf+0x35>
  104691:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  104698:	89 e8                	mov    %ebp,%eax
  10469a:	2b 44 24 04          	sub    0x4(%esp),%eax
			else
				--fmt;
			break;
		}
	}
	*str = '\0';
  10469e:	c6 45 00 00          	movb   $0x0,0x0(%ebp)
	return str-buf;
}
  1046a2:	83 c4 1c             	add    $0x1c,%esp
  1046a5:	5b                   	pop    %ebx
  1046a6:	5e                   	pop    %esi
  1046a7:	5f                   	pop    %edi
  1046a8:	5d                   	pop    %ebp
  1046a9:	c3                   	ret    
  1046aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		case 'X':
			str = number(str, va_arg(args, unsigned long), 16,
				field_width, precision, flags);
			break;
		case 'b':
			str = number(str, va_arg(args, unsigned long), 2,
  1046b0:	8b 44 24 38          	mov    0x38(%esp),%eax
  1046b4:	83 ec 04             	sub    $0x4,%esp
  1046b7:	b9 02 00 00 00       	mov    $0x2,%ecx
  1046bc:	83 c0 04             	add    $0x4,%eax
  1046bf:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1046c3:	56                   	push   %esi
  1046c4:	89 e8                	mov    %ebp,%eax
  1046c6:	ff 74 24 08          	pushl  0x8(%esp)
  1046ca:	53                   	push   %ebx
  1046cb:	8b 54 24 48          	mov    0x48(%esp),%edx
  1046cf:	8b 12                	mov    (%edx),%edx
  1046d1:	e8 ea fb ff ff       	call   1042c0 <number>
  1046d6:	83 c4 10             	add    $0x10,%esp
  1046d9:	89 c5                	mov    %eax,%ebp
  1046db:	8b 44 24 08          	mov    0x8(%esp),%eax
  1046df:	89 44 24 38          	mov    %eax,0x38(%esp)
				field_width, precision, flags);
		case 'd':
		case 'i':
			flags |= SIGN;
  1046e3:	8b 44 24 38          	mov    0x38(%esp),%eax
  1046e7:	83 ce 02             	or     $0x2,%esi
		case 'u':
			str = number(str, va_arg(args, unsigned long), 10,
  1046ea:	8b 10                	mov    (%eax),%edx
  1046ec:	83 44 24 38 04       	addl   $0x4,0x38(%esp)
  1046f1:	83 ec 04             	sub    $0x4,%esp
  1046f4:	56                   	push   %esi
  1046f5:	ff 74 24 08          	pushl  0x8(%esp)
  1046f9:	89 e8                	mov    %ebp,%eax
  1046fb:	53                   	push   %ebx
  1046fc:	b9 0a 00 00 00       	mov    $0xa,%ecx
  104701:	e8 ba fb ff ff       	call   1042c0 <number>
  104706:	0f b6 57 01          	movzbl 0x1(%edi),%edx
  10470a:	89 c5                	mov    %eax,%ebp
				field_width, precision, flags);
			break;
  10470c:	83 c4 10             	add    $0x10,%esp
  10470f:	e9 46 fe ff ff       	jmp    10455a <vsprintf+0x2a>
  104714:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  104718:	0f b6 47 01          	movzbl 0x1(%edi),%eax

		/* get the conversion qualifier */
		qualifier = -1;
		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L') {
			qualifier = *fmt;
			++fmt;
  10471c:	83 c7 01             	add    $0x1,%edi
		}

		switch (*fmt) {
  10471f:	8d 48 a8             	lea    -0x58(%eax),%ecx
  104722:	80 f9 20             	cmp    $0x20,%cl
  104725:	0f 86 cd fe ff ff    	jbe    1045f8 <vsprintf+0xc8>
			ip = va_arg(args, int *);
			*ip = (str - buf);
			break;

		default:
			if (*fmt != '%')
  10472b:	3c 25                	cmp    $0x25,%al
  10472d:	0f 84 1d fe ff ff    	je     104550 <vsprintf+0x20>
				*str++ = '%';
  104733:	c6 45 00 25          	movb   $0x25,0x0(%ebp)
			if (*fmt)
  104737:	0f b6 17             	movzbl (%edi),%edx
			*ip = (str - buf);
			break;

		default:
			if (*fmt != '%')
				*str++ = '%';
  10473a:	8d 45 01             	lea    0x1(%ebp),%eax
  10473d:	89 c5                	mov    %eax,%ebp
			if (*fmt)
  10473f:	84 d2                	test   %dl,%dl
  104741:	0f 84 53 ff ff ff    	je     10469a <vsprintf+0x16a>
  104747:	e9 04 fe ff ff       	jmp    104550 <vsprintf+0x20>
  10474c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		
		/* get field width */
		field_width = -1;
		if (is_digit(*fmt))
			field_width = skip_atoi(&fmt);
		else if (*fmt == '*') {
  104750:	80 f9 2a             	cmp    $0x2a,%cl
			
		/* process flags */
		flags = 0;
		repeat:
			++fmt;		/* this also skips first '%' */
			switch (*fmt) {
  104753:	89 c8                	mov    %ecx,%eax
				case '#': flags |= SPECIAL; goto repeat;
				case '0': flags |= ZEROPAD; goto repeat;
				}
		
		/* get field width */
		field_width = -1;
  104755:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
		if (is_digit(*fmt))
			field_width = skip_atoi(&fmt);
		else if (*fmt == '*') {
  10475a:	0f 85 66 fe ff ff    	jne    1045c6 <vsprintf+0x96>
			/* it's the next argument */
			field_width = va_arg(args, int);
  104760:	8b 5c 24 38          	mov    0x38(%esp),%ebx
  104764:	8b 44 24 38          	mov    0x38(%esp),%eax
  104768:	8b 1b                	mov    (%ebx),%ebx
  10476a:	83 c0 04             	add    $0x4,%eax
			if (field_width < 0) {
  10476d:	85 db                	test   %ebx,%ebx
  10476f:	0f 88 45 02 00 00    	js     1049ba <vsprintf+0x48a>
			else if (*fmt == '*') {
				/* it's the next argument */
				precision = va_arg(args, int);
			}
			if (precision < 0)
				precision = 0;
  104775:	89 44 24 38          	mov    %eax,0x38(%esp)
				flags |= LEFT;
			}
		}

		/* get the precision */
		precision = -1;
  104779:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
  104780:	b8 2a 00 00 00       	mov    $0x2a,%eax
  104785:	e9 62 fe ff ff       	jmp    1045ec <vsprintf+0xbc>
  10478a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		if (*fmt == '.') {
			++fmt;	
  104790:	8d 47 01             	lea    0x1(%edi),%eax
  104793:	89 44 24 08          	mov    %eax,0x8(%esp)
			if (is_digit(*fmt))
  104797:	0f be 47 01          	movsbl 0x1(%edi),%eax
  10479b:	8d 48 d0             	lea    -0x30(%eax),%ecx
  10479e:	80 f9 09             	cmp    $0x9,%cl
  1047a1:	77 35                	ja     1047d8 <vsprintf+0x2a8>
  1047a3:	8b 7c 24 08          	mov    0x8(%esp),%edi
  1047a7:	89 34 24             	mov    %esi,(%esp)
  1047aa:	31 c9                	xor    %ecx,%ecx
  1047ac:	89 d6                	mov    %edx,%esi
  1047ae:	66 90                	xchg   %ax,%ax
static int skip_atoi(const char **s)
{
	int i=0;

	while (is_digit(**s))
		i = i*10 + *((*s)++) - '0';
  1047b0:	8d 14 89             	lea    (%ecx,%ecx,4),%edx
  1047b3:	83 c7 01             	add    $0x1,%edi
  1047b6:	8d 4c 50 d0          	lea    -0x30(%eax,%edx,2),%ecx

static int skip_atoi(const char **s)
{
	int i=0;

	while (is_digit(**s))
  1047ba:	0f be 07             	movsbl (%edi),%eax
  1047bd:	8d 50 d0             	lea    -0x30(%eax),%edx
  1047c0:	80 fa 09             	cmp    $0x9,%dl
  1047c3:	76 eb                	jbe    1047b0 <vsprintf+0x280>
  1047c5:	89 f2                	mov    %esi,%edx
  1047c7:	8b 34 24             	mov    (%esp),%esi
  1047ca:	89 0c 24             	mov    %ecx,(%esp)
  1047cd:	e9 04 fe ff ff       	jmp    1045d6 <vsprintf+0xa6>
  1047d2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		precision = -1;
		if (*fmt == '.') {
			++fmt;	
			if (is_digit(*fmt))
				precision = skip_atoi(&fmt);
			else if (*fmt == '*') {
  1047d8:	3c 2a                	cmp    $0x2a,%al
  1047da:	0f 84 b4 01 00 00    	je     104994 <vsprintf+0x464>
		}

		/* get the precision */
		precision = -1;
		if (*fmt == '.') {
			++fmt;	
  1047e0:	8b 7c 24 08          	mov    0x8(%esp),%edi
			else if (*fmt == '*') {
				/* it's the next argument */
				precision = va_arg(args, int);
			}
			if (precision < 0)
				precision = 0;
  1047e4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1047eb:	e9 e6 fd ff ff       	jmp    1045d6 <vsprintf+0xa6>
		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L') {
			qualifier = *fmt;
			++fmt;
		}

		switch (*fmt) {
  1047f0:	8b 44 24 38          	mov    0x38(%esp),%eax
  1047f4:	e9 f1 fe ff ff       	jmp    1046ea <vsprintf+0x1ba>
  1047f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
				(unsigned long) va_arg(args, void *), 16,
				field_width, precision, flags);
			break;

		case 'x':
			flags |= SMALL;
  104800:	83 ce 40             	or     $0x40,%esi
  104803:	e9 48 fe ff ff       	jmp    104650 <vsprintf+0x120>
  104808:	90                   	nop
  104809:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			while (--field_width > 0)
				*str++ = ' ';
			break;

		case 's':
			s = va_arg(args, char *);
  104810:	8b 44 24 38          	mov    0x38(%esp),%eax
			len = strlen(s);
  104814:	83 ec 0c             	sub    $0xc,%esp
			while (--field_width > 0)
				*str++ = ' ';
			break;

		case 's':
			s = va_arg(args, char *);
  104817:	83 c0 04             	add    $0x4,%eax
  10481a:	89 44 24 18          	mov    %eax,0x18(%esp)
  10481e:	8b 44 24 44          	mov    0x44(%esp),%eax
  104822:	8b 10                	mov    (%eax),%edx
			len = strlen(s);
  104824:	52                   	push   %edx
  104825:	89 54 24 18          	mov    %edx,0x18(%esp)
  104829:	e8 f2 f9 ff ff       	call   104220 <strlen>
			if (precision < 0)
				precision = len;
			else if (len > precision)
  10482e:	83 c4 10             	add    $0x10,%esp
  104831:	8b 0c 24             	mov    (%esp),%ecx
  104834:	8b 54 24 08          	mov    0x8(%esp),%edx
  104838:	39 c1                	cmp    %eax,%ecx
  10483a:	0f 8d 4c 01 00 00    	jge    10498c <vsprintf+0x45c>
  104840:	83 f9 ff             	cmp    $0xffffffff,%ecx
  104843:	0f 84 43 01 00 00    	je     10498c <vsprintf+0x45c>
				len = precision;

			if (!(flags & LEFT))
  104849:	83 e6 10             	and    $0x10,%esi
  10484c:	75 2d                	jne    10487b <vsprintf+0x34b>
				while (len < field_width--)
  10484e:	8b 34 24             	mov    (%esp),%esi
  104851:	8d 4b ff             	lea    -0x1(%ebx),%ecx
  104854:	39 de                	cmp    %ebx,%esi
  104856:	0f 8d 98 01 00 00    	jge    1049f4 <vsprintf+0x4c4>
  10485c:	89 d8                	mov    %ebx,%eax
  10485e:	29 f0                	sub    %esi,%eax
  104860:	01 e8                	add    %ebp,%eax
  104862:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
					*str++ = ' ';
  104868:	83 c5 01             	add    $0x1,%ebp
  10486b:	c6 45 ff 20          	movb   $0x20,-0x1(%ebp)
				precision = len;
			else if (len > precision)
				len = precision;

			if (!(flags & LEFT))
				while (len < field_width--)
  10486f:	39 c5                	cmp    %eax,%ebp
  104871:	75 f5                	jne    104868 <vsprintf+0x338>
  104873:	8b 04 24             	mov    (%esp),%eax
  104876:	29 d9                	sub    %ebx,%ecx
  104878:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
					*str++ = ' ';
			for (i = 0; i < len; ++i)
  10487b:	8b 34 24             	mov    (%esp),%esi
  10487e:	85 f6                	test   %esi,%esi
  104880:	0f 8e 45 01 00 00    	jle    1049cb <vsprintf+0x49b>
  104886:	31 c0                	xor    %eax,%eax
  104888:	90                   	nop
  104889:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
				*str++ = *s++;
  104890:	0f b6 0c 02          	movzbl (%edx,%eax,1),%ecx
  104894:	88 4c 05 00          	mov    %cl,0x0(%ebp,%eax,1)
				len = precision;

			if (!(flags & LEFT))
				while (len < field_width--)
					*str++ = ' ';
			for (i = 0; i < len; ++i)
  104898:	83 c0 01             	add    $0x1,%eax
  10489b:	39 f0                	cmp    %esi,%eax
  10489d:	75 f1                	jne    104890 <vsprintf+0x360>
  10489f:	8b 04 24             	mov    (%esp),%eax
  1048a2:	01 e8                	add    %ebp,%eax
  1048a4:	8b 34 24             	mov    (%esp),%esi
  1048a7:	89 dd                	mov    %ebx,%ebp
  1048a9:	29 f5                	sub    %esi,%ebp
  1048ab:	01 c5                	add    %eax,%ebp
				*str++ = *s++;
			while (len < field_width--)
  1048ad:	39 de                	cmp    %ebx,%esi
  1048af:	0f 8d 2c 01 00 00    	jge    1049e1 <vsprintf+0x4b1>
  1048b5:	8d 76 00             	lea    0x0(%esi),%esi
				*str++ = ' ';
  1048b8:	83 c0 01             	add    $0x1,%eax
  1048bb:	c6 40 ff 20          	movb   $0x20,-0x1(%eax)
			if (!(flags & LEFT))
				while (len < field_width--)
					*str++ = ' ';
			for (i = 0; i < len; ++i)
				*str++ = *s++;
			while (len < field_width--)
  1048bf:	39 e8                	cmp    %ebp,%eax
  1048c1:	75 f5                	jne    1048b8 <vsprintf+0x388>
			while (--field_width > 0)
				*str++ = ' ';
			break;

		case 's':
			s = va_arg(args, char *);
  1048c3:	8b 44 24 0c          	mov    0xc(%esp),%eax
  1048c7:	0f b6 57 01          	movzbl 0x1(%edi),%edx
  1048cb:	89 44 24 38          	mov    %eax,0x38(%esp)
  1048cf:	e9 86 fc ff ff       	jmp    10455a <vsprintf+0x2a>
  1048d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			while (len < field_width--)
				*str++ = ' ';
			break;

		case 'o':
			str = number(str, va_arg(args, unsigned long), 8,
  1048d8:	8b 44 24 38          	mov    0x38(%esp),%eax
  1048dc:	83 ec 04             	sub    $0x4,%esp
  1048df:	b9 08 00 00 00       	mov    $0x8,%ecx
  1048e4:	83 c0 04             	add    $0x4,%eax
  1048e7:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1048eb:	56                   	push   %esi
  1048ec:	ff 74 24 08          	pushl  0x8(%esp)
  1048f0:	53                   	push   %ebx
  1048f1:	8b 5c 24 48          	mov    0x48(%esp),%ebx
  1048f5:	8b 13                	mov    (%ebx),%edx
  1048f7:	e9 73 fd ff ff       	jmp    10466f <vsprintf+0x13f>
  1048fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				field_width, precision, flags);
			break;

		case 'n':
			ip = va_arg(args, int *);
			*ip = (str - buf);
  104900:	8b 44 24 38          	mov    0x38(%esp),%eax
  104904:	89 ea                	mov    %ebp,%edx
  104906:	2b 54 24 04          	sub    0x4(%esp),%edx
  10490a:	8b 00                	mov    (%eax),%eax
  10490c:	89 10                	mov    %edx,(%eax)
			str = number(str, va_arg(args, unsigned long), 10,
				field_width, precision, flags);
			break;

		case 'n':
			ip = va_arg(args, int *);
  10490e:	8b 44 24 38          	mov    0x38(%esp),%eax
  104912:	0f b6 57 01          	movzbl 0x1(%edi),%edx
  104916:	83 c0 04             	add    $0x4,%eax
  104919:	89 44 24 38          	mov    %eax,0x38(%esp)
			*ip = (str - buf);
			break;
  10491d:	e9 38 fc ff ff       	jmp    10455a <vsprintf+0x2a>
  104922:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			++fmt;
		}

		switch (*fmt) {
		case 'c':
			if (!(flags & LEFT))
  104928:	83 e6 10             	and    $0x10,%esi
  10492b:	75 20                	jne    10494d <vsprintf+0x41d>
				while (--field_width > 0)
  10492d:	83 eb 01             	sub    $0x1,%ebx
  104930:	85 db                	test   %ebx,%ebx
  104932:	7e 19                	jle    10494d <vsprintf+0x41d>
  104934:	8d 44 1d 00          	lea    0x0(%ebp,%ebx,1),%eax
  104938:	90                   	nop
  104939:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
					*str++ = ' ';
  104940:	83 c5 01             	add    $0x1,%ebp
  104943:	c6 45 ff 20          	movb   $0x20,-0x1(%ebp)
		}

		switch (*fmt) {
		case 'c':
			if (!(flags & LEFT))
				while (--field_width > 0)
  104947:	39 c5                	cmp    %eax,%ebp
  104949:	75 f5                	jne    104940 <vsprintf+0x410>
  10494b:	31 db                	xor    %ebx,%ebx
					*str++ = ' ';
			*str++ = (unsigned char) va_arg(args, int);
  10494d:	8b 74 24 38          	mov    0x38(%esp),%esi
  104951:	8b 44 24 38          	mov    0x38(%esp),%eax
  104955:	8b 16                	mov    (%esi),%edx
  104957:	8d 48 04             	lea    0x4(%eax),%ecx
  10495a:	8d 45 01             	lea    0x1(%ebp),%eax
  10495d:	88 55 00             	mov    %dl,0x0(%ebp)
  104960:	01 dd                	add    %ebx,%ebp
			while (--field_width > 0)
  104962:	83 fb 01             	cmp    $0x1,%ebx
  104965:	89 c2                	mov    %eax,%edx
  104967:	7e 69                	jle    1049d2 <vsprintf+0x4a2>
  104969:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
				*str++ = ' ';
  104970:	83 c2 01             	add    $0x1,%edx
  104973:	c6 42 ff 20          	movb   $0x20,-0x1(%edx)
		case 'c':
			if (!(flags & LEFT))
				while (--field_width > 0)
					*str++ = ' ';
			*str++ = (unsigned char) va_arg(args, int);
			while (--field_width > 0)
  104977:	39 ea                	cmp    %ebp,%edx
  104979:	75 f5                	jne    104970 <vsprintf+0x440>
  10497b:	8d 6c 18 ff          	lea    -0x1(%eax,%ebx,1),%ebp
  10497f:	0f b6 57 01          	movzbl 0x1(%edi),%edx
		switch (*fmt) {
		case 'c':
			if (!(flags & LEFT))
				while (--field_width > 0)
					*str++ = ' ';
			*str++ = (unsigned char) va_arg(args, int);
  104983:	89 4c 24 38          	mov    %ecx,0x38(%esp)
  104987:	e9 ce fb ff ff       	jmp    10455a <vsprintf+0x2a>
				*str++ = ' ';
			break;

		case 's':
			s = va_arg(args, char *);
			len = strlen(s);
  10498c:	89 04 24             	mov    %eax,(%esp)
  10498f:	e9 b5 fe ff ff       	jmp    104849 <vsprintf+0x319>
			++fmt;	
			if (is_digit(*fmt))
				precision = skip_atoi(&fmt);
			else if (*fmt == '*') {
				/* it's the next argument */
				precision = va_arg(args, int);
  104994:	8b 7c 24 38          	mov    0x38(%esp),%edi
  104998:	8b 44 24 38          	mov    0x38(%esp),%eax
  10499c:	8b 3f                	mov    (%edi),%edi
  10499e:	83 c0 04             	add    $0x4,%eax
			}
			if (precision < 0)
  1049a1:	85 ff                	test   %edi,%edi
			++fmt;	
			if (is_digit(*fmt))
				precision = skip_atoi(&fmt);
			else if (*fmt == '*') {
				/* it's the next argument */
				precision = va_arg(args, int);
  1049a3:	89 3c 24             	mov    %edi,(%esp)
			}
			if (precision < 0)
  1049a6:	78 53                	js     1049fb <vsprintf+0x4cb>
			++fmt;	
			if (is_digit(*fmt))
				precision = skip_atoi(&fmt);
			else if (*fmt == '*') {
				/* it's the next argument */
				precision = va_arg(args, int);
  1049a8:	89 44 24 38          	mov    %eax,0x38(%esp)
		}

		/* get the precision */
		precision = -1;
		if (*fmt == '.') {
			++fmt;	
  1049ac:	8b 7c 24 08          	mov    0x8(%esp),%edi
  1049b0:	b8 2a 00 00 00       	mov    $0x2a,%eax
  1049b5:	e9 1c fc ff ff       	jmp    1045d6 <vsprintf+0xa6>
			field_width = skip_atoi(&fmt);
		else if (*fmt == '*') {
			/* it's the next argument */
			field_width = va_arg(args, int);
			if (field_width < 0) {
				field_width = -field_width;
  1049ba:	f7 db                	neg    %ebx
				flags |= LEFT;
  1049bc:	83 ce 10             	or     $0x10,%esi
  1049bf:	e9 b1 fd ff ff       	jmp    104775 <vsprintf+0x245>
	int field_width;	/* width of output field */
	int precision;		/* min. # of digits for integers; max
				   number of chars for from string */
	int qualifier;		/* 'h', 'l', or 'L' for integer fields */

	for (str=buf ; *fmt ; ++fmt) {
  1049c4:	31 c0                	xor    %eax,%eax
  1049c6:	e9 d3 fc ff ff       	jmp    10469e <vsprintf+0x16e>
				len = precision;

			if (!(flags & LEFT))
				while (len < field_width--)
					*str++ = ' ';
			for (i = 0; i < len; ++i)
  1049cb:	89 e8                	mov    %ebp,%eax
  1049cd:	e9 d2 fe ff ff       	jmp    1048a4 <vsprintf+0x374>
  1049d2:	0f b6 57 01          	movzbl 0x1(%edi),%edx
		switch (*fmt) {
		case 'c':
			if (!(flags & LEFT))
				while (--field_width > 0)
					*str++ = ' ';
			*str++ = (unsigned char) va_arg(args, int);
  1049d6:	89 c5                	mov    %eax,%ebp
  1049d8:	89 4c 24 38          	mov    %ecx,0x38(%esp)
  1049dc:	e9 79 fb ff ff       	jmp    10455a <vsprintf+0x2a>
			if (!(flags & LEFT))
				while (len < field_width--)
					*str++ = ' ';
			for (i = 0; i < len; ++i)
				*str++ = *s++;
			while (len < field_width--)
  1049e1:	89 c5                	mov    %eax,%ebp
			while (--field_width > 0)
				*str++ = ' ';
			break;

		case 's':
			s = va_arg(args, char *);
  1049e3:	8b 44 24 0c          	mov    0xc(%esp),%eax
  1049e7:	0f b6 57 01          	movzbl 0x1(%edi),%edx
  1049eb:	89 44 24 38          	mov    %eax,0x38(%esp)
  1049ef:	e9 66 fb ff ff       	jmp    10455a <vsprintf+0x2a>
				precision = len;
			else if (len > precision)
				len = precision;

			if (!(flags & LEFT))
				while (len < field_width--)
  1049f4:	89 cb                	mov    %ecx,%ebx
  1049f6:	e9 80 fe ff ff       	jmp    10487b <vsprintf+0x34b>
			++fmt;	
			if (is_digit(*fmt))
				precision = skip_atoi(&fmt);
			else if (*fmt == '*') {
				/* it's the next argument */
				precision = va_arg(args, int);
  1049fb:	89 44 24 38          	mov    %eax,0x38(%esp)
		}

		/* get the precision */
		precision = -1;
		if (*fmt == '.') {
			++fmt;	
  1049ff:	8b 7c 24 08          	mov    0x8(%esp),%edi
  104a03:	e9 2b fd ff ff       	jmp    104733 <vsprintf+0x203>
  104a08:	66 90                	xchg   %ax,%ax
  104a0a:	66 90                	xchg   %ax,%ax
  104a0c:	66 90                	xchg   %ax,%ax
  104a0e:	66 90                	xchg   %ax,%ax
  104a10:	66 90                	xchg   %ax,%ax
  104a12:	66 90                	xchg   %ax,%ax
  104a14:	66 90                	xchg   %ax,%ax
  104a16:	66 90                	xchg   %ax,%ax
  104a18:	66 90                	xchg   %ax,%ax
  104a1a:	66 90                	xchg   %ax,%ax
  104a1c:	66 90                	xchg   %ax,%ax
  104a1e:	66 90                	xchg   %ax,%ax
  104a20:	66 90                	xchg   %ax,%ax
  104a22:	66 90                	xchg   %ax,%ax
  104a24:	66 90                	xchg   %ax,%ax
  104a26:	66 90                	xchg   %ax,%ax
  104a28:	66 90                	xchg   %ax,%ax
  104a2a:	66 90                	xchg   %ax,%ax
  104a2c:	66 90                	xchg   %ax,%ax
  104a2e:	66 90                	xchg   %ax,%ax
  104a30:	66 90                	xchg   %ax,%ax
  104a32:	66 90                	xchg   %ax,%ax
  104a34:	66 90                	xchg   %ax,%ax
  104a36:	66 90                	xchg   %ax,%ax
  104a38:	66 90                	xchg   %ax,%ax
  104a3a:	66 90                	xchg   %ax,%ax
  104a3c:	66 90                	xchg   %ax,%ax
  104a3e:	66 90                	xchg   %ax,%ax
  104a40:	66 90                	xchg   %ax,%ax
  104a42:	66 90                	xchg   %ax,%ax
  104a44:	66 90                	xchg   %ax,%ax
  104a46:	66 90                	xchg   %ax,%ax
  104a48:	66 90                	xchg   %ax,%ax
  104a4a:	66 90                	xchg   %ax,%ax
  104a4c:	66 90                	xchg   %ax,%ax
  104a4e:	66 90                	xchg   %ax,%ax
  104a50:	66 90                	xchg   %ax,%ax
  104a52:	66 90                	xchg   %ax,%ax
  104a54:	66 90                	xchg   %ax,%ax
  104a56:	66 90                	xchg   %ax,%ax
  104a58:	66 90                	xchg   %ax,%ax
  104a5a:	66 90                	xchg   %ax,%ax
  104a5c:	66 90                	xchg   %ax,%ax
  104a5e:	66 90                	xchg   %ax,%ax
  104a60:	66 90                	xchg   %ax,%ax
  104a62:	66 90                	xchg   %ax,%ax
  104a64:	66 90                	xchg   %ax,%ax
  104a66:	66 90                	xchg   %ax,%ax
  104a68:	66 90                	xchg   %ax,%ax
  104a6a:	66 90                	xchg   %ax,%ax
  104a6c:	66 90                	xchg   %ax,%ax
  104a6e:	66 90                	xchg   %ax,%ax
  104a70:	66 90                	xchg   %ax,%ax
  104a72:	66 90                	xchg   %ax,%ax
  104a74:	66 90                	xchg   %ax,%ax
  104a76:	66 90                	xchg   %ax,%ax
  104a78:	66 90                	xchg   %ax,%ax
  104a7a:	66 90                	xchg   %ax,%ax
  104a7c:	66 90                	xchg   %ax,%ax
  104a7e:	66 90                	xchg   %ax,%ax
  104a80:	66 90                	xchg   %ax,%ax
  104a82:	66 90                	xchg   %ax,%ax
  104a84:	66 90                	xchg   %ax,%ax
  104a86:	66 90                	xchg   %ax,%ax
  104a88:	66 90                	xchg   %ax,%ax
  104a8a:	66 90                	xchg   %ax,%ax
  104a8c:	66 90                	xchg   %ax,%ax
  104a8e:	66 90                	xchg   %ax,%ax
  104a90:	66 90                	xchg   %ax,%ax
  104a92:	66 90                	xchg   %ax,%ax
  104a94:	66 90                	xchg   %ax,%ax
  104a96:	66 90                	xchg   %ax,%ax
  104a98:	66 90                	xchg   %ax,%ax
  104a9a:	66 90                	xchg   %ax,%ax
  104a9c:	66 90                	xchg   %ax,%ax
  104a9e:	66 90                	xchg   %ax,%ax
  104aa0:	66 90                	xchg   %ax,%ax
  104aa2:	66 90                	xchg   %ax,%ax
  104aa4:	66 90                	xchg   %ax,%ax
  104aa6:	66 90                	xchg   %ax,%ax
  104aa8:	66 90                	xchg   %ax,%ax
  104aaa:	66 90                	xchg   %ax,%ax
  104aac:	66 90                	xchg   %ax,%ax
  104aae:	66 90                	xchg   %ax,%ax
  104ab0:	66 90                	xchg   %ax,%ax
  104ab2:	66 90                	xchg   %ax,%ax
  104ab4:	66 90                	xchg   %ax,%ax
  104ab6:	66 90                	xchg   %ax,%ax
  104ab8:	66 90                	xchg   %ax,%ax
  104aba:	66 90                	xchg   %ax,%ax
  104abc:	66 90                	xchg   %ax,%ax
  104abe:	66 90                	xchg   %ax,%ax
  104ac0:	66 90                	xchg   %ax,%ax
  104ac2:	66 90                	xchg   %ax,%ax
  104ac4:	66 90                	xchg   %ax,%ax
  104ac6:	66 90                	xchg   %ax,%ax
  104ac8:	66 90                	xchg   %ax,%ax
  104aca:	66 90                	xchg   %ax,%ax
  104acc:	66 90                	xchg   %ax,%ax
  104ace:	66 90                	xchg   %ax,%ax
  104ad0:	66 90                	xchg   %ax,%ax
  104ad2:	66 90                	xchg   %ax,%ax
  104ad4:	66 90                	xchg   %ax,%ax
  104ad6:	66 90                	xchg   %ax,%ax
  104ad8:	66 90                	xchg   %ax,%ax
  104ada:	66 90                	xchg   %ax,%ax
  104adc:	66 90                	xchg   %ax,%ax
  104ade:	66 90                	xchg   %ax,%ax
  104ae0:	66 90                	xchg   %ax,%ax
  104ae2:	66 90                	xchg   %ax,%ax
  104ae4:	66 90                	xchg   %ax,%ax
  104ae6:	66 90                	xchg   %ax,%ax
  104ae8:	66 90                	xchg   %ax,%ax
  104aea:	66 90                	xchg   %ax,%ax
  104aec:	66 90                	xchg   %ax,%ax
  104aee:	66 90                	xchg   %ax,%ax
  104af0:	66 90                	xchg   %ax,%ax
  104af2:	66 90                	xchg   %ax,%ax
  104af4:	66 90                	xchg   %ax,%ax
  104af6:	66 90                	xchg   %ax,%ax
  104af8:	66 90                	xchg   %ax,%ax
  104afa:	66 90                	xchg   %ax,%ax
  104afc:	66 90                	xchg   %ax,%ax
  104afe:	66 90                	xchg   %ax,%ax
  104b00:	66 90                	xchg   %ax,%ax
  104b02:	66 90                	xchg   %ax,%ax
  104b04:	66 90                	xchg   %ax,%ax
  104b06:	66 90                	xchg   %ax,%ax
  104b08:	66 90                	xchg   %ax,%ax
  104b0a:	66 90                	xchg   %ax,%ax
  104b0c:	66 90                	xchg   %ax,%ax
  104b0e:	66 90                	xchg   %ax,%ax
  104b10:	66 90                	xchg   %ax,%ax
  104b12:	66 90                	xchg   %ax,%ax
  104b14:	66 90                	xchg   %ax,%ax
  104b16:	66 90                	xchg   %ax,%ax
  104b18:	66 90                	xchg   %ax,%ax
  104b1a:	66 90                	xchg   %ax,%ax
  104b1c:	66 90                	xchg   %ax,%ax
  104b1e:	66 90                	xchg   %ax,%ax
  104b20:	66 90                	xchg   %ax,%ax
  104b22:	66 90                	xchg   %ax,%ax
  104b24:	66 90                	xchg   %ax,%ax
  104b26:	66 90                	xchg   %ax,%ax
  104b28:	66 90                	xchg   %ax,%ax
  104b2a:	66 90                	xchg   %ax,%ax
  104b2c:	66 90                	xchg   %ax,%ax
  104b2e:	66 90                	xchg   %ax,%ax
  104b30:	66 90                	xchg   %ax,%ax
  104b32:	66 90                	xchg   %ax,%ax
  104b34:	66 90                	xchg   %ax,%ax
  104b36:	66 90                	xchg   %ax,%ax
  104b38:	66 90                	xchg   %ax,%ax
  104b3a:	66 90                	xchg   %ax,%ax
  104b3c:	66 90                	xchg   %ax,%ax
  104b3e:	66 90                	xchg   %ax,%ax
  104b40:	66 90                	xchg   %ax,%ax
  104b42:	66 90                	xchg   %ax,%ax
  104b44:	66 90                	xchg   %ax,%ax
  104b46:	66 90                	xchg   %ax,%ax
  104b48:	66 90                	xchg   %ax,%ax
  104b4a:	66 90                	xchg   %ax,%ax
  104b4c:	66 90                	xchg   %ax,%ax
  104b4e:	66 90                	xchg   %ax,%ax
  104b50:	66 90                	xchg   %ax,%ax
  104b52:	66 90                	xchg   %ax,%ax
  104b54:	66 90                	xchg   %ax,%ax
  104b56:	66 90                	xchg   %ax,%ax
  104b58:	66 90                	xchg   %ax,%ax
  104b5a:	66 90                	xchg   %ax,%ax
  104b5c:	66 90                	xchg   %ax,%ax
  104b5e:	66 90                	xchg   %ax,%ax
  104b60:	66 90                	xchg   %ax,%ax
  104b62:	66 90                	xchg   %ax,%ax
  104b64:	66 90                	xchg   %ax,%ax
  104b66:	66 90                	xchg   %ax,%ax
  104b68:	66 90                	xchg   %ax,%ax
  104b6a:	66 90                	xchg   %ax,%ax
  104b6c:	66 90                	xchg   %ax,%ax
  104b6e:	66 90                	xchg   %ax,%ax
  104b70:	66 90                	xchg   %ax,%ax
  104b72:	66 90                	xchg   %ax,%ax
  104b74:	66 90                	xchg   %ax,%ax
  104b76:	66 90                	xchg   %ax,%ax
  104b78:	66 90                	xchg   %ax,%ax
  104b7a:	66 90                	xchg   %ax,%ax
  104b7c:	66 90                	xchg   %ax,%ax
  104b7e:	66 90                	xchg   %ax,%ax
  104b80:	66 90                	xchg   %ax,%ax
  104b82:	66 90                	xchg   %ax,%ax
  104b84:	66 90                	xchg   %ax,%ax
  104b86:	66 90                	xchg   %ax,%ax
  104b88:	66 90                	xchg   %ax,%ax
  104b8a:	66 90                	xchg   %ax,%ax
  104b8c:	66 90                	xchg   %ax,%ax
  104b8e:	66 90                	xchg   %ax,%ax
  104b90:	66 90                	xchg   %ax,%ax
  104b92:	66 90                	xchg   %ax,%ax
  104b94:	66 90                	xchg   %ax,%ax
  104b96:	66 90                	xchg   %ax,%ax
  104b98:	66 90                	xchg   %ax,%ax
  104b9a:	66 90                	xchg   %ax,%ax
  104b9c:	66 90                	xchg   %ax,%ax
  104b9e:	66 90                	xchg   %ax,%ax
  104ba0:	66 90                	xchg   %ax,%ax
  104ba2:	66 90                	xchg   %ax,%ax
  104ba4:	66 90                	xchg   %ax,%ax
  104ba6:	66 90                	xchg   %ax,%ax
  104ba8:	66 90                	xchg   %ax,%ax
  104baa:	66 90                	xchg   %ax,%ax
  104bac:	66 90                	xchg   %ax,%ax
  104bae:	66 90                	xchg   %ax,%ax
  104bb0:	66 90                	xchg   %ax,%ax
  104bb2:	66 90                	xchg   %ax,%ax
  104bb4:	66 90                	xchg   %ax,%ax
  104bb6:	66 90                	xchg   %ax,%ax
  104bb8:	66 90                	xchg   %ax,%ax
  104bba:	66 90                	xchg   %ax,%ax
  104bbc:	66 90                	xchg   %ax,%ax
  104bbe:	66 90                	xchg   %ax,%ax
  104bc0:	66 90                	xchg   %ax,%ax
  104bc2:	66 90                	xchg   %ax,%ax
  104bc4:	66 90                	xchg   %ax,%ax
  104bc6:	66 90                	xchg   %ax,%ax
  104bc8:	66 90                	xchg   %ax,%ax
  104bca:	66 90                	xchg   %ax,%ax
  104bcc:	66 90                	xchg   %ax,%ax
  104bce:	66 90                	xchg   %ax,%ax
  104bd0:	66 90                	xchg   %ax,%ax
  104bd2:	66 90                	xchg   %ax,%ax
  104bd4:	66 90                	xchg   %ax,%ax
  104bd6:	66 90                	xchg   %ax,%ax
  104bd8:	66 90                	xchg   %ax,%ax
  104bda:	66 90                	xchg   %ax,%ax
  104bdc:	66 90                	xchg   %ax,%ax
  104bde:	66 90                	xchg   %ax,%ax
  104be0:	66 90                	xchg   %ax,%ax
  104be2:	66 90                	xchg   %ax,%ax
  104be4:	66 90                	xchg   %ax,%ax
  104be6:	66 90                	xchg   %ax,%ax
  104be8:	66 90                	xchg   %ax,%ax
  104bea:	66 90                	xchg   %ax,%ax
  104bec:	66 90                	xchg   %ax,%ax
  104bee:	66 90                	xchg   %ax,%ax
  104bf0:	66 90                	xchg   %ax,%ax
  104bf2:	66 90                	xchg   %ax,%ax
  104bf4:	66 90                	xchg   %ax,%ax
  104bf6:	66 90                	xchg   %ax,%ax
  104bf8:	66 90                	xchg   %ax,%ax
  104bfa:	66 90                	xchg   %ax,%ax
  104bfc:	66 90                	xchg   %ax,%ax
  104bfe:	66 90                	xchg   %ax,%ax
  104c00:	66 90                	xchg   %ax,%ax
  104c02:	66 90                	xchg   %ax,%ax
  104c04:	66 90                	xchg   %ax,%ax
  104c06:	66 90                	xchg   %ax,%ax
  104c08:	66 90                	xchg   %ax,%ax
  104c0a:	66 90                	xchg   %ax,%ax
  104c0c:	66 90                	xchg   %ax,%ax
  104c0e:	66 90                	xchg   %ax,%ax
  104c10:	66 90                	xchg   %ax,%ax
  104c12:	66 90                	xchg   %ax,%ax
  104c14:	66 90                	xchg   %ax,%ax
  104c16:	66 90                	xchg   %ax,%ax
  104c18:	66 90                	xchg   %ax,%ax
  104c1a:	66 90                	xchg   %ax,%ax
  104c1c:	66 90                	xchg   %ax,%ax
  104c1e:	66 90                	xchg   %ax,%ax
  104c20:	66 90                	xchg   %ax,%ax
  104c22:	66 90                	xchg   %ax,%ax
  104c24:	66 90                	xchg   %ax,%ax
  104c26:	66 90                	xchg   %ax,%ax
  104c28:	66 90                	xchg   %ax,%ax
  104c2a:	66 90                	xchg   %ax,%ax
  104c2c:	66 90                	xchg   %ax,%ax
  104c2e:	66 90                	xchg   %ax,%ax
  104c30:	66 90                	xchg   %ax,%ax
  104c32:	66 90                	xchg   %ax,%ax
  104c34:	66 90                	xchg   %ax,%ax
  104c36:	66 90                	xchg   %ax,%ax
  104c38:	66 90                	xchg   %ax,%ax
  104c3a:	66 90                	xchg   %ax,%ax
  104c3c:	66 90                	xchg   %ax,%ax
  104c3e:	66 90                	xchg   %ax,%ax
  104c40:	66 90                	xchg   %ax,%ax
  104c42:	66 90                	xchg   %ax,%ax
  104c44:	66 90                	xchg   %ax,%ax
  104c46:	66 90                	xchg   %ax,%ax
  104c48:	66 90                	xchg   %ax,%ax
  104c4a:	66 90                	xchg   %ax,%ax
  104c4c:	66 90                	xchg   %ax,%ax
  104c4e:	66 90                	xchg   %ax,%ax
  104c50:	66 90                	xchg   %ax,%ax
  104c52:	66 90                	xchg   %ax,%ax
  104c54:	66 90                	xchg   %ax,%ax
  104c56:	66 90                	xchg   %ax,%ax
  104c58:	66 90                	xchg   %ax,%ax
  104c5a:	66 90                	xchg   %ax,%ax
  104c5c:	66 90                	xchg   %ax,%ax
  104c5e:	66 90                	xchg   %ax,%ax
  104c60:	66 90                	xchg   %ax,%ax
  104c62:	66 90                	xchg   %ax,%ax
  104c64:	66 90                	xchg   %ax,%ax
  104c66:	66 90                	xchg   %ax,%ax
  104c68:	66 90                	xchg   %ax,%ax
  104c6a:	66 90                	xchg   %ax,%ax
  104c6c:	66 90                	xchg   %ax,%ax
  104c6e:	66 90                	xchg   %ax,%ax
  104c70:	66 90                	xchg   %ax,%ax
  104c72:	66 90                	xchg   %ax,%ax
  104c74:	66 90                	xchg   %ax,%ax
  104c76:	66 90                	xchg   %ax,%ax
  104c78:	66 90                	xchg   %ax,%ax
  104c7a:	66 90                	xchg   %ax,%ax
  104c7c:	66 90                	xchg   %ax,%ax
  104c7e:	66 90                	xchg   %ax,%ax
  104c80:	66 90                	xchg   %ax,%ax
  104c82:	66 90                	xchg   %ax,%ax
  104c84:	66 90                	xchg   %ax,%ax
  104c86:	66 90                	xchg   %ax,%ax
  104c88:	66 90                	xchg   %ax,%ax
  104c8a:	66 90                	xchg   %ax,%ax
  104c8c:	66 90                	xchg   %ax,%ax
  104c8e:	66 90                	xchg   %ax,%ax
  104c90:	66 90                	xchg   %ax,%ax
  104c92:	66 90                	xchg   %ax,%ax
  104c94:	66 90                	xchg   %ax,%ax
  104c96:	66 90                	xchg   %ax,%ax
  104c98:	66 90                	xchg   %ax,%ax
  104c9a:	66 90                	xchg   %ax,%ax
  104c9c:	66 90                	xchg   %ax,%ax
  104c9e:	66 90                	xchg   %ax,%ax
  104ca0:	66 90                	xchg   %ax,%ax
  104ca2:	66 90                	xchg   %ax,%ax
  104ca4:	66 90                	xchg   %ax,%ax
  104ca6:	66 90                	xchg   %ax,%ax
  104ca8:	66 90                	xchg   %ax,%ax
  104caa:	66 90                	xchg   %ax,%ax
  104cac:	66 90                	xchg   %ax,%ax
  104cae:	66 90                	xchg   %ax,%ax
  104cb0:	66 90                	xchg   %ax,%ax
  104cb2:	66 90                	xchg   %ax,%ax
  104cb4:	66 90                	xchg   %ax,%ax
  104cb6:	66 90                	xchg   %ax,%ax
  104cb8:	66 90                	xchg   %ax,%ax
  104cba:	66 90                	xchg   %ax,%ax
  104cbc:	66 90                	xchg   %ax,%ax
  104cbe:	66 90                	xchg   %ax,%ax
  104cc0:	66 90                	xchg   %ax,%ax
  104cc2:	66 90                	xchg   %ax,%ax
  104cc4:	66 90                	xchg   %ax,%ax
  104cc6:	66 90                	xchg   %ax,%ax
  104cc8:	66 90                	xchg   %ax,%ax
  104cca:	66 90                	xchg   %ax,%ax
  104ccc:	66 90                	xchg   %ax,%ax
  104cce:	66 90                	xchg   %ax,%ax
  104cd0:	66 90                	xchg   %ax,%ax
  104cd2:	66 90                	xchg   %ax,%ax
  104cd4:	66 90                	xchg   %ax,%ax
  104cd6:	66 90                	xchg   %ax,%ax
  104cd8:	66 90                	xchg   %ax,%ax
  104cda:	66 90                	xchg   %ax,%ax
  104cdc:	66 90                	xchg   %ax,%ax
  104cde:	66 90                	xchg   %ax,%ax
  104ce0:	66 90                	xchg   %ax,%ax
  104ce2:	66 90                	xchg   %ax,%ax
  104ce4:	66 90                	xchg   %ax,%ax
  104ce6:	66 90                	xchg   %ax,%ax
  104ce8:	66 90                	xchg   %ax,%ax
  104cea:	66 90                	xchg   %ax,%ax
  104cec:	66 90                	xchg   %ax,%ax
  104cee:	66 90                	xchg   %ax,%ax
  104cf0:	66 90                	xchg   %ax,%ax
  104cf2:	66 90                	xchg   %ax,%ax
  104cf4:	66 90                	xchg   %ax,%ax
  104cf6:	66 90                	xchg   %ax,%ax
  104cf8:	66 90                	xchg   %ax,%ax
  104cfa:	66 90                	xchg   %ax,%ax
  104cfc:	66 90                	xchg   %ax,%ax
  104cfe:	66 90                	xchg   %ax,%ax
  104d00:	66 90                	xchg   %ax,%ax
  104d02:	66 90                	xchg   %ax,%ax
  104d04:	66 90                	xchg   %ax,%ax
  104d06:	66 90                	xchg   %ax,%ax
  104d08:	66 90                	xchg   %ax,%ax
  104d0a:	66 90                	xchg   %ax,%ax
  104d0c:	66 90                	xchg   %ax,%ax
  104d0e:	66 90                	xchg   %ax,%ax
  104d10:	66 90                	xchg   %ax,%ax
  104d12:	66 90                	xchg   %ax,%ax
  104d14:	66 90                	xchg   %ax,%ax
  104d16:	66 90                	xchg   %ax,%ax
  104d18:	66 90                	xchg   %ax,%ax
  104d1a:	66 90                	xchg   %ax,%ax
  104d1c:	66 90                	xchg   %ax,%ax
  104d1e:	66 90                	xchg   %ax,%ax
  104d20:	66 90                	xchg   %ax,%ax
  104d22:	66 90                	xchg   %ax,%ax
  104d24:	66 90                	xchg   %ax,%ax
  104d26:	66 90                	xchg   %ax,%ax
  104d28:	66 90                	xchg   %ax,%ax
  104d2a:	66 90                	xchg   %ax,%ax
  104d2c:	66 90                	xchg   %ax,%ax
  104d2e:	66 90                	xchg   %ax,%ax
  104d30:	66 90                	xchg   %ax,%ax
  104d32:	66 90                	xchg   %ax,%ax
  104d34:	66 90                	xchg   %ax,%ax
  104d36:	66 90                	xchg   %ax,%ax
  104d38:	66 90                	xchg   %ax,%ax
  104d3a:	66 90                	xchg   %ax,%ax
  104d3c:	66 90                	xchg   %ax,%ax
  104d3e:	66 90                	xchg   %ax,%ax
  104d40:	66 90                	xchg   %ax,%ax
  104d42:	66 90                	xchg   %ax,%ax
  104d44:	66 90                	xchg   %ax,%ax
  104d46:	66 90                	xchg   %ax,%ax
  104d48:	66 90                	xchg   %ax,%ax
  104d4a:	66 90                	xchg   %ax,%ax
  104d4c:	66 90                	xchg   %ax,%ax
  104d4e:	66 90                	xchg   %ax,%ax
  104d50:	66 90                	xchg   %ax,%ax
  104d52:	66 90                	xchg   %ax,%ax
  104d54:	66 90                	xchg   %ax,%ax
  104d56:	66 90                	xchg   %ax,%ax
  104d58:	66 90                	xchg   %ax,%ax
  104d5a:	66 90                	xchg   %ax,%ax
  104d5c:	66 90                	xchg   %ax,%ax
  104d5e:	66 90                	xchg   %ax,%ax
  104d60:	66 90                	xchg   %ax,%ax
  104d62:	66 90                	xchg   %ax,%ax
  104d64:	66 90                	xchg   %ax,%ax
  104d66:	66 90                	xchg   %ax,%ax
  104d68:	66 90                	xchg   %ax,%ax
  104d6a:	66 90                	xchg   %ax,%ax
  104d6c:	66 90                	xchg   %ax,%ax
  104d6e:	66 90                	xchg   %ax,%ax
  104d70:	66 90                	xchg   %ax,%ax
  104d72:	66 90                	xchg   %ax,%ax
  104d74:	66 90                	xchg   %ax,%ax
  104d76:	66 90                	xchg   %ax,%ax
  104d78:	66 90                	xchg   %ax,%ax
  104d7a:	66 90                	xchg   %ax,%ax
  104d7c:	66 90                	xchg   %ax,%ax
  104d7e:	66 90                	xchg   %ax,%ax
  104d80:	66 90                	xchg   %ax,%ax
  104d82:	66 90                	xchg   %ax,%ax
  104d84:	66 90                	xchg   %ax,%ax
  104d86:	66 90                	xchg   %ax,%ax
  104d88:	66 90                	xchg   %ax,%ax
  104d8a:	66 90                	xchg   %ax,%ax
  104d8c:	66 90                	xchg   %ax,%ax
  104d8e:	66 90                	xchg   %ax,%ax
  104d90:	66 90                	xchg   %ax,%ax
  104d92:	66 90                	xchg   %ax,%ax
  104d94:	66 90                	xchg   %ax,%ax
  104d96:	66 90                	xchg   %ax,%ax
  104d98:	66 90                	xchg   %ax,%ax
  104d9a:	66 90                	xchg   %ax,%ax
  104d9c:	66 90                	xchg   %ax,%ax
  104d9e:	66 90                	xchg   %ax,%ax
  104da0:	66 90                	xchg   %ax,%ax
  104da2:	66 90                	xchg   %ax,%ax
  104da4:	66 90                	xchg   %ax,%ax
  104da6:	66 90                	xchg   %ax,%ax
  104da8:	66 90                	xchg   %ax,%ax
  104daa:	66 90                	xchg   %ax,%ax
  104dac:	66 90                	xchg   %ax,%ax
  104dae:	66 90                	xchg   %ax,%ax
  104db0:	66 90                	xchg   %ax,%ax
  104db2:	66 90                	xchg   %ax,%ax
  104db4:	66 90                	xchg   %ax,%ax
  104db6:	66 90                	xchg   %ax,%ax
  104db8:	66 90                	xchg   %ax,%ax
  104dba:	66 90                	xchg   %ax,%ax
  104dbc:	66 90                	xchg   %ax,%ax
  104dbe:	66 90                	xchg   %ax,%ax
  104dc0:	66 90                	xchg   %ax,%ax
  104dc2:	66 90                	xchg   %ax,%ax
  104dc4:	66 90                	xchg   %ax,%ax
  104dc6:	66 90                	xchg   %ax,%ax
  104dc8:	66 90                	xchg   %ax,%ax
  104dca:	66 90                	xchg   %ax,%ax
  104dcc:	66 90                	xchg   %ax,%ax
  104dce:	66 90                	xchg   %ax,%ax
  104dd0:	66 90                	xchg   %ax,%ax
  104dd2:	66 90                	xchg   %ax,%ax
  104dd4:	66 90                	xchg   %ax,%ax
  104dd6:	66 90                	xchg   %ax,%ax
  104dd8:	66 90                	xchg   %ax,%ax
  104dda:	66 90                	xchg   %ax,%ax
  104ddc:	66 90                	xchg   %ax,%ax
  104dde:	66 90                	xchg   %ax,%ax
  104de0:	66 90                	xchg   %ax,%ax
  104de2:	66 90                	xchg   %ax,%ax
  104de4:	66 90                	xchg   %ax,%ax
  104de6:	66 90                	xchg   %ax,%ax
  104de8:	66 90                	xchg   %ax,%ax
  104dea:	66 90                	xchg   %ax,%ax
  104dec:	66 90                	xchg   %ax,%ax
  104dee:	66 90                	xchg   %ax,%ax
  104df0:	66 90                	xchg   %ax,%ax
  104df2:	66 90                	xchg   %ax,%ax
  104df4:	66 90                	xchg   %ax,%ax
  104df6:	66 90                	xchg   %ax,%ax
  104df8:	66 90                	xchg   %ax,%ax
  104dfa:	66 90                	xchg   %ax,%ax
  104dfc:	66 90                	xchg   %ax,%ax
  104dfe:	66 90                	xchg   %ax,%ax
  104e00:	66 90                	xchg   %ax,%ax
  104e02:	66 90                	xchg   %ax,%ax
  104e04:	66 90                	xchg   %ax,%ax
  104e06:	66 90                	xchg   %ax,%ax
  104e08:	66 90                	xchg   %ax,%ax
  104e0a:	66 90                	xchg   %ax,%ax
  104e0c:	66 90                	xchg   %ax,%ax
  104e0e:	66 90                	xchg   %ax,%ax
  104e10:	66 90                	xchg   %ax,%ax
  104e12:	66 90                	xchg   %ax,%ax
  104e14:	66 90                	xchg   %ax,%ax
  104e16:	66 90                	xchg   %ax,%ax
  104e18:	66 90                	xchg   %ax,%ax
  104e1a:	66 90                	xchg   %ax,%ax
  104e1c:	66 90                	xchg   %ax,%ax
  104e1e:	66 90                	xchg   %ax,%ax
  104e20:	66 90                	xchg   %ax,%ax
  104e22:	66 90                	xchg   %ax,%ax
  104e24:	66 90                	xchg   %ax,%ax
  104e26:	66 90                	xchg   %ax,%ax
  104e28:	66 90                	xchg   %ax,%ax
  104e2a:	66 90                	xchg   %ax,%ax
  104e2c:	66 90                	xchg   %ax,%ax
  104e2e:	66 90                	xchg   %ax,%ax
  104e30:	66 90                	xchg   %ax,%ax
  104e32:	66 90                	xchg   %ax,%ax
  104e34:	66 90                	xchg   %ax,%ax
  104e36:	66 90                	xchg   %ax,%ax
  104e38:	66 90                	xchg   %ax,%ax
  104e3a:	66 90                	xchg   %ax,%ax
  104e3c:	66 90                	xchg   %ax,%ax
  104e3e:	66 90                	xchg   %ax,%ax
  104e40:	66 90                	xchg   %ax,%ax
  104e42:	66 90                	xchg   %ax,%ax
  104e44:	66 90                	xchg   %ax,%ax
  104e46:	66 90                	xchg   %ax,%ax
  104e48:	66 90                	xchg   %ax,%ax
  104e4a:	66 90                	xchg   %ax,%ax
  104e4c:	66 90                	xchg   %ax,%ax
  104e4e:	66 90                	xchg   %ax,%ax
  104e50:	66 90                	xchg   %ax,%ax
  104e52:	66 90                	xchg   %ax,%ax
  104e54:	66 90                	xchg   %ax,%ax
  104e56:	66 90                	xchg   %ax,%ax
  104e58:	66 90                	xchg   %ax,%ax
  104e5a:	66 90                	xchg   %ax,%ax
  104e5c:	66 90                	xchg   %ax,%ax
  104e5e:	66 90                	xchg   %ax,%ax
  104e60:	66 90                	xchg   %ax,%ax
  104e62:	66 90                	xchg   %ax,%ax
  104e64:	66 90                	xchg   %ax,%ax
  104e66:	66 90                	xchg   %ax,%ax
  104e68:	66 90                	xchg   %ax,%ax
  104e6a:	66 90                	xchg   %ax,%ax
  104e6c:	66 90                	xchg   %ax,%ax
  104e6e:	66 90                	xchg   %ax,%ax
  104e70:	66 90                	xchg   %ax,%ax
  104e72:	66 90                	xchg   %ax,%ax
  104e74:	66 90                	xchg   %ax,%ax
  104e76:	66 90                	xchg   %ax,%ax
  104e78:	66 90                	xchg   %ax,%ax
  104e7a:	66 90                	xchg   %ax,%ax
  104e7c:	66 90                	xchg   %ax,%ax
  104e7e:	66 90                	xchg   %ax,%ax
  104e80:	66 90                	xchg   %ax,%ax
  104e82:	66 90                	xchg   %ax,%ax
  104e84:	66 90                	xchg   %ax,%ax
  104e86:	66 90                	xchg   %ax,%ax
  104e88:	66 90                	xchg   %ax,%ax
  104e8a:	66 90                	xchg   %ax,%ax
  104e8c:	66 90                	xchg   %ax,%ax
  104e8e:	66 90                	xchg   %ax,%ax
  104e90:	66 90                	xchg   %ax,%ax
  104e92:	66 90                	xchg   %ax,%ax
  104e94:	66 90                	xchg   %ax,%ax
  104e96:	66 90                	xchg   %ax,%ax
  104e98:	66 90                	xchg   %ax,%ax
  104e9a:	66 90                	xchg   %ax,%ax
  104e9c:	66 90                	xchg   %ax,%ax
  104e9e:	66 90                	xchg   %ax,%ax
  104ea0:	66 90                	xchg   %ax,%ax
  104ea2:	66 90                	xchg   %ax,%ax
  104ea4:	66 90                	xchg   %ax,%ax
  104ea6:	66 90                	xchg   %ax,%ax
  104ea8:	66 90                	xchg   %ax,%ax
  104eaa:	66 90                	xchg   %ax,%ax
  104eac:	66 90                	xchg   %ax,%ax
  104eae:	66 90                	xchg   %ax,%ax
  104eb0:	66 90                	xchg   %ax,%ax
  104eb2:	66 90                	xchg   %ax,%ax
  104eb4:	66 90                	xchg   %ax,%ax
  104eb6:	66 90                	xchg   %ax,%ax
  104eb8:	66 90                	xchg   %ax,%ax
  104eba:	66 90                	xchg   %ax,%ax
  104ebc:	66 90                	xchg   %ax,%ax
  104ebe:	66 90                	xchg   %ax,%ax
  104ec0:	66 90                	xchg   %ax,%ax
  104ec2:	66 90                	xchg   %ax,%ax
  104ec4:	66 90                	xchg   %ax,%ax
  104ec6:	66 90                	xchg   %ax,%ax
  104ec8:	66 90                	xchg   %ax,%ax
  104eca:	66 90                	xchg   %ax,%ax
  104ecc:	66 90                	xchg   %ax,%ax
  104ece:	66 90                	xchg   %ax,%ax
  104ed0:	66 90                	xchg   %ax,%ax
  104ed2:	66 90                	xchg   %ax,%ax
  104ed4:	66 90                	xchg   %ax,%ax
  104ed6:	66 90                	xchg   %ax,%ax
  104ed8:	66 90                	xchg   %ax,%ax
  104eda:	66 90                	xchg   %ax,%ax
  104edc:	66 90                	xchg   %ax,%ax
  104ede:	66 90                	xchg   %ax,%ax
  104ee0:	66 90                	xchg   %ax,%ax
  104ee2:	66 90                	xchg   %ax,%ax
  104ee4:	66 90                	xchg   %ax,%ax
  104ee6:	66 90                	xchg   %ax,%ax
  104ee8:	66 90                	xchg   %ax,%ax
  104eea:	66 90                	xchg   %ax,%ax
  104eec:	66 90                	xchg   %ax,%ax
  104eee:	66 90                	xchg   %ax,%ax
  104ef0:	66 90                	xchg   %ax,%ax
  104ef2:	66 90                	xchg   %ax,%ax
  104ef4:	66 90                	xchg   %ax,%ax
  104ef6:	66 90                	xchg   %ax,%ax
  104ef8:	66 90                	xchg   %ax,%ax
  104efa:	66 90                	xchg   %ax,%ax
  104efc:	66 90                	xchg   %ax,%ax
  104efe:	66 90                	xchg   %ax,%ax
  104f00:	66 90                	xchg   %ax,%ax
  104f02:	66 90                	xchg   %ax,%ax
  104f04:	66 90                	xchg   %ax,%ax
  104f06:	66 90                	xchg   %ax,%ax
  104f08:	66 90                	xchg   %ax,%ax
  104f0a:	66 90                	xchg   %ax,%ax
  104f0c:	66 90                	xchg   %ax,%ax
  104f0e:	66 90                	xchg   %ax,%ax
  104f10:	66 90                	xchg   %ax,%ax
  104f12:	66 90                	xchg   %ax,%ax
  104f14:	66 90                	xchg   %ax,%ax
  104f16:	66 90                	xchg   %ax,%ax
  104f18:	66 90                	xchg   %ax,%ax
  104f1a:	66 90                	xchg   %ax,%ax
  104f1c:	66 90                	xchg   %ax,%ax
  104f1e:	66 90                	xchg   %ax,%ax
  104f20:	66 90                	xchg   %ax,%ax
  104f22:	66 90                	xchg   %ax,%ax
  104f24:	66 90                	xchg   %ax,%ax
  104f26:	66 90                	xchg   %ax,%ax
  104f28:	66 90                	xchg   %ax,%ax
  104f2a:	66 90                	xchg   %ax,%ax
  104f2c:	66 90                	xchg   %ax,%ax
  104f2e:	66 90                	xchg   %ax,%ax
  104f30:	66 90                	xchg   %ax,%ax
  104f32:	66 90                	xchg   %ax,%ax
  104f34:	66 90                	xchg   %ax,%ax
  104f36:	66 90                	xchg   %ax,%ax
  104f38:	66 90                	xchg   %ax,%ax
  104f3a:	66 90                	xchg   %ax,%ax
  104f3c:	66 90                	xchg   %ax,%ax
  104f3e:	66 90                	xchg   %ax,%ax
  104f40:	66 90                	xchg   %ax,%ax
  104f42:	66 90                	xchg   %ax,%ax
  104f44:	66 90                	xchg   %ax,%ax
  104f46:	66 90                	xchg   %ax,%ax
  104f48:	66 90                	xchg   %ax,%ax
  104f4a:	66 90                	xchg   %ax,%ax
  104f4c:	66 90                	xchg   %ax,%ax
  104f4e:	66 90                	xchg   %ax,%ax
  104f50:	66 90                	xchg   %ax,%ax
  104f52:	66 90                	xchg   %ax,%ax
  104f54:	66 90                	xchg   %ax,%ax
  104f56:	66 90                	xchg   %ax,%ax
  104f58:	66 90                	xchg   %ax,%ax
  104f5a:	66 90                	xchg   %ax,%ax
  104f5c:	66 90                	xchg   %ax,%ax
  104f5e:	66 90                	xchg   %ax,%ax
  104f60:	66 90                	xchg   %ax,%ax
  104f62:	66 90                	xchg   %ax,%ax
  104f64:	66 90                	xchg   %ax,%ax
  104f66:	66 90                	xchg   %ax,%ax
  104f68:	66 90                	xchg   %ax,%ax
  104f6a:	66 90                	xchg   %ax,%ax
  104f6c:	66 90                	xchg   %ax,%ax
  104f6e:	66 90                	xchg   %ax,%ax
  104f70:	66 90                	xchg   %ax,%ax
  104f72:	66 90                	xchg   %ax,%ax
  104f74:	66 90                	xchg   %ax,%ax
  104f76:	66 90                	xchg   %ax,%ax
  104f78:	66 90                	xchg   %ax,%ax
  104f7a:	66 90                	xchg   %ax,%ax
  104f7c:	66 90                	xchg   %ax,%ax
  104f7e:	66 90                	xchg   %ax,%ax
  104f80:	66 90                	xchg   %ax,%ax
  104f82:	66 90                	xchg   %ax,%ax
  104f84:	66 90                	xchg   %ax,%ax
  104f86:	66 90                	xchg   %ax,%ax
  104f88:	66 90                	xchg   %ax,%ax
  104f8a:	66 90                	xchg   %ax,%ax
  104f8c:	66 90                	xchg   %ax,%ax
  104f8e:	66 90                	xchg   %ax,%ax
  104f90:	66 90                	xchg   %ax,%ax
  104f92:	66 90                	xchg   %ax,%ax
  104f94:	66 90                	xchg   %ax,%ax
  104f96:	66 90                	xchg   %ax,%ax
  104f98:	66 90                	xchg   %ax,%ax
  104f9a:	66 90                	xchg   %ax,%ax
  104f9c:	66 90                	xchg   %ax,%ax
  104f9e:	66 90                	xchg   %ax,%ax
  104fa0:	66 90                	xchg   %ax,%ax
  104fa2:	66 90                	xchg   %ax,%ax
  104fa4:	66 90                	xchg   %ax,%ax
  104fa6:	66 90                	xchg   %ax,%ax
  104fa8:	66 90                	xchg   %ax,%ax
  104faa:	66 90                	xchg   %ax,%ax
  104fac:	66 90                	xchg   %ax,%ax
  104fae:	66 90                	xchg   %ax,%ax
  104fb0:	66 90                	xchg   %ax,%ax
  104fb2:	66 90                	xchg   %ax,%ax
  104fb4:	66 90                	xchg   %ax,%ax
  104fb6:	66 90                	xchg   %ax,%ax
  104fb8:	66 90                	xchg   %ax,%ax
  104fba:	66 90                	xchg   %ax,%ax
  104fbc:	66 90                	xchg   %ax,%ax
  104fbe:	66 90                	xchg   %ax,%ax
  104fc0:	66 90                	xchg   %ax,%ax
  104fc2:	66 90                	xchg   %ax,%ax
  104fc4:	66 90                	xchg   %ax,%ax
  104fc6:	66 90                	xchg   %ax,%ax
  104fc8:	66 90                	xchg   %ax,%ax
  104fca:	66 90                	xchg   %ax,%ax
  104fcc:	66 90                	xchg   %ax,%ax
  104fce:	66 90                	xchg   %ax,%ax
  104fd0:	66 90                	xchg   %ax,%ax
  104fd2:	66 90                	xchg   %ax,%ax
  104fd4:	66 90                	xchg   %ax,%ax
  104fd6:	66 90                	xchg   %ax,%ax
  104fd8:	66 90                	xchg   %ax,%ax
  104fda:	66 90                	xchg   %ax,%ax
  104fdc:	66 90                	xchg   %ax,%ax
  104fde:	66 90                	xchg   %ax,%ax
  104fe0:	66 90                	xchg   %ax,%ax
  104fe2:	66 90                	xchg   %ax,%ax
  104fe4:	66 90                	xchg   %ax,%ax
  104fe6:	66 90                	xchg   %ax,%ax
  104fe8:	66 90                	xchg   %ax,%ax
  104fea:	66 90                	xchg   %ax,%ax
  104fec:	66 90                	xchg   %ax,%ax
  104fee:	66 90                	xchg   %ax,%ax
  104ff0:	66 90                	xchg   %ax,%ax
  104ff2:	66 90                	xchg   %ax,%ax
  104ff4:	66 90                	xchg   %ax,%ax
  104ff6:	66 90                	xchg   %ax,%ax
  104ff8:	66 90                	xchg   %ax,%ax
  104ffa:	66 90                	xchg   %ax,%ax
  104ffc:	66 90                	xchg   %ax,%ax
  104ffe:	66 90                	xchg   %ax,%ax
